import _ from 'lodash';
import { Config, PageModel, DataModel, FieldObjectProps, FieldSpecificProps, mapModelFieldsRecursively, ObjectModel } from '@stackbit/sdk';
import * as StackbitTypes from '@stackbit/types';
import { mapPromise, omitByNil } from '@stackbit/utils';
import * as ContentStoreTypes from '../types';
import {
    CustomActionStateChange,
    APICustomAction,
    APICustomActionDocumentSpecifier,
    APICustomActionDocument,
    APICustomActionObject,
    APICustomActionField,
    APIGetCustomActionRequest,
    APIRunCustomActionRequest,
    APIRunCustomActionRequestBulk,
    CustomActionRunStateMap,
    ExtendedCustomActionDocument,
    ExtendedCustomActionObjectModel,
    ExtendedCustomActionField,
    APICustomActionGlobal,
    APICustomActionBulk,
    ExtendedCustomAction,
    ExtendedCustomActionObjectField
} from '../types';
import { createConfigDelegate } from './config-delegate';
import { getContentSourceActionsForSourceThunk } from './document-hooks';
import { mapStoreDocumentToCSIDocumentWithSource, mapStoreFieldToCSIField } from './store-to-csi-docs-converter';
import { getModelAndDocumentFieldForLocalizedFieldPath } from './field-path-utils';
import { getContentSourceDataByTypeAndProjectIdOrThrow, getUserContextForSrcTypeThunk } from '../content-store-utils';

/**
 * Removes "run" and "state" functions from actions of models, nested objects and fields.
 * Sets "needsResolving" flag to let client know if the action needs additional resolving.
 * @param {StackbitTypes.ModelMap} modelMap
 */
export function stripModelActions({ modelMap }: { modelMap: StackbitTypes.ModelMap }): StackbitTypes.ModelMap {
    return _.mapValues(modelMap, (model) => {
        if ('actions' in model) {
            const { actions, ...restModel } = model;
            model = restModel;
        }

        model = mapModelFieldsRecursively(model, (field) => {
            if ('actions' in field && Array.isArray(field.actions)) {
                const { actions, ...restField } = field;
                field = restField;
            }
            return field;
        });

        return model;
    });
}

export async function getGlobalAndBulkAPIActions({
    stackbitConfig,
    customActionRunStateMap,
    contentSourceDataById,
    userLogger,
    pageUrl,
    user,
    locale,
    currentPageDocument
}: {
    stackbitConfig: Config | null;
    customActionRunStateMap: CustomActionRunStateMap;
    contentSourceDataById: Record<string, ContentStoreTypes.ContentSourceData>;
    userLogger: StackbitTypes.Logger;
    pageUrl?: string;
    user?: ContentStoreTypes.User;
    locale?: string;
    currentPageDocument?: APICustomActionDocumentSpecifier;
}): Promise<(APICustomActionGlobal | APICustomActionBulk)[]> {
    if (!stackbitConfig || !Array.isArray(stackbitConfig.actions)) {
        return [];
    }

    const configDelegate = createConfigDelegate({
        contentSourceDataById: contentSourceDataById,
        logger: userLogger
    });

    return mapPromise(stackbitConfig.actions, async (action) => {
        const actionId = globalActionId(action);
        const actionRunState = customActionRunStateMap[actionId];
        let state: StackbitTypes.CustomActionState | 'unknown';

        if (actionRunState?.runningHandler) {
            state = 'running';
        } else if (action.state) {
            const pageDocument = getCSIDocumentWithSourceFromDocumentSpec(currentPageDocument, configDelegate);
            state = await action.state({
                actionId: actionId,
                currentLocale: locale,
                currentUser: user ? { name: user.name, email: user.email } : undefined,
                currentPageUrl: pageUrl,
                currentPageDocument: pageDocument,
                ...configDelegate
            });
        } else {
            state = actionRunState?.lastResultState ?? 'enabled';
        }

        return omitByNil({
            type: action.type,
            actionId: actionId,
            name: action.name,
            label: action.label ?? _.startCase(action.name),
            icon: action.icon,
            state: state,
            inputFields: action.inputFields
        });
    });
}

export function getDocumentActionsThunk({
    csiDocument,
    model,
    srcType,
    srcProjectId,
    customActionRunStateMap
}: {
    csiDocument: StackbitTypes.Document;
    model: PageModel | DataModel;
    srcType: string;
    srcProjectId: string;
    customActionRunStateMap: ContentStoreTypes.CustomActionRunStateMap;
}): () => APICustomActionDocument[] | undefined {
    if (!('actions' in model) || !Array.isArray(model.actions)) {
        return () => undefined;
    }

    const extendedDocumentActions = model.actions.map((action): ExtendedCustomActionDocument => {
        const documentSpec = {
            srcType: srcType,
            srcProjectId: srcProjectId,
            srcDocumentId: csiDocument.id
        };
        return {
            // if configuration is updated, the new action properties will override the stored action properties
            ...action,
            type: 'document',
            actionId: documentActionId({ ...documentSpec, actionName: action.name }),
            label: action.label ?? _.startCase(action.name),
            documentSpec: documentSpec
        };
    });

    return () =>
        extendedDocumentActions.map((extendedAction) => {
            return omitByNil({
                type: 'document',
                actionId: extendedAction.actionId,
                name: extendedAction.name,
                label: extendedAction.label,
                icon: extendedAction.icon,
                inputFields: extendedAction.inputFields,
                ...getAPIActionState(extendedAction, customActionRunStateMap)
            });
        });
}

export function getObjectModelActionsThunk({
    model,
    csiParentDocument,
    srcType,
    srcProjectId,
    customActionRunStateMap,
    fieldPath
}: {
    model: ObjectModel;
    csiParentDocument: StackbitTypes.Document;
    srcType: string;
    srcProjectId: string;
    customActionRunStateMap: ContentStoreTypes.CustomActionRunStateMap;
    fieldPath: (string | number)[];
}): () => ContentStoreTypes.APICustomActionObject[] | undefined {
    if (!('actions' in model) || !Array.isArray(model.actions)) {
        return () => undefined;
    }

    const extendedObjectModelActions = model.actions.map((action): ExtendedCustomActionObjectModel => {
        const documentSpec = {
            srcType: srcType,
            srcProjectId: srcProjectId,
            srcDocumentId: csiParentDocument.id
        };
        return {
            // if configuration is updated, the new action properties will override the stored action properties
            ...action,
            type: 'objectModel',
            actionId: fieldPathActionId({ ...documentSpec, fieldPath, actionName: action.name }),
            label: action.label ?? _.startCase(action.name),
            documentSpec: documentSpec,
            fieldPath
        };
    });

    return () =>
        extendedObjectModelActions.map((extendedAction) => {
            return omitByNil({
                type: 'object',
                actionId: extendedAction.actionId,
                name: extendedAction.name,
                label: extendedAction.label,
                icon: extendedAction.icon,
                inputFields: extendedAction.inputFields,
                ...getAPIActionState(extendedAction, customActionRunStateMap)
            });
        });
}

export function getObjectFieldActionsThunk({
    modelField,
    csiParentDocument,
    srcType,
    srcProjectId,
    customActionRunStateMap,
    fieldPath
}: {
    modelField: FieldObjectProps;
    csiParentDocument: StackbitTypes.Document;
    srcType: string;
    srcProjectId: string;
    customActionRunStateMap: ContentStoreTypes.CustomActionRunStateMap;
    fieldPath: (string | number)[];
}): () => APICustomActionObject[] | undefined {
    if (!('actions' in modelField) || !Array.isArray(modelField.actions)) {
        return () => undefined;
    }
    const objectFieldActions = modelField.actions.filter((action): action is StackbitTypes.CustomActionObjectField => action.type === 'object');

    const extendedObjectFieldActions = objectFieldActions.map((action): ExtendedCustomActionObjectField => {
        const documentSpec = {
            srcType: srcType,
            srcProjectId: srcProjectId,
            srcDocumentId: csiParentDocument.id
        };
        return {
            // if configuration is updated, the new action properties will override the stored action properties
            ...action,
            type: 'objectField',
            actionId: fieldPathActionId({ ...documentSpec, fieldPath, actionName: action.name }),
            label: action.label ?? _.startCase(action.name),
            documentSpec: documentSpec,
            fieldPath
        };
    });

    return () =>
        extendedObjectFieldActions.map((extendedAction) => {
            return omitByNil({
                type: 'object',
                actionId: extendedAction.actionId,
                name: extendedAction.name,
                label: extendedAction.label,
                icon: extendedAction.icon,
                inputFields: extendedAction.inputFields,
                ...getAPIActionState(extendedAction, customActionRunStateMap)
            });
        });
}

export function getFieldActions({
    modelField,
    csiParentDocument,
    srcType,
    srcProjectId,
    customActionRunStateMap,
    fieldPath
}: {
    modelField: FieldSpecificProps;
    csiParentDocument: StackbitTypes.Document;
    srcType: string;
    srcProjectId: string;
    customActionRunStateMap: ContentStoreTypes.CustomActionRunStateMap;
    fieldPath: (string | number)[];
}): APICustomActionField[] | undefined {
    if (!('actions' in modelField) || !Array.isArray(modelField.actions)) {
        return undefined;
    }
    const fieldActions = modelField.actions.filter((action): action is StackbitTypes.CustomActionField => action.type !== 'object');

    const extendedFieldActions = fieldActions.map((action): ExtendedCustomActionField => {
        const documentSpec = {
            srcType: srcType,
            srcProjectId: srcProjectId,
            srcDocumentId: csiParentDocument.id
        };
        return {
            // if configuration is updated, the new action properties will override the stored action properties
            ...action,
            type: 'field',
            actionId: fieldPathActionId({ ...documentSpec, fieldPath, actionName: action.name }),
            label: action.label ?? _.startCase(action.name),
            documentSpec: documentSpec,
            fieldPath
        };
    });

    return extendedFieldActions.map((extendedAction) => {
        return omitByNil({
            type: 'field',
            actionId: extendedAction.actionId,
            name: extendedAction.name,
            label: extendedAction.label,
            icon: extendedAction.icon,
            inputFields: extendedAction.inputFields,
            ...getAPIActionState(extendedAction, customActionRunStateMap)
        });
    });
}

export async function resolveCustomActionsById({
    getActionRequest,
    customActionRunStateMap,
    contentSourceDataById,
    stackbitConfig,
    userLogger
}: {
    getActionRequest: APIGetCustomActionRequest;
    customActionRunStateMap: CustomActionRunStateMap;
    contentSourceDataById: Record<string, ContentStoreTypes.ContentSourceData>;
    stackbitConfig: Config | null;
    userLogger: StackbitTypes.Logger;
}): Promise<APICustomAction[]> {
    const result: APICustomAction[] = [];
    const { customActionIds, locale, user, pageUrl, currentPageDocument } = getActionRequest;

    const configDelegate = createConfigDelegate({
        contentSourceDataById,
        logger: userLogger
    });

    for (const actionId of customActionIds) {
        const extendedAction = findCustomActionById({
            actionId,
            customActionRunStateMap,
            contentSourceDataById,
            stackbitConfig
        });
        if (!extendedAction) {
            userLogger.debug(`custom action with id: '${actionId}' was not found`);
            continue;
        }

        try {
            let state: StackbitTypes.CustomActionState;
            if (extendedAction.runningHandler) {
                state = 'running';
            } else if (extendedAction.state) {
                const pageDocument = getCSIDocumentWithSourceFromDocumentSpec(currentPageDocument, configDelegate);
                const commonStateOptions: StackbitTypes.CustomActionStateCommonOptions = {
                    actionId: actionId,
                    currentLocale: locale,
                    currentUser: user
                        ? {
                              name: user.name,
                              email: user.email
                          }
                        : undefined,
                    currentPageUrl: pageUrl,
                    currentPageDocument: pageDocument,
                    ...configDelegate
                };
                if (extendedAction.type === 'global' || extendedAction.type === 'bulk') {
                    state = await extendedAction.state(commonStateOptions);
                } else if (extendedAction.type === 'document') {
                    const { document, model } = getCSIDocumentAndModelWithSourceFromDocumentSpec({
                        documentSpec: extendedAction.documentSpec,
                        contentSourceDataById
                    });
                    state = await extendedAction.state({
                        ...commonStateOptions,
                        document: document,
                        model: model
                    });
                } else if (extendedAction.type === 'objectModel') {
                    const stateObjectParams = getHandlerParamsForObjectModelAction({
                        extendedAction,
                        contentSourceDataById
                    });
                    state = await extendedAction.state({
                        ...commonStateOptions,
                        ...stateObjectParams
                    });
                } else if (extendedAction.type === 'objectField') {
                    const stateObjectParams = getHandlerParamsForObjectFieldAction({
                        extendedAction,
                        contentSourceDataById
                    });
                    state = await extendedAction.state({
                        ...commonStateOptions,
                        ...stateObjectParams
                    });
                } else if (extendedAction.type === 'field') {
                    const stateFieldParams = getHandlerParamsForFieldAction({
                        extendedAction,
                        contentSourceDataById
                    });
                    state = await extendedAction.state({
                        ...commonStateOptions,
                        ...stateFieldParams
                    });
                } else {
                    const _exhaustiveCheck: never = extendedAction;
                    continue;
                }
            } else {
                state = extendedAction.lastResultState ?? 'enabled';
            }
            result.push(
                omitByNil({
                    actionId: actionId,
                    type: storeActionTypeToAPIActionType(extendedAction.type),
                    name: extendedAction.name,
                    label: extendedAction.label,
                    icon: extendedAction.icon,
                    state: state,
                    inputFields: extendedAction.inputFields
                })
            );
        } catch (error: any) {
            userLogger.warn(`getCustomActionsById: error resolving custom action, id: '${actionId}', error: ${error.message}`);
        }
    }

    return result;
}

export function runCustomAction({
    runActionRequest,
    customActionRunStateMap,
    contentSourceDataById,
    stackbitConfig,
    userLogger
}: {
    runActionRequest: APIRunCustomActionRequest;
    customActionRunStateMap: CustomActionRunStateMap;
    contentSourceDataById: Record<string, ContentStoreTypes.ContentSourceData>;
    stackbitConfig: Config | null;
    userLogger: StackbitTypes.Logger;
}): Promise<CustomActionStateChange> {
    const extendedAction = findCustomActionById({
        actionId: runActionRequest.actionId,
        customActionRunStateMap,
        contentSourceDataById,
        stackbitConfig
    });
    if (!extendedAction) {
        throw new Error(`Error running action: action not found, action name: '${runActionRequest.actionName}' action ID: '${runActionRequest.actionId}'.`);
    }
    const prevResultState = extendedAction.lastResultState;
    if (extendedAction.lastResultState && extendedAction.lastResultState !== 'enabled') {
        throw new Error(
            `Error running action: action is not enabled, action name: '${runActionRequest.actionName}' action ID: '${runActionRequest.actionId}'.`
        );
    }

    try {
        const actionLogger = userLogger.createLogger({ label: `action:${extendedAction.name}` });
        const configDelegate = createConfigDelegate({ contentSourceDataById: contentSourceDataById, logger: actionLogger });
        const currentPageDocument = getCSIDocumentWithSourceFromDocumentSpec(runActionRequest.currentPageDocument, configDelegate);

        customActionRunStateMap[runActionRequest.actionId] = {
            runningHandler: true,
            lastResultState: 'running'
        };

        const commonRunOptions: StackbitTypes.CustomActionRunCommonOptions = {
            actionId: extendedAction.actionId,
            inputData: runActionRequest.inputData,
            currentLocale: runActionRequest.locale,
            currentUser: runActionRequest.user,
            currentPageUrl: runActionRequest.pageUrl,
            currentPageDocument: currentPageDocument,
            getContentSourceActionsForSource: getContentSourceActionsForSourceThunk({
                getContentSourceDataById: () => contentSourceDataById,
                logger: userLogger,
                user: runActionRequest.user,
                stackbitConfig: stackbitConfig
            }),
            getUserContextForContentSourceType: getUserContextForSrcTypeThunk(runActionRequest.user),
            ...configDelegate
        };

        let promise;

        if (extendedAction.type === 'global') {
            promise = extendedAction.run(commonRunOptions);
        } else if (extendedAction.type === 'bulk') {
            const documents = (runActionRequest as APIRunCustomActionRequestBulk).documents.map((documentSpec) => {
                const { document } = getCSIDocumentAndModelWithSourceFromDocumentSpec({
                    documentSpec,
                    contentSourceDataById
                });
                return document;
            });
            promise = extendedAction.run({
                ...commonRunOptions,
                documents
            });
        } else if (extendedAction.type === 'document') {
            const { document, model } = getCSIDocumentAndModelWithSourceFromDocumentSpec({
                documentSpec: extendedAction.documentSpec,
                contentSourceDataById
            });
            promise = extendedAction.run({
                ...commonRunOptions,
                document,
                model,
                contentSourceActions: commonRunOptions.getContentSourceActionsForSource({
                    srcType: extendedAction.documentSpec.srcType,
                    srcProjectId: extendedAction.documentSpec.srcProjectId
                })!
            });
        } else if (extendedAction.type === 'objectModel') {
            const handlerObjectParams = getHandlerParamsForObjectModelAction({
                extendedAction,
                contentSourceDataById
            });
            promise = extendedAction.run({
                ...commonRunOptions,
                ...handlerObjectParams,
                contentSourceActions: commonRunOptions.getContentSourceActionsForSource({
                    srcType: extendedAction.documentSpec.srcType,
                    srcProjectId: extendedAction.documentSpec.srcProjectId
                })!
            });
        } else if (extendedAction.type === 'objectField') {
            const handlerObjectParams = getHandlerParamsForObjectFieldAction({
                extendedAction,
                contentSourceDataById
            });
            promise = extendedAction.run({
                ...commonRunOptions,
                ...handlerObjectParams,
                contentSourceActions: commonRunOptions.getContentSourceActionsForSource({
                    srcType: extendedAction.documentSpec.srcType,
                    srcProjectId: extendedAction.documentSpec.srcProjectId
                })!
            });
        } else if (extendedAction.type === 'field') {
            const handlerFieldParams = getHandlerParamsForFieldAction({ extendedAction, contentSourceDataById });
            promise = extendedAction.run({
                ...commonRunOptions,
                ...handlerFieldParams,
                contentSourceActions: commonRunOptions.getContentSourceActionsForSource({
                    srcType: extendedAction.documentSpec.srcType,
                    srcProjectId: extendedAction.documentSpec.srcProjectId
                })!
            });
        } else {
            throw new Error(`action type ${(extendedAction as any).type} not supported`);
        }

        return promise
            .then((actionResult) => {
                customActionRunStateMap[runActionRequest.actionId] = {
                    runningHandler: false,
                    lastResultState: actionResult?.state
                };
                userLogger.debug(`Action completed: ${extendedAction.actionId}`);
                return Promise.resolve(
                    omitByNil({
                        actionId: extendedAction.actionId,
                        actionName: extendedAction.name,
                        actionType: storeActionTypeToAPIActionType(extendedAction.type),
                        // TODO: resolve the state if state function is defined
                        state: actionResult?.state ?? 'enabled',
                        success: actionResult?.success,
                        error: actionResult?.error
                    })
                );
            })
            .catch((error: any) => {
                customActionRunStateMap[runActionRequest.actionId] = {
                    runningHandler: false,
                    lastResultState: prevResultState
                };
                userLogger.debug(`Error running action: ${error.message}`);
                return Promise.resolve({
                    actionId: extendedAction.actionId,
                    actionName: extendedAction.name,
                    actionType: storeActionTypeToAPIActionType(extendedAction.type),
                    // TODO: resolve the state if state function is defined
                    state: prevResultState ?? 'enabled',
                    error: `Error running action: ${error.message}`
                });
            });
    } catch (error: any) {
        if (customActionRunStateMap[runActionRequest.actionId]) {
            customActionRunStateMap[runActionRequest.actionId] = {
                runningHandler: false,
                lastResultState: prevResultState
            };
        }
        userLogger.debug(`Error running action: ${error.message}`);
        return Promise.resolve({
            actionId: runActionRequest.actionId,
            actionName: extendedAction?.name ?? runActionRequest.actionName,
            actionType: storeActionTypeToAPIActionType(extendedAction?.type) ?? runActionRequest.actionType,
            // TODO: resolve the state if state function is defined
            state: prevResultState ?? 'enabled',
            error: `Error running action: ${error.message}`
        });
    }
}

function getCSIDocumentWithSourceFromDocumentSpec(
    documentSpec: APICustomActionDocumentSpecifier | undefined,
    configDelegate: StackbitTypes.ConfigDelegate
): StackbitTypes.DocumentWithSource | undefined {
    return documentSpec
        ? configDelegate.getDocumentById({
              id: documentSpec.srcDocumentId,
              srcType: documentSpec.srcType,
              srcProjectId: documentSpec.srcProjectId
          })
        : undefined;
}

function getAPIActionState(
    extendedAction: ExtendedCustomAction,
    customActionRunStateMap: CustomActionRunStateMap
): {
    state: StackbitTypes.CustomActionState | 'unknown';
    needsResolving: boolean;
} {
    const actionId = extendedAction.actionId;
    const actionRunState = customActionRunStateMap[actionId];
    let state: StackbitTypes.CustomActionState | 'unknown';
    let needsResolving = false;
    if (actionRunState?.runningHandler) {
        state = 'running';
    } else if (extendedAction.state) {
        state = 'unknown';
        needsResolving = true;
    } else {
        state = actionRunState?.lastResultState ?? 'enabled';
    }
    return { state, needsResolving };
}

function getHandlerParamsForObjectModelAction({
    extendedAction,
    contentSourceDataById
}: {
    extendedAction: Pick<ExtendedCustomActionObjectModel, 'documentSpec' | 'fieldPath'>;
    contentSourceDataById: Record<string, ContentStoreTypes.ContentSourceData>;
}): StackbitTypes.CustomActionObjectModelStateParams {
    const fieldActionCommonParams = getHandlerParamsForFieldAction({
        extendedAction,
        contentSourceDataById
    });

    if (!fieldActionCommonParams.documentField) {
        throw new Error(`object document field not found at field path: ${extendedAction.fieldPath.join('.')}`);
    }

    const documentField = fieldActionCommonParams.documentField as StackbitTypes.DocumentModelFieldNonLocalized;
    const documentSpec = extendedAction.documentSpec;
    const contentSourceData = getContentSourceDataByTypeAndProjectIdOrThrow(documentSpec.srcType, documentSpec.srcProjectId, contentSourceDataById);
    const objectModel = contentSourceData.modelMap[documentField.modelName];
    if (!objectModel || objectModel.type !== 'object') {
        throw new Error(`object model '${documentField.modelName}' not found`);
    }

    return {
        ...fieldActionCommonParams,
        documentField,
        modelField: fieldActionCommonParams.modelField as StackbitTypes.FieldModel,
        objectModel: {
            ...objectModel,
            srcType: documentSpec.srcType,
            srcProjectId: documentSpec.srcProjectId
        }
    };
}

function getHandlerParamsForObjectFieldAction({
    extendedAction,
    contentSourceDataById
}: {
    extendedAction: Pick<ExtendedCustomActionObjectField, 'documentSpec' | 'fieldPath'>;
    contentSourceDataById: Record<string, ContentStoreTypes.ContentSourceData>;
}): StackbitTypes.CustomActionObjectFieldStateParams {
    const fieldActionCommonParams = getHandlerParamsForFieldAction({
        extendedAction,
        contentSourceDataById
    });

    if (!fieldActionCommonParams.documentField) {
        throw new Error(`object document field not found at field path: ${extendedAction.fieldPath.join('.')}`);
    }

    return {
        ...fieldActionCommonParams,
        documentField: fieldActionCommonParams.documentField as StackbitTypes.DocumentObjectFieldNonLocalized,
        modelField: fieldActionCommonParams.modelField as StackbitTypes.FieldObject
    };
}

function getHandlerParamsForFieldAction({
    extendedAction,
    contentSourceDataById
}: {
    extendedAction: Pick<ExtendedCustomActionField, 'documentSpec' | 'fieldPath'>;
    contentSourceDataById: Record<string, ContentStoreTypes.ContentSourceData>;
}): StackbitTypes.CustomActionFieldStateParams {
    const documentSpec = extendedAction.documentSpec;
    const contentSourceData = getContentSourceDataByTypeAndProjectIdOrThrow(documentSpec.srcType, documentSpec.srcProjectId, contentSourceDataById);
    const document = contentSourceData.documentMap[documentSpec.srcDocumentId];
    const csiDocument = contentSourceData.csiDocumentMap[documentSpec.srcDocumentId];
    if (!document || !csiDocument) {
        throw new Error(
            `document not found for srcType: ${documentSpec.srcType}, srcProjectId: ${documentSpec.srcProjectId}, srcDocumentId: ${documentSpec.srcDocumentId}`
        );
    }

    const model = contentSourceData.modelMap[document.srcModelName];
    if (!model) {
        throw new Error(`model '${document.srcModelName}' not found`);
    }

    const mappedCSIDocument = mapStoreDocumentToCSIDocumentWithSource({ document, csiDocument });

    // the documentField should be localized because fieldPath includes locales
    const { modelField, documentField } = getModelAndDocumentFieldForLocalizedFieldPath({
        document,
        fieldPath: extendedAction.fieldPath,
        modelMap: contentSourceData.modelMap
    }) as {
        // list items cannot have actions, therefore we can safely reduce the type to non list item fields
        modelField: StackbitTypes.Field;
        documentField: ContentStoreTypes.DocumentField;
    };

    const csiDocumentField = mapStoreFieldToCSIField(documentField);

    return {
        parentDocument: mappedCSIDocument,
        parentModel: {
            ...model,
            srcType: documentSpec.srcType,
            srcProjectId: documentSpec.srcProjectId
        },
        documentField: csiDocumentField,
        modelField: modelField,
        fieldPath: extendedAction.fieldPath
    };
}

function getCSIDocumentAndModelWithSourceFromDocumentSpec({
    documentSpec,
    contentSourceDataById
}: {
    documentSpec: APICustomActionDocumentSpecifier;
    contentSourceDataById: Record<string, ContentStoreTypes.ContentSourceData>;
}): {
    document: StackbitTypes.DocumentWithSource;
    model: StackbitTypes.ModelWithSource;
} {
    const contentSourceData = getContentSourceDataByTypeAndProjectIdOrThrow(documentSpec.srcType, documentSpec.srcProjectId, contentSourceDataById);
    const document = contentSourceData.documentMap[documentSpec.srcDocumentId];
    const csiDocument = contentSourceData.csiDocumentMap[documentSpec.srcDocumentId];
    if (!document || !csiDocument) {
        throw new Error(
            `document not found, srcType: ${documentSpec.srcType}, srcProjectId: ${documentSpec.srcProjectId}, srcDocumentId: ${documentSpec.srcDocumentId}`
        );
    }
    const mappedDocument = mapStoreDocumentToCSIDocumentWithSource({
        document,
        csiDocument
    });
    const model = contentSourceData.modelMap[mappedDocument.modelName];
    if (!model) {
        throw new Error(`model '${mappedDocument.modelName}' not found`);
    }
    return {
        document: mappedDocument,
        model: {
            ...model,
            srcType: documentSpec.srcType,
            srcProjectId: documentSpec.srcProjectId
        }
    };
}

function storeActionTypeToAPIActionType(storeActionType: ExtendedCustomAction['type']): APICustomAction['type'] {
    if (storeActionType === 'objectModel' || storeActionType === 'objectField') {
        return 'object';
    }
    return storeActionType;
}

function findCustomActionById({
    actionId,
    customActionRunStateMap,
    contentSourceDataById,
    stackbitConfig
}: {
    actionId: string;
    customActionRunStateMap: CustomActionRunStateMap;
    contentSourceDataById: Record<string, ContentStoreTypes.ContentSourceData>;
    stackbitConfig: Config | null;
}): ExtendedCustomAction | undefined {
    const actionRunState = customActionRunStateMap[actionId];
    if (isGlobalActionId(actionId)) {
        if (!stackbitConfig || !Array.isArray(stackbitConfig.actions)) {
            return undefined;
        }
        const actionName = getGlobalActionNameFromId(actionId);
        const action = stackbitConfig.actions.find((action) => action.name === actionName);
        if (!action) {
            return undefined;
        }
        return {
            ...action,
            actionId,
            label: action.label ?? _.startCase(action.name),
            runningHandler: actionRunState?.runningHandler,
            lastResultState: actionRunState?.lastResultState
        };
    }
    const { srcType, srcProjectId, srcDocumentId, actionName, fieldPath } = parseActionId(actionId) ?? {};
    if (!srcType || !srcProjectId || !srcDocumentId || !actionName) {
        return undefined;
    }
    const documentSpec: APICustomActionDocumentSpecifier = { srcType, srcProjectId, srcDocumentId };
    const contentSourceData = getContentSourceDataByTypeAndProjectIdOrThrow(srcType, srcProjectId, contentSourceDataById);
    const document = contentSourceData.documentMap[srcDocumentId];
    if (!document) {
        return undefined;
    }
    const modelName = document.srcModelName;
    const model = contentSourceData.modelMap[modelName];
    // The model of a document is always 'page' or 'data',
    // this condition helps TS to infer the right type of model.actions
    if (!model || (model.type !== 'page' && model.type !== 'data')) {
        return undefined;
    }
    if (typeof fieldPath === 'undefined') {
        // fieldPath was not provided, therefore the model must be of type "page" or "data",
        // and the action type must be 'document'
        const action = model.actions?.find((action) => action.name === actionName);
        if (!action) {
            return undefined;
        }
        return {
            // if configuration is updated, the new action properties will override the stored action properties
            ...action,
            type: 'document',
            actionId,
            label: action.label ?? _.startCase(action.name),
            documentSpec,
            runningHandler: actionRunState?.runningHandler,
            lastResultState: actionRunState?.lastResultState
        };
    } else {
        const { modelField, documentField } = getModelAndDocumentFieldForLocalizedFieldPath({
            document,
            fieldPath,
            modelMap: contentSourceData.modelMap
        });

        if ('actions' in modelField && Array.isArray(modelField.actions)) {
            const action = modelField.actions.find((action) => action.name === actionName);
            if (action) {
                return {
                    // if configuration is updated, the new action properties will override the stored action properties
                    ...action,
                    type: action.type === 'object' ? 'objectField' : 'field',
                    actionId,
                    label: action.label ?? _.startCase(action.name),
                    documentSpec,
                    fieldPath,
                    runningHandler: actionRunState?.runningHandler,
                    lastResultState: actionRunState?.lastResultState
                } as ExtendedCustomActionField | ExtendedCustomActionObjectField;
            }
        }

        if (modelField.type === 'model') {
            if (documentField.type !== 'model' || documentField.localized || documentField.isUnset) {
                return undefined;
            }
            const modelName = documentField.srcModelName;
            const model = contentSourceData.modelMap[modelName];
            if (!model || model.type !== 'object') {
                return undefined;
            }
            if (!('actions' in model && Array.isArray(model.actions))) {
                return undefined;
            }
            // This is a nested model of type "object", so the action must be CustomActionObjectModel
            const action = model.actions.find((action) => action.name === actionName);
            if (!action) {
                return undefined;
            }
            return {
                // if configuration is updated, the new action properties will override the stored action properties
                ...action,
                type: 'objectModel',
                actionId,
                label: action.label ?? _.startCase(action.name),
                documentSpec,
                fieldPath,
                runningHandler: actionRunState?.runningHandler,
                lastResultState: actionRunState?.lastResultState
            };
        }
    }
}

function globalActionId(action: StackbitTypes.CustomActionGlobal | StackbitTypes.CustomActionBulk): string {
    return `config.actions.${action.name}`;
}

function isGlobalActionId(actionId: string) {
    return actionId.startsWith('config.actions.');
}

function getGlobalActionNameFromId(actionId: string) {
    return actionId.substring('config.actions.'.length);
}

function documentActionId({ srcType, srcProjectId, srcDocumentId, actionName }: APICustomActionDocumentSpecifier & { actionName: string }): string {
    return `${srcType}:${srcProjectId}:${srcDocumentId}:${actionName}`;
}

function fieldPathActionId({
    srcType,
    srcProjectId,
    srcDocumentId,
    fieldPath,
    actionName
}: APICustomActionDocumentSpecifier & { fieldPath: (string | number)[]; actionName: string }): string {
    return `${srcType}:${srcProjectId}:${srcDocumentId}:${fieldPath.join('.')}:${actionName}`;
}

function parseActionId(actionId: string):
    | {
          srcType?: string;
          srcProjectId?: string;
          srcDocumentId?: string;
          actionName?: string;
          fieldPath?: string[];
      }
    | undefined {
    const parts = actionId.split(':');
    if (parts.length < 4 || parts.length > 5) {
        return undefined;
    }
    const srcType = parts[0];
    const srcProjectId = parts[1];
    const srcDocumentId = parts[2];
    let fieldPath: string[] | undefined;
    let actionName: string | undefined;
    if (parts.length === 5) {
        fieldPath = parts[3]?.split('.');
        actionName = parts[4];
    } else {
        actionName = parts[3];
    }
    return {
        srcType,
        srcProjectId,
        srcDocumentId,
        actionName,
        fieldPath
    };
}
