import _ from 'lodash';
import path from 'path';
import sanitizeFilename from 'sanitize-filename';

import * as CSITypes from '@stackbit/types';
import { getLocalizedFieldForLocale, isOneOfFieldTypes, ModelExtension, UserCommandSpawner, CommandRunner, ScheduledAction } from '@stackbit/types';
import {
    Config,
    extendModelsWithPresetsIds,
    getPresetDirs,
    getYamlModelDirs,
    ImageModel,
    loadPresets,
    loadYamlModelsFromFiles,
    mergeConfigModelsWithExternalModels,
    mergeConfigModelsWithModelsFromFiles,
    Model,
    Preset,
    PresetMap
} from '@stackbit/sdk';
import { append, DeferredPromise, deferredPromise, deferWhileRunning, mapPromise, reducePromise } from '@stackbit/utils';

import * as ContentStoreTypes from './types';
import { Timer } from './utils/timer';
import { SearchFilter } from './types';
import { searchDocuments } from './utils/search-utils';
import { mapCSIAssetsToStoreAssets, mapCSIDocumentsToStoreDocuments } from './utils/csi-to-store-docs-converter';
import {
    getContentSourceId,
    getContentSourceDataByIdOrThrow,
    getContentSourceIdForContentSource,
    getCSIDocumentsAndAssetsFromContentSourceDataByIds,
    getUserContextForSrcType,
    groupDocumentsByContentSource,
    groupModelsByContentSource,
    isContentChangesEmpty,
    isContentChangeResultEmpty,
    contentChangeResultCounts,
    updateOperationValueFieldWithCrossReference,
    getErrorAtLine,
    findContentSourcesDataForTypeOrId
} from './content-store-utils';
import {
    getSiteMapEntriesFromStackbitConfig,
    updateSiteMapEntriesWithContentChanges,
    getDocumentFieldLabelValueForSiteMapEntry,
    getSiteMapGroupKeyForDocument,
    SiteMapEntryGroups
} from './utils/site-map';
import { mapAssetsToLocalizedApiImages, mapDocumentsToLocalizedApiObjects, mapStoreAssetsToAPIAssets } from './utils/store-to-api-docs-converter';
import { convertOperationField, createDocumentRecursively, CreateDocumentThunk, getCreateDocumentThunk } from './utils/create-update-csi-docs';
import { mergeObjectWithDocument } from './utils/duplicate-document';
import { normalizeModels, validateModels } from './utils/model-utils';
import { IMAGE_MODEL } from './common/common-schema';
import { getDocumentObjectFromPreset, getPresetFromDocument } from './utils/preset-utils';
import { BackCompatContentSourceInterface, backwardCompatibleContentSource } from './utils/backward-compatibility';
import { createConfigDelegate, getCreateConfigDelegateThunk } from './utils/config-delegate';
import { GitService } from './services';
import { getAssetSourcesForClient } from './utils/asset-sources-utils';
import { deleteDocumentHooked, publishDocumentHooked, updateDocumentHooked } from './utils/document-hooks';
import { resolveCustomActionsById, getGlobalAndBulkAPIActions, runCustomAction, stripModelActions } from './utils/custom-actions';
import { getSanitizedTreeViews } from './utils/tree-views';
import { getModelFieldAtFieldPath } from './utils/field-path-utils';
import {
    logCreateDocument,
    logDeleteDocument,
    logDuplicateDocument,
    logPublishDocuments,
    logUpdateDocument,
    logUploadAssets,
    pluralize
} from './utils/user-log-utils';
import { ContentEngine, PluginRef, contentEngine } from 'content-engine';

export type HandleConfigAssets = <T extends Model>({ models, presets }: { models?: T[]; presets?: PresetMap }) => Promise<{ models: T[]; presets: PresetMap }>;

export interface ContentSourceOptions {
    logger: CSITypes.Logger;
    userLogger: CSITypes.Logger;
    localDev: boolean;
    staticAssetsPublicPath: string;
    webhookUrl?: string;
    runCommand: CommandRunner;
    git: GitService;
    userCommandSpawner?: UserCommandSpawner; //TODO remove
    onSchemaChangeCallback: () => void;
    onContentChangeCallback: (contentChanges: ContentStoreTypes.ContentChangeResult) => void;
    onActionStateChangeCallback: (actionResult: ContentStoreTypes.CustomActionStateChange) => void;
    handleConfigAssets: HandleConfigAssets;
    devAppRestartNeeded?: () => void;
}

type ContentSourceData = ContentStoreTypes.ContentSourceData;
type ContentSourceRawData = Omit<ContentSourceData, 'models' | 'modelMap' | 'documents' | 'documentMap'>;
type ContentStoreEventQueue = ContentStoreEvent[];

const ContentStoreEventType = {
    YamlModelFilesChange: 'yamlModelFilesChange',
    PresetFilesChange: 'presetFilesChange',
    ContentSourceInvalidateSchema: 'contentSourceInvalidateSchema',
    ContentSourceContentChange: 'contentSourceContentChange'
} as const;

type ContentStoreEvent =
    | {
          eventName: typeof ContentStoreEventType.YamlModelFilesChange;
      }
    | {
          eventName: typeof ContentStoreEventType.PresetFilesChange;
      }
    | {
          eventName: typeof ContentStoreEventType.ContentSourceInvalidateSchema;
          contentSourceId: string;
      }
    | {
          eventName: typeof ContentStoreEventType.ContentSourceContentChange;
          contentSourceId: string;
          contentChanges: CSITypes.ContentChanges;
      };

export const StackbitPresetModelName = 'stackbitPreset';

export class ContentStore {
    private readonly logger: CSITypes.Logger;
    private readonly userLogger: CSITypes.Logger;
    private readonly userCommandSpawner?: UserCommandSpawner;
    private readonly localDev: boolean;
    private readonly staticAssetsPublicPath: string;
    private readonly webhookUrl?: string;
    private readonly runCommand: CommandRunner;
    private readonly git: GitService;
    private readonly onSchemaChangeCallback: () => void;
    private readonly onContentChangeCallback: (contentChanges: ContentStoreTypes.ContentChangeResult) => void;
    private readonly onActionStateChangeCallback: (actionStateChange: ContentStoreTypes.CustomActionStateChange) => void;
    private readonly handleConfigAssets: HandleConfigAssets;
    private readonly devAppRestartNeeded?: () => void;
    private contentSources: BackCompatContentSourceInterface[] = [];
    private contentSourceDataById: Record<string, ContentSourceData> = {};
    private presetsContentSource?: BackCompatContentSourceInterface;
    private contentUpdatesWatchTimer: Timer;
    private stackbitConfig: Config | null = null;
    private yamlModels: Model[] = [];
    private configModels: Model[] = [];
    private modelExtensions: ModelExtension[] | null = null;
    private presets: PresetMap = {};
    private siteMapEntryGroups: SiteMapEntryGroups = {};
    private processingContentSourcesPromise: DeferredPromise<void> | null = null;
    private contentStoreEventQueue: ContentStoreEventQueue = [];
    private treeViews: CSITypes.TreeViewNode[] = [];
    private customActionRunStateMap: ContentStoreTypes.CustomActionRunStateMap = {};
    private contentEngine?: ContentEngine | null;

    constructor(options: ContentSourceOptions) {
        this.logger = options.logger.createLogger({ label: 'content-store' });
        this.userLogger = options.userLogger.createLogger({ label: 'content-store' });
        this.localDev = options.localDev;
        this.staticAssetsPublicPath = options.staticAssetsPublicPath;
        this.webhookUrl = options.webhookUrl;
        this.runCommand = options.runCommand;
        this.git = options.git;
        this.userCommandSpawner = options.userCommandSpawner;
        this.onSchemaChangeCallback = options.onSchemaChangeCallback;
        this.onContentChangeCallback = options.onContentChangeCallback;
        this.onActionStateChangeCallback = options.onActionStateChangeCallback;
        this.handleConfigAssets = options.handleConfigAssets;
        this.contentUpdatesWatchTimer = new Timer({ timerCallback: () => this.handleTimerTimeout(), logger: this.logger });
        this.devAppRestartNeeded = options.devAppRestartNeeded;

        // The `loadContentSourcesAndProcessData` method can be called multiple times rapidly for several reasons:
        // stackbit.config.js updated, one of the preset or the yaml-model files changed, one of the content-source's
        // schema files updated (for example Sanity's schema files).
        // Therefore, to prevent parallel executions of this method and corrupting the ContentStore state,
        // debounce rapid invocations of this method and defer invocation while this method is running.
        this.loadContentSourcesAndProcessData = deferWhileRunning(this.loadContentSourcesAndProcessData, {
            thisArg: this,
            debounceDelay: 100,
            debounceMaxDelay: 500,

            // When the loadContentSourcesAndProcessData is called multiple times with different arguments,
            // ensure that the deferred call will be called with the lowest denominator of the passed arguments.
            argsResolver: ({ nextArgs, prevArgs }) => {
                // If at least one call had "init: true" then call the deferred
                // function with "init: true" and without contentSourceIds.
                const init = nextArgs[0].init || Boolean(prevArgs?.[0].init);
                if (init) {
                    return [{ init }] as typeof nextArgs;
                }
                // If at least one call had "startWatchingContentUpdates: true" then call the deferred
                // function with "startWatchingContentUpdates: true".
                const startWatchingContentUpdates = nextArgs[0].startWatchingContentUpdates || Boolean(prevArgs?.[0].startWatchingContentUpdates);
                // If at least one call had "contentSourceIds: undefined" (signal to reload all content sources)
                // then call the deferred function with "contentSourceIds: undefined",
                // otherwise call it with union of content source ids.
                const contentSourceIds =
                    typeof nextArgs[0].contentSourceIds === 'undefined' || (prevArgs && typeof prevArgs[0].contentSourceIds === 'undefined')
                        ? undefined
                        : _.union(nextArgs[0].contentSourceIds, prevArgs?.[0].contentSourceIds);
                return [{ init, startWatchingContentUpdates, contentSourceIds }] as typeof nextArgs;
            }
        });
    }

    async init({ stackbitConfig }: { stackbitConfig: Config | null }): Promise<void> {
        this.logger.debug('init');

        this.stackbitConfig = stackbitConfig;

        if (stackbitConfig) {
            if (stackbitConfig.modelExtensions) {
                this.modelExtensions = stackbitConfig.modelExtensions;
            } else {
                this.yamlModels = await this.loadYamlModels({ stackbitConfig });
                this.configModels = this.mergeConfigModels(stackbitConfig.models ?? [], this.yamlModels);
            }
        }

        await this.loadContentSourcesAndProcessData({ init: true });

        this.contentUpdatesWatchTimer.startTimer();
    }

    async onStackbitConfigChange({ stackbitConfig }: { stackbitConfig: Config | null }) {
        this.logger.debug('onStackbitConfigChange');

        this.stackbitConfig = stackbitConfig;

        if (stackbitConfig) {
            if (stackbitConfig.modelExtensions) {
                this.modelExtensions = stackbitConfig.modelExtensions;
            } else {
                this.configModels = this.mergeConfigModels(stackbitConfig.models ?? [], this.yamlModels);
            }
        }

        await this.loadContentSourcesAndProcessData({ init: true });
    }

    /**
     * This method is called when contentUpdatesWatchTimer receives timeout.
     * This happens when the user is not using the Stackbit app for some time
     * but container is not hibernated.
     * It then notifies all content sources to stop watching for content
     * changes, which in turn stops polling CMS for content changes and helps
     * reducing the CMS API usage.
     */
    private handleTimerTimeout() {
        for (const contentSourceInstance of this.contentSources) {
            contentSourceInstance.stopWatchingContentUpdates?.();
        }
    }

    /**
     * This method is called when user interacts with Stackbit application.
     * It is used to reset contentUpdatesWatchTimer. When the timer is over
     * all content sources are notified to stop watching for content updates.
     */
    async keepAlive() {
        if (this.contentUpdatesWatchTimer.isRunning()) {
            this.contentUpdatesWatchTimer.resetTimer();
            return;
        }

        this.logger.debug('keepAlive => contentUpdatesWatchTimer is not running => load content source data');
        this.contentUpdatesWatchTimer.startTimer();
        await this.loadContentSourcesAndProcessData({ init: false, startWatchingContentUpdates: true });
    }

    stop() {
        this.contentUpdatesWatchTimer.stopTimer();
    }

    async onFilesChange(updatedFiles: string[]): Promise<void> {
        this.logger.debug('onFilesChange');

        if (this.stackbitConfig && !this.stackbitConfig.modelExtensions) {
            // Check if any of the yaml models files were changed. If yaml model files were changed,
            // reload them and merge them with models defined in stackbit config.
            const modelDirs = getYamlModelDirs(this.stackbitConfig);
            const yamlModelsChanged = updatedFiles.find((updatedFile) => _.some(modelDirs, (modelDir) => updatedFile.startsWith(modelDir)));
            if (yamlModelsChanged) {
                this.logger.debug('identified change in stackbit model files');
                this.yamlModels = await this.loadYamlModels({ stackbitConfig: this.stackbitConfig });
                this.configModels = this.mergeConfigModels(this.stackbitConfig.models ?? [], this.yamlModels);
                this.pushContentSourceEvent({
                    eventName: ContentStoreEventType.YamlModelFilesChange
                });
            }
        }

        if (this.stackbitConfig) {
            // Check if any of the preset files were changed. If presets were changed, reload them.
            const presetDirs = getPresetDirs(this.stackbitConfig);
            const presetsChanged = updatedFiles.find((updatedFile) => _.some(presetDirs, (presetDir) => updatedFile.startsWith(presetDir)));
            if (presetsChanged && !this.usesContentSourcePresets()) {
                this.logger.debug('identified change in stackbit preset files');
                this.presets = await this.loadPresetsFromConfig({ stackbitConfig: this.stackbitConfig });
                this.pushContentSourceEvent({
                    eventName: ContentStoreEventType.PresetFilesChange
                });
            }
        }

        for (const contentSourceInstance of this.contentSources) {
            const contentSourceId = getContentSourceIdForContentSource(contentSourceInstance);
            const contentSourceData = this.contentSourceDataById[contentSourceId];
            if (contentSourceData?.destroyed) {
                this.logger.debug(`contentSource '${contentSourceId}' was destroyed, don't call onFilesChange`);
                continue;
            }
            this.logger.debug(`call onFilesChange for contentSource: ${contentSourceId}`);
            const onFilesChangeResult = await contentSourceInstance.onFilesChange({ updatedFiles: updatedFiles });

            // If the schema was changed in a specific content source, there is no need to process and notify for content changes.
            // Because the schema changes will trigger loadContentSourcesAndProcessData and reload all models and content of that
            // content source and send the schemaChanged notification that will cause the Studio to reload the schema and documents.
            if (onFilesChangeResult.invalidateSchema) {
                this.logger.debug(`schema was invalidated for contentSource: ${contentSourceId}`);
                this.pushContentSourceEvent({
                    eventName: ContentStoreEventType.ContentSourceInvalidateSchema,
                    contentSourceId: contentSourceId
                });
            } else if (!isContentChangesEmpty(onFilesChangeResult.contentChanges)) {
                this.logger.debug(`content was changed for contentSource: ${contentSourceId}`);
                this.pushContentSourceEvent({
                    eventName: ContentStoreEventType.ContentSourceContentChange,
                    contentSourceId: contentSourceId,
                    contentChanges: onFilesChangeResult.contentChanges
                });
            }
        }

        await this.processContentStoreEvents();
    }

    private async loadYamlModels({ stackbitConfig }: { stackbitConfig: Config }): Promise<Model[]> {
        const yamlModelsResult = await loadYamlModelsFromFiles(stackbitConfig);
        for (const error of yamlModelsResult.errors) {
            this.userLogger.warn(error.message);
        }
        return yamlModelsResult.models;
    }

    private mergeConfigModels(configModels: Model[], modelsFromFiles: Model[]) {
        const configModelsResult = mergeConfigModelsWithModelsFromFiles(configModels, modelsFromFiles);
        for (const error of configModelsResult.errors) {
            this.userLogger.warn(error.message);
        }
        return configModelsResult.models;
    }

    private async loadPresetsFromConfig({ stackbitConfig }: { stackbitConfig: Config }): Promise<PresetMap> {
        const contentSources = stackbitConfig?.contentSources ?? [];
        const singleContentSource = contentSources.length === 1 ? contentSources[0] : null;
        const presetResult = await loadPresets({
            config: stackbitConfig,
            ...(singleContentSource
                ? {
                      fallbackSrcType: singleContentSource.getContentSourceType(),
                      fallbackSrcProjectId: singleContentSource.getProjectId()
                  }
                : null)
        });
        for (const error of presetResult.errors) {
            this.userLogger.warn(error.message);
        }
        const { presets } = await this.handleConfigAssets({ presets: presetResult.presets });
        return presets;
    }

    private async loadPresetsFromContentSource(contentSourceData: ContentSourceRawData): Promise<PresetMap> {
        const presets = _.reduce(
            contentSourceData.csiDocuments,
            (result: Record<string, Preset>, csiDocument) => {
                if (csiDocument.modelName === StackbitPresetModelName) {
                    const preset = getPresetFromDocument({
                        srcType: contentSourceData.srcType,
                        srcProjectId: contentSourceData.srcProjectId,
                        csiDocument,
                        csiAssetMap: contentSourceData.csiAssetMap,
                        logger: this.logger
                    });
                    if (preset) {
                        result[csiDocument.id] = preset;
                    }
                }
                return result;
            },
            {}
        );
        return presets;
    }

    /**
     * If any content sources implement the `getContentEngineConfig` method then this function gets all
     * of these plugin definitions and creates the content engine.
     */
    private async createContentEngineIfNeeded() {
        const logger = this.userLogger.createLogger({ label: 'content-engine' });
        if (this.contentEngine) {
            logger.info('stopping content engine');
            this.contentEngine.clearListeners();
            await this.contentEngine.stop();
            this.contentEngine = null;
        }
        const plugins = Array.from(
            new Set(this.contentSources?.flatMap((contentSource) => contentSource.getContentEngineConfig?.()?.plugins).filter(Boolean))
        ) as PluginRef[];
        if (plugins.length < 1) {
            return;
        }
        logger.info('creating content engine');
        this.contentEngine = contentEngine({
            directory: this.stackbitConfig?.dirPath,
            port: this.stackbitConfig?.contentEngine?.port,
            host: this.stackbitConfig?.contentEngine?.host,
            engineConfig: {
                plugins
            }
        });

        this.contentEngine?.onStdOut((data) => {
            logger.info(data.toString());
        });

        this.contentEngine?.onStdErr((data) => {
            logger.error(data.toString());
        });
    }

    /**
     * This function reloads the data of the specified content-sources, while
     * reusing the cached data of the rest of the content-sources, then processes
     * the content sources' data by merging it with models defined in
     * stackbit.config.js and yaml-model files.
     *
     * This function is wrapped by `deferWhileRunning` ensuring this method is
     * invoked one at a time.
     *
     * @param {boolean} init Flag specifying if the content sources need to be initialized or reset.
     *   The content sources need to be (re-)initialized only when the stackbit.config.js was reloaded.
     *   In all other cases content sources can be reset.
     * @param {string[] | undefined} contentSourceIds Array of content source IDs to reload.
     *   If not provided or set to "undefined", will reload all content sources.
     *   If set to empty array will not reload any content sources and only process their cached data.
     * @private
     */
    private async loadContentSourcesAndProcessData({
        init,
        startWatchingContentUpdates,
        contentSourceIds
    }: {
        init: boolean;
        startWatchingContentUpdates?: boolean;
        contentSourceIds?: string[];
    }) {
        this.logger.debug('loadContentSourcesAndProcessData', { init, contentSourceIds });
        if (this.processingContentSourcesPromise) {
            // for internal monitoring
            this.logger.error('ALERT, called loadContentSourcesAndProcessData while still processing the previous call');
        }
        this.processingContentSourcesPromise = deferredPromise();

        // On init, get the new content source instances from the config and wrap them with backward compatibility Proxy.
        // Otherwise, reuse existing proxy wrapped backward compatible content sources.
        const contentSources =
            init || this.contentSources.length === 0
                ? (this.stackbitConfig?.contentSources ?? []).map((contentSource) => {
                      return backwardCompatibleContentSource(contentSource);
                  })
                : this.contentSources;

        this.contentSources = contentSources;

        if (init) {
            this.logger.debug('init content sources');
            await this.createContentEngineIfNeeded();
            await this.contentEngine?.sync({
                runServer: true
            });
        }

        const promises = contentSources.map((contentSourceInstance): Promise<ContentSourceRawData> => {
            const contentSourceId = getContentSourceIdForContentSource(contentSourceInstance);
            if (init || !contentSourceIds || contentSourceIds.includes(contentSourceId)) {
                return this.loadContentSourceData({ contentSourceInstance, init, startWatchingContentUpdates });
            } else {
                return Promise.resolve(_.omit(this.contentSourceDataById[contentSourceId], ['models', 'modelMap', 'documents', 'documentMap']));
            }
        });

        const contentSourceRawDataArr = await Promise.all(promises);

        // find first content source that supports presets
        for (let i = 0; i < contentSources.length; i++) {
            const contentSourceDataRaw = contentSourceRawDataArr[i];
            if (contentSourceDataRaw?.csiModelMap?.[StackbitPresetModelName]) {
                this.presetsContentSource = contentSourceDataRaw.instance;
                // reload presets from content source only if needed
                if (init || !contentSourceIds || contentSourceIds.includes(contentSourceDataRaw.id)) {
                    this.presets = await this.loadPresetsFromContentSource(contentSourceDataRaw);
                }
                break;
            }
        }

        // fallback to loading presets from config as usual
        if (init && this.stackbitConfig && !this.presetsContentSource) {
            this.presets = await this.loadPresetsFromConfig({ stackbitConfig: this.stackbitConfig });
        }

        // update all content sources at once to prevent race conditions
        this.contentSourceDataById = await this.processData({
            stackbitConfig: this.stackbitConfig,
            configModels: this.modelExtensions ?? (this.configModels as ModelExtension[]) ?? [],
            presets: this.presets,
            contentSourceRawDataArr: contentSourceRawDataArr
        });

        const configDelegate = createConfigDelegate({
            contentSourceDataById: this.contentSourceDataById,
            logger: this.userLogger
        });

        // generate create site map entries
        this.siteMapEntryGroups = await getSiteMapEntriesFromStackbitConfig({
            stackbitConfig: this.stackbitConfig,
            contentSourceDataById: this.contentSourceDataById,
            configDelegate
        });

        this.treeViews = await getSanitizedTreeViews({
            configDelegate,
            stackbitConfig: this.stackbitConfig,
            contentSourceDataById: this.contentSourceDataById,
            logger: this.userLogger
        });

        if (!init) {
            this.onSchemaChangeCallback();
        }

        this.logger.debug('loadContentSourcesAndProcessData finished', { init, contentSourceIds });
        const processingPromise = this.processingContentSourcesPromise;
        this.processingContentSourcesPromise = null;

        // Do not "await" on processContentStoreEvents as it may introduce a deadlock with
        // the nested loadContentSourcesAndProcessData call which is wrapped by deferWhileRunning.
        this.processContentStoreEvents()
            .catch((error) => {
                this.logger.error('error processing content source events', { error });
            })
            .finally(() => {
                processingPromise.resolve();
            });
    }

    private async processContentStoreEvents() {
        // If the ContentStore is currently loading content sources, return to prevent parallel data updates.
        // This method will be called once current loading cycle ends.
        if (this.processingContentSourcesPromise) {
            this.logger.debug('processContentStoreEvents, processing content sources, delaying execution');
            return this.processingContentSourcesPromise.promise;
        }
        this.logger.debug('processContentStoreEvents');

        const contentSourceIdsWithInvalidatedSchema: string[] = [];
        const contentChanges: ContentStoreTypes.ContentChangeResult = {
            updatedDocuments: [],
            updatedAssets: [],
            updatedScheduledActions: [],
            deletedDocuments: [],
            deletedAssets: [],
            deletedScheduledActions: []
        };
        let invalidateSchema = false;
        let presetsUpdated = false;

        const contentSourceEvents = this.contentStoreEventQueue;
        this.contentStoreEventQueue = [];
        for (const contentSourceEvent of contentSourceEvents) {
            if (
                contentSourceEvent.eventName === ContentStoreEventType.YamlModelFilesChange ||
                contentSourceEvent.eventName === ContentStoreEventType.PresetFilesChange
            ) {
                invalidateSchema = true;
            } else if (contentSourceEvent.eventName === ContentStoreEventType.ContentSourceInvalidateSchema) {
                invalidateSchema = true;
                contentSourceIdsWithInvalidatedSchema.push(contentSourceEvent.contentSourceId);
            } else if (contentSourceEvent.eventName === ContentStoreEventType.ContentSourceContentChange) {
                const result = this.onContentChange(contentSourceEvent.contentSourceId, contentSourceEvent.contentChanges);
                contentChanges.updatedDocuments = contentChanges.updatedDocuments.concat(result.contentChangeResult.updatedDocuments);
                contentChanges.updatedAssets = contentChanges.updatedAssets.concat(result.contentChangeResult.updatedAssets);
                contentChanges.updatedScheduledActions = contentChanges.updatedScheduledActions.concat(result.contentChangeResult.updatedScheduledActions);
                contentChanges.deletedDocuments = contentChanges.deletedDocuments.concat(result.contentChangeResult.deletedDocuments);
                contentChanges.deletedAssets = contentChanges.deletedAssets.concat(result.contentChangeResult.deletedAssets);
                contentChanges.deletedScheduledActions = contentChanges.deletedScheduledActions.concat(result.contentChangeResult.deletedScheduledActions);
                if (result.presetsUpdated) {
                    presetsUpdated = true;
                }
            }
        }

        // If the schema was changed, call loadContentSourcesAndProcessData method, this will reload all the SiteMapEntries and call the onSchemaChangeCallback.
        // As soon as the Studio receives the schemaChanged notification it will reload all the models and the documents.
        if (invalidateSchema) {
            this.logger.debug('processContentStoreEvents => invalidateSchema');
            await this.loadContentSourcesAndProcessData({
                init: false,
                contentSourceIds: contentSourceIdsWithInvalidatedSchema
            });
        } else {
            this.logger.debug('processContentStoreEvents => content changes', { ...contentChangeResultCounts(contentChanges), presetsUpdated });
            const configDelegate = createConfigDelegate({
                contentSourceDataById: this.contentSourceDataById,
                logger: this.userLogger
            });
            // If the schema wasn't changed, update SiteMapEntries with the changed content.
            this.siteMapEntryGroups = await updateSiteMapEntriesWithContentChanges({
                siteMapEntryGroups: this.siteMapEntryGroups,
                contentChanges: contentChanges,
                stackbitConfig: this.stackbitConfig,
                contentSourceDataById: this.contentSourceDataById,
                configDelegate
            });
            this.treeViews = await getSanitizedTreeViews({
                configDelegate,
                stackbitConfig: this.stackbitConfig,
                contentSourceDataById: this.contentSourceDataById,
                logger: this.userLogger
            });
            // If presets were updated, call onSchemaChangeCallback to notify the Studio.
            // The Studio will refresh the models and the documents, so no need to notify
            // content changes in this case.
            if (presetsUpdated) {
                this.onSchemaChangeCallback();
            } else if (!isContentChangeResultEmpty(contentChanges)) {
                this.onContentChangeCallback(contentChanges);
            }
        }
    }

    private pushContentSourceEvent(contentStoreEvent: ContentStoreEvent) {
        if (contentStoreEvent.eventName === ContentStoreEventType.ContentSourceContentChange) {
            // If a content source enqueued the 'contentSourceInvalidateSchema' event,
            // don't push the 'contentSourceContentChange' event, because 'contentSourceInvalidateSchema'
            // will reload all the content source data.
            const hasContentSourceSchemaChangeEvent = this.contentStoreEventQueue.find(
                (event) =>
                    event.eventName === ContentStoreEventType.ContentSourceInvalidateSchema && event.contentSourceId === contentStoreEvent.contentSourceId
            );
            if (!hasContentSourceSchemaChangeEvent) {
                this.contentStoreEventQueue.push(contentStoreEvent);
            }
        } else if (contentStoreEvent.eventName === ContentStoreEventType.ContentSourceInvalidateSchema) {
            // Clear any 'contentSourceContentChange' events for a content source,
            // the 'contentSourceInvalidateSchema' will reload all the content source data.
            this.clearEventsForContentSourceId(contentStoreEvent.contentSourceId);
            this.contentStoreEventQueue.push(contentStoreEvent);
        } else if (contentStoreEvent.eventName === ContentStoreEventType.YamlModelFilesChange) {
            this.contentStoreEventQueue = this.contentStoreEventQueue.filter((event) => event.eventName !== ContentStoreEventType.YamlModelFilesChange);
            this.contentStoreEventQueue.push(contentStoreEvent);
        } else if (contentStoreEvent.eventName === ContentStoreEventType.PresetFilesChange) {
            this.contentStoreEventQueue = this.contentStoreEventQueue.filter((event) => event.eventName !== ContentStoreEventType.PresetFilesChange);
            this.contentStoreEventQueue.push(contentStoreEvent);
        }
    }

    private clearEventsForContentSourceId(contentSourceId: string) {
        this.contentStoreEventQueue = this.contentStoreEventQueue.filter((contentSourceEvent) => {
            if (
                contentSourceEvent.eventName === ContentStoreEventType.ContentSourceContentChange ||
                contentSourceEvent.eventName === ContentStoreEventType.ContentSourceInvalidateSchema
            ) {
                return contentSourceEvent.contentSourceId !== contentSourceId;
            }
            return true;
        });
    }

    private async loadContentSourceData({
        contentSourceInstance,
        init,
        startWatchingContentUpdates
    }: {
        contentSourceInstance: BackCompatContentSourceInterface;
        init: boolean;
        startWatchingContentUpdates?: boolean;
    }): Promise<ContentSourceRawData> {
        const contentSourceId = getContentSourceIdForContentSource(contentSourceInstance);

        const contentEngineConfig = contentSourceInstance.getContentEngineConfig?.();

        this.logger.debug('loadContentSourceData', { contentSourceId, init });

        // clear content source events emitted by this content source because all the content source data is reloaded
        this.clearEventsForContentSourceId(contentSourceId);

        const localCache: Partial<
            Pick<
                ContentSourceRawData,
                'csiSchema' | 'csiModels' | 'csiModelMap' | 'locales' | 'csiDocuments' | 'csiDocumentMap' | 'csiAssets' | 'csiAssetMap' | 'scheduledActions'
            >
        > = {};

        const getContentSourceDataForCurrentInstance = (methodName: keyof CSITypes.Cache | 'getModelMap' | 'getDocument' | 'getAsset') => {
            const contentSourceData = this.contentSourceDataById[contentSourceId];
            if (!contentSourceData) {
                // When loading the content sources for the first time, this.contentSourceDataById will be empty.
                // However, while being loaded, content sources may call cache methods, for example a content
                // source may call getModelByName from within getDocuments. In this case, return locally cached data.
                if (this.processingContentSourcesPromise) {
                    return localCache;
                }
                const atLine = getErrorAtLine(2, getContentSourceDataForCurrentInstance);
                const errorMessage = `Error executing 'cache.${methodName}' method${atLine}. The content source with id '${contentSourceId}' was not found.`;
                this.logger.error(errorMessage);
                return;
            }
            if (!this.contentSources.includes(contentSourceInstance)) {
                const atLine = getErrorAtLine(2, getContentSourceDataForCurrentInstance);
                const errorMessage =
                    `Content source life cycle error! The content source with id '${contentSourceId}' called the 'cache.${methodName}' ` +
                    `method${atLine} after the destroy() method was called.`;
                this.logger.error(errorMessage);
                return;
            }
            // While loading the content source, it may call cache methods, when this happens, return the
            // stale data overridden with the most frequent loaded data
            if (this.processingContentSourcesPromise) {
                return Object.assign(contentSourceData, localCache);
            }
            return contentSourceData;
        };

        const cache: CSITypes.Cache = {
            getSchema: () => {
                const contentSourceData = getContentSourceDataForCurrentInstance('getSchema');
                if (!contentSourceData?.csiSchema) {
                    if (contentSourceData) {
                        const atLine = getErrorAtLine(1);
                        const errorMessage =
                            `Content source life cycle error! The content source with id '${contentSourceId}' called the 'cache.getSchema' ` +
                            `method${atLine} before the content source's getSchema() method was called.`;
                        this.logger.error(errorMessage);
                    }
                    return { models: [], locales: [], context: null };
                }
                return contentSourceData.csiSchema;
            },
            getModelByName: (modelName) => {
                const contentSourceData = getContentSourceDataForCurrentInstance('getModelByName');
                if (!contentSourceData?.csiModelMap) {
                    if (contentSourceData) {
                        const atLine = getErrorAtLine(1);
                        const errorMessage =
                            `Content source life cycle error! The content source with id '${contentSourceId}' called the 'cache.getModelByName' ` +
                            `method${atLine} before the content source's getSchema() method was called.`;
                        this.logger.error(errorMessage);
                    }
                    return;
                }
                return contentSourceData.csiModelMap[modelName];
            },
            getDocuments: () => {
                const contentSourceData = getContentSourceDataForCurrentInstance('getDocuments');
                return contentSourceData?.csiDocuments ?? [];
            },
            getDocumentById: (documentId) => {
                const contentSourceData = getContentSourceDataForCurrentInstance('getDocumentById');
                return contentSourceData?.csiDocumentMap?.[documentId];
            },
            getAssets: () => {
                const contentSourceData = getContentSourceDataForCurrentInstance('getAssets');
                return contentSourceData?.csiAssets ?? [];
            },
            getScheduledActions: () => {
                const contentSourceData = getContentSourceDataForCurrentInstance('getScheduledActions');
                return contentSourceData?.scheduledActions ?? [];
            },
            getScheduledActionsForDocumentId: (documentId: string) => {
                const contentSourceData = getContentSourceDataForCurrentInstance('getScheduledActionsForDocumentId');
                return contentSourceData?.scheduledActions?.filter((scheduledAction) => scheduledAction.documentIds.includes(documentId)) ?? [];
            },
            getAssetById: (assetId) => {
                const contentSourceData = getContentSourceDataForCurrentInstance('getAssetById');
                return contentSourceData?.csiAssetMap?.[assetId];
            },
            updateContent: async (contentChanges: CSITypes.ContentChanges): Promise<void> => {
                if (isContentChangesEmpty(contentChanges)) {
                    return;
                }
                const contentSourceData = getContentSourceDataForCurrentInstance('updateContent');
                if (!contentSourceData) {
                    return;
                }
                this.logger.debug('content source called updateContent', { contentSourceId });

                if (contentEngineConfig && this.contentEngine) {
                    this.logger.debug(`syncing ${contentEngineConfig.connector}`);
                    await this.contentEngine.sync({
                        buildSchema: false,
                        connector: contentEngineConfig.connector
                    });
                }

                this.pushContentSourceEvent({
                    eventName: ContentStoreEventType.ContentSourceContentChange,
                    contentSourceId: contentSourceId,
                    contentChanges: contentChanges
                });
                await this.processContentStoreEvents();
            },

            invalidateSchema: async () => {
                const contentSourceData = getContentSourceDataForCurrentInstance('invalidateSchema');
                if (!contentSourceData) {
                    return;
                }
                this.logger.debug('content source called invalidateSchema', { contentSourceId });
                if (contentEngineConfig && this.contentEngine) {
                    this.logger.debug(`syncing ${contentEngineConfig.connector}`);
                    await this.contentEngine.sync({
                        buildSchema: true,
                        connector: contentEngineConfig.connector
                    });
                }
                this.pushContentSourceEvent({
                    eventName: ContentStoreEventType.ContentSourceInvalidateSchema,
                    contentSourceId: contentSourceId
                });
                await this.processContentStoreEvents();
            }
        };

        if (init) {
            this.userLogger.info(
                `Initializing content source: ${contentSourceInstance.getContentSourceType()} (project: ${contentSourceInstance.getProjectId()})`
            );
            // When stackbit.config.js reloads, it loads new content source instances.
            // Previously loaded content source instances must be destroyed.
            const contentSourceData = this.contentSourceDataById[contentSourceId];
            if (contentSourceData && contentSourceData.instance !== contentSourceInstance) {
                this.logger.debug('destroy previous content source instance', { contentSourceId });
                try {
                    contentSourceData.instance.stopWatchingContentUpdates?.();
                    await contentSourceData.instance.destroy();
                } catch (error) {
                    this.logger.debug('error destroying content source instance', { error });
                }
                contentSourceData.destroyed = true;
            }

            // If an instance that wasn't destroyed calls one of the InitOptions method don't return any data.
            await contentSourceInstance.init({
                logger: this.logger,
                userLogger: this.userLogger,
                localDev: this.localDev,
                webhookUrl: this.getWebhookUrl(contentSourceInstance.getContentSourceType(), contentSourceInstance.getProjectId()),
                userCommandSpawner: this.userCommandSpawner,
                devAppRestartNeeded: this.devAppRestartNeeded,
                cache: cache,
                runCommand: this.runCommand,
                git: this.git
            });
        } else {
            this.userLogger.info(`reset content source`);
            await contentSourceInstance.reset();
        }

        const version = await contentSourceInstance.getVersion();
        const csiSchema = await contentSourceInstance.getSchema();
        const csiModels = csiSchema.models;
        const csiModelMap = _.keyBy(csiModels, 'name');
        const locales = csiSchema.locales;
        const defaultLocaleCode = locales?.find((locale) => locale.default)?.code;

        localCache.csiSchema = csiSchema;
        localCache.csiModels = csiModels;
        localCache.csiModelMap = csiModelMap;
        localCache.locales = locales;

        const csiDocuments = await contentSourceInstance.getDocuments({ modelMap: csiModelMap });
        const csiDocumentMap = _.keyBy(csiDocuments, 'id');
        localCache.csiDocuments = csiDocuments;
        localCache.csiDocumentMap = csiDocumentMap;

        const csiAssets = await contentSourceInstance.getAssets();
        const csiAssetMap = _.keyBy(csiAssets, 'id');
        localCache.csiAssets = csiAssets;
        localCache.csiAssetMap = csiAssetMap;

        let scheduledActions: ScheduledAction[] = [];
        let enabledScheduledActions = false;
        const scheduledActionsMethodsImplemented = !!(
            contentSourceInstance.createScheduledAction &&
            contentSourceInstance.updateScheduledAction &&
            contentSourceInstance.cancelScheduledAction &&
            contentSourceInstance.getScheduledActions
        );
        try {
            if (scheduledActionsMethodsImplemented) {
                scheduledActions = (await contentSourceInstance.getScheduledActions?.()) ?? [];
                localCache.scheduledActions = scheduledActions;
                enabledScheduledActions = true;
            }
        } catch (err) {
            this.userLogger.warn('Failed to fetch scheduled actions:', { error: err });
        }

        const contentStoreAssets = mapCSIAssetsToStoreAssets({
            csiAssets: csiAssets,
            contentSourceInstance,
            defaultLocaleCode
        });
        const assetMap = _.keyBy(contentStoreAssets, 'srcObjectId');

        this.logger.debug('loaded content source data', {
            contentSourceId,
            defaultLocaleCode,
            localesCount: locales?.length ?? 0,
            modelCount: csiModels.length,
            documentCount: csiDocuments.length,
            assetCount: csiAssets.length
        });

        this.userLogger.info(
            `→ Loaded content source data: ${csiModels.length} ${pluralize('model', csiModels.length)}, ` +
                `${csiDocuments.length} ${pluralize('document', csiDocuments.length)} and ` +
                `${csiAssets.length} ${pluralize('asset', csiAssets.length)}`
        );

        if (init || startWatchingContentUpdates) {
            // backward compatibility
            contentSourceInstance.startWatchingContentUpdates?.({
                getModelMap: () => {
                    const contentSourceData = getContentSourceDataForCurrentInstance('getModelMap');
                    return contentSourceData?.csiModelMap ?? {};
                },
                getDocument: ({ documentId }) => {
                    const contentSourceData = getContentSourceDataForCurrentInstance('getDocument');
                    return contentSourceData?.csiDocumentMap?.[documentId];
                },
                getAsset: ({ assetId }) => {
                    const contentSourceData = getContentSourceDataForCurrentInstance('getAsset');
                    return contentSourceData?.csiAssetMap?.[assetId];
                },
                onContentChange: cache.updateContent,
                onSchemaChange: cache.invalidateSchema
            });
        }

        return {
            id: contentSourceId,
            version: version,
            srcType: contentSourceInstance.getContentSourceType(),
            srcProjectId: contentSourceInstance.getProjectId(),
            instance: contentSourceInstance,
            destroyed: false,
            locales: locales,
            defaultLocaleCode: defaultLocaleCode,
            csiSchema: csiSchema,
            csiModels: csiModels,
            csiModelMap: csiModelMap,
            csiDocuments: csiDocuments,
            csiDocumentMap: csiDocumentMap,
            csiAssets: csiAssets,
            csiAssetMap: csiAssetMap,
            assets: contentStoreAssets,
            assetMap: assetMap,
            scheduledActions: scheduledActions,
            enabledFeatures: { scheduledActions: enabledScheduledActions }
        };
    }

    private onContentChange(
        contentSourceId: string,
        contentChanges: CSITypes.ContentChanges
    ): { contentChangeResult: ContentStoreTypes.ContentChangeResult; presetsUpdated: boolean } {
        // certain content changes, like preset changes are interpreted as schema changes
        let presetsUpdated = false;

        const contentChangesFull: Required<CSITypes.ContentChanges> = {
            documents: contentChanges.documents ?? [],
            assets: contentChanges.assets ?? [],
            scheduledActions: contentChanges.scheduledActions ?? [],
            deletedDocumentIds: contentChanges.deletedDocumentIds ?? [],
            deletedAssetIds: contentChanges.deletedAssetIds ?? [],
            deletedScheduledActionIds: contentChanges.deletedScheduledActionIds ?? []
        };

        this.logger.debug('onContentChange', {
            contentSourceId,
            documentCount: contentChangesFull.documents.length,
            assetCount: contentChangesFull.assets.length,
            scheduledActionCount: contentChangesFull.scheduledActions.length,
            deletedDocumentCount: contentChangesFull.deletedDocumentIds.length,
            deletedAssetCount: contentChangesFull.deletedAssetIds.length,
            deletedScheduledActionCount: contentChangesFull.deletedScheduledActionIds.length
        });

        const result: ContentStoreTypes.ContentChangeResult = {
            updatedDocuments: [],
            updatedAssets: [],
            updatedScheduledActions: [],
            deletedDocuments: [],
            deletedAssets: [],
            deletedScheduledActions: []
        };

        const contentSourceData = this.getContentSourceDataByIdOrThrow(contentSourceId);

        // update contentSourceData with deleted documents
        contentChangesFull.deletedDocumentIds.forEach((docId) => {
            // remove preset, make sure there is something to remove first because
            // were explicitly calling onContentChange from deletePreset as well
            if (this.presets[docId] && contentSourceData.csiDocumentMap[docId]?.modelName === StackbitPresetModelName) {
                presetsUpdated = true;
                const preset = this.presets[docId]!;
                const model = contentSourceData.modelMap[preset.modelName];
                delete this.presets[docId];
                if (model && model.presets) {
                    const presetIdIndex = model.presets.findIndex((presetId) => presetId === docId);
                    model.presets.splice(presetIdIndex, 1);
                }
            }

            // delete document from documents map
            delete contentSourceData.documentMap[docId];
            delete contentSourceData.csiDocumentMap[docId];

            // delete document from document array
            const index = contentSourceData.documents.findIndex((document) => document.srcObjectId === docId);
            if (index !== -1) {
                // the indexes of documents and csiDocuments are always the same as they are always updated at the same time
                contentSourceData.documents.splice(index, 1);
                contentSourceData.csiDocuments.splice(index, 1);
            }

            result.deletedDocuments.push({
                srcType: contentSourceData.srcType,
                srcProjectId: contentSourceData.srcProjectId,
                srcObjectId: docId
            });
        });

        // update contentSourceData with deleted assets
        contentChangesFull.deletedAssetIds.forEach((assetId) => {
            // delete document from asset map
            delete contentSourceData.assetMap[assetId];
            delete contentSourceData.csiAssetMap[assetId];

            // delete document from asset array
            const index = contentSourceData.assets.findIndex((asset) => asset.srcObjectId === assetId);
            if (index !== -1) {
                // the indexes of assets and csiAssets are always the same as they are always updated at the same time
                contentSourceData.assets.splice(index, 1);
                contentSourceData.csiAssets.splice(index, 1);
            }

            result.deletedAssets.push({
                srcType: contentSourceData.srcType,
                srcProjectId: contentSourceData.srcProjectId,
                srcObjectId: assetId
            });
        });

        // update contentSourceData with deleted scheduledActions
        contentChangesFull.deletedScheduledActionIds.forEach((scheduledActionId) => {
            // delete scheduledAction from scheduledActions array
            const index = contentSourceData.scheduledActions.findIndex((scheduledAction) => scheduledAction.id === scheduledActionId);
            if (index !== -1) {
                contentSourceData.scheduledActions.splice(index, 1);
            }

            result.deletedScheduledActions.push({
                srcType: contentSourceData.srcType,
                srcProjectId: contentSourceData.srcProjectId,
                scheduledActionId: scheduledActionId
            });
        });

        // map csi documents through stackbitConfig.mapDocuments
        let mappedDocs = contentChangesFull.documents;
        if (this.stackbitConfig?.mapDocuments) {
            const csiDocumentsWithSource = contentChangesFull.documents.map(
                (csiDocument): CSITypes.DocumentWithSource => ({
                    srcType: contentSourceData.srcType,
                    srcProjectId: contentSourceData.srcProjectId,
                    ...csiDocument
                })
            );

            const modelsWithSource = contentSourceData.models.map((model): CSITypes.ModelWithSource => {
                return {
                    srcType: contentSourceData.srcType,
                    srcProjectId: contentSourceData.srcProjectId,
                    ...model
                };
            });

            mappedDocs =
                this.stackbitConfig?.mapDocuments?.({
                    documents: _.cloneDeep(csiDocumentsWithSource),
                    models: _.cloneDeep(modelsWithSource)
                }) ?? csiDocumentsWithSource;
        }

        // map csi documents and assets to content store documents and assets
        const documents = mapCSIDocumentsToStoreDocuments({
            csiDocuments: mappedDocs,
            contentSourceInstance: contentSourceData.instance,
            modelMap: contentSourceData.modelMap,
            defaultLocaleCode: contentSourceData.defaultLocaleCode,
            assetSources: this.stackbitConfig?.assetSources ?? [],
            customActionRunStateMap: this.customActionRunStateMap,
            createConfigDelegate: getCreateConfigDelegateThunk({
                getContentSourceDataById: () => this.contentSourceDataById,
                logger: this.userLogger
            })
        });
        const assets = mapCSIAssetsToStoreAssets({
            csiAssets: contentChangesFull.assets,
            contentSourceInstance: contentSourceData.instance,
            defaultLocaleCode: contentSourceData.defaultLocaleCode
        });

        // update contentSourceData with new or updated documents and assets
        Object.assign(contentSourceData.csiDocumentMap, _.keyBy(contentChangesFull.documents, 'id'));
        Object.assign(contentSourceData.csiAssetMap, _.keyBy(contentChangesFull.assets, 'id'));
        Object.assign(contentSourceData.documentMap, _.keyBy(documents, 'srcObjectId'));
        Object.assign(contentSourceData.assetMap, _.keyBy(assets, 'srcObjectId'));

        for (let idx = 0; idx < documents.length; idx++) {
            // the indexes of mapped documents and documents from changeEvent are the same
            const document = documents[idx]!;
            const csiDocument = contentChangesFull.documents[idx]!;
            const dataIndex = contentSourceData.documents.findIndex((existingDoc) => existingDoc.srcObjectId === document.srcObjectId);
            if (dataIndex === -1) {
                contentSourceData.documents.push(document);
                contentSourceData.csiDocuments.push(csiDocument);
            } else {
                contentSourceData.documents.splice(dataIndex, 1, document);
                contentSourceData.csiDocuments.splice(dataIndex, 1, csiDocument);
            }
            if (csiDocument.modelName === StackbitPresetModelName) {
                presetsUpdated = true;
                const preset = getPresetFromDocument({
                    srcType: contentSourceData.srcType,
                    srcProjectId: contentSourceData.srcProjectId,
                    csiDocument,
                    csiAssetMap: contentSourceData.csiAssetMap,
                    logger: this.logger
                });
                if (preset) {
                    this.presets[csiDocument.id] = preset;
                    if (dataIndex === -1) {
                        //TODO recalculate assets as well
                        contentSourceData.modelMap[preset.modelName]?.presets?.push(csiDocument.id);
                    }
                }
            }
            result.updatedDocuments.push({
                srcType: contentSourceData.srcType,
                srcProjectId: contentSourceData.srcProjectId,
                srcObjectId: document.srcObjectId
            });
        }

        for (let idx = 0; idx < assets.length; idx++) {
            // the indexes of mapped assets and assets from changeEvent are the same
            const asset = assets[idx]!;
            const csiAsset = contentChangesFull.assets[idx]!;
            const index = contentSourceData.assets.findIndex((existingAsset) => existingAsset.srcObjectId === asset.srcObjectId);
            if (index === -1) {
                contentSourceData.assets.push(asset);
                contentSourceData.csiAssets.push(csiAsset);
            } else {
                // the indexes of assets and csiAssets are always the same as they are always updated at the same time
                contentSourceData.assets.splice(index, 1, asset);
                contentSourceData.csiAssets.splice(index, 1, csiAsset);
            }
            result.updatedAssets.push({
                srcType: contentSourceData.srcType,
                srcProjectId: contentSourceData.srcProjectId,
                srcObjectId: asset.srcObjectId
            });
        }

        const scheduledActions = contentChangesFull.scheduledActions;
        for (let idx = 0; idx < scheduledActions.length; idx++) {
            // the indexes of mapped assets and assets from changeEvent are the same
            const scheduledAction = scheduledActions[idx]!;
            const index = contentSourceData.scheduledActions.findIndex((existingScheduledAction) => existingScheduledAction.id === scheduledAction.id);
            if (index === -1) {
                contentSourceData.scheduledActions.push(scheduledAction);
            } else {
                contentSourceData.scheduledActions.splice(index, 1, scheduledAction);
            }
            result.updatedScheduledActions.push({
                srcType: contentSourceData.srcType,
                srcProjectId: contentSourceData.srcProjectId,
                scheduledActionId: scheduledAction.id
            });
        }

        return {
            contentChangeResult: result,
            presetsUpdated
        };
    }

    private async processData({
        stackbitConfig,
        configModels,
        presets,
        contentSourceRawDataArr
    }: {
        stackbitConfig: Config | null;
        configModels: ModelExtension[];
        presets: Record<string, Preset>;
        contentSourceRawDataArr: ContentSourceRawData[];
    }): Promise<Record<string, ContentSourceData>> {
        this.logger.debug('processData');
        // Group models from all content sources by their names

        const csiModelGroups = contentSourceRawDataArr.reduce((modelGroups: Record<string, CSITypes.ModelWithSource[]>, csData) => {
            return csData.csiModels.reduce((modelGroups, model) => {
                if (!(model.name in modelGroups)) {
                    modelGroups[model.name] = [];
                }
                modelGroups[model.name]!.push({
                    srcType: csData.srcType,
                    srcProjectId: csData.srcProjectId,
                    ...model
                });
                return modelGroups;
            }, modelGroups);
        }, {});

        // Match config models to the group of content source models with the same name.
        // Then, match the config model to content source model by comparing srcType and
        // srcProjectId. If after the comparison, there are more than one model left,
        // log a warning and filter out that config model so it won't be merged with any
        // of the content source models.
        const nonMatchedModels: { configModel: ModelExtension; matchedCSIModels: CSITypes.ModelWithSource[] }[] = [];
        const configModelsByContentSourceId = configModels.reduce((modelGroups: Record<string, ModelExtension[]>, configModel) => {
            const csiModels = csiModelGroups[configModel.name];
            if (!csiModels) {
                nonMatchedModels.push({
                    configModel,
                    matchedCSIModels: []
                });
                return modelGroups;
            }
            const matchedCSIModels = csiModels.filter((model) => {
                const matchesType = !configModel.srcType || model.srcType === configModel.srcType;
                const matchesId = !configModel.srcProjectId || model.srcProjectId === configModel.srcProjectId;
                return matchesType && matchesId;
            });
            if (matchedCSIModels.length !== 1) {
                nonMatchedModels.push({
                    configModel,
                    matchedCSIModels
                });
                return modelGroups;
            }
            const contentSource = matchedCSIModels[0]!;
            const contentSourceId = getContentSourceId(contentSource.srcType, contentSource.srcProjectId);
            append(modelGroups, contentSourceId, configModel);
            return modelGroups;
        }, {});

        // Log model matching warnings using user logger
        for (const { configModel, matchedCSIModels } of nonMatchedModels) {
            let configModelMessage = `model name: '${configModel.name}'`;
            if (configModel.srcType) {
                configModelMessage += `, srcType: '${configModel.srcType}'`;
            }
            if (configModel.srcProjectId) {
                configModelMessage += `, srcProjectId: '${configModel.srcProjectId}'`;
            }
            configModelMessage = configModelMessage + ` defined in stackbit config`;
            let contentSourceModelsMessage;
            if (matchedCSIModels.length) {
                const matchesModelsMessage = matchedCSIModels.map((model) => `srcType: '${model.srcType}', srcProjectId: '${model.srcProjectId}'`).join('; ');
                contentSourceModelsMessage = ` matches more that 1 model in the following content sources: ${matchesModelsMessage}`;
            } else {
                contentSourceModelsMessage = ' does not match any content source model';
            }
            this.userLogger.warn(configModelMessage + contentSourceModelsMessage);
        }

        const modelsWithSource = contentSourceRawDataArr.reduce((accum: CSITypes.ModelWithSource[], csData) => {
            const contentSourceId = getContentSourceId(csData.srcType, csData.srcProjectId);
            const mergedModels = mergeConfigModelsWithExternalModels({
                configModels: configModelsByContentSourceId[contentSourceId] ?? [],
                externalModels: csData.csiModels,
                logger: this.userLogger
            });
            const modelsWithSource = mergedModels.map((model): CSITypes.ModelWithSource => {
                return {
                    srcType: csData.srcType,
                    srcProjectId: csData.srcProjectId,
                    ...model
                };
            });
            return accum.concat(modelsWithSource);
        }, []);

        // TODO: Is there a better way than deep cloning objects before passing them to user methods?
        //   Not cloning mutable objects will break the internal state if user mutates the objects.
        const mappedModels = stackbitConfig?.mapModels?.({ models: _.cloneDeep(modelsWithSource) }) ?? modelsWithSource;
        const normalizedModels = normalizeModels({ models: mappedModels, logger: this.userLogger });
        const validatedModels = validateModels({ models: normalizedModels, logger: this.userLogger });
        const modelsWithPresetsIds = extendModelsWithPresetsIds({ models: validatedModels, presets });
        const { models } = await this.handleConfigAssets({ models: modelsWithPresetsIds });

        let documentMapByContentSource: Record<string, Record<string, CSITypes.Document[]>> | null = null;
        if (stackbitConfig?.mapDocuments) {
            const csiDocumentsWithSource = contentSourceRawDataArr.reduce((accum: CSITypes.DocumentWithSource[], csData) => {
                const csiDocumentsWithSource = csData.csiDocuments.map(
                    (csiDocument): CSITypes.DocumentWithSource => ({
                        srcType: csData.srcType,
                        srcProjectId: csData.srcProjectId,
                        ...csiDocument
                    })
                );
                return accum.concat(csiDocumentsWithSource);
            }, []);

            // TODO: Is there a better way than deep cloning objects before passing them to user methods?
            //   Not cloning mutable objects will break the internal state if user mutates the objects.
            const mappedDocs =
                stackbitConfig?.mapDocuments?.({
                    documents: _.cloneDeep(csiDocumentsWithSource),
                    models: _.cloneDeep(models)
                }) ?? csiDocumentsWithSource;
            documentMapByContentSource = groupDocumentsByContentSource({ documents: mappedDocs });
        }

        const modelMapByContentSource = groupModelsByContentSource({ models: models });

        const contentSourceDataArr = contentSourceRawDataArr.map((csData): ContentSourceData => {
            const modelMap = _.get(modelMapByContentSource, [csData.srcType, csData.srcProjectId], {});
            const csiDocuments = documentMapByContentSource
                ? _.get(documentMapByContentSource, [csData.srcType, csData.srcProjectId], [])
                : csData.csiDocuments;
            const documents = mapCSIDocumentsToStoreDocuments({
                csiDocuments: csiDocuments,
                contentSourceInstance: csData.instance,
                modelMap: modelMap,
                defaultLocaleCode: csData.defaultLocaleCode,
                assetSources: this.stackbitConfig?.assetSources ?? [],
                customActionRunStateMap: this.customActionRunStateMap,
                createConfigDelegate: getCreateConfigDelegateThunk({
                    getContentSourceDataById: () => this.contentSourceDataById,
                    logger: this.userLogger
                })
            });
            return {
                ...csData,
                models: Object.values(modelMap),
                modelMap,
                documents,
                documentMap: _.keyBy(documents, 'srcObjectId')
            };
        });

        this.logger.debug('processData finished');
        return _.keyBy(contentSourceDataArr, 'id');
    }

    getContentSourceMeta(): { srcType: string; srcProjectId: string; srcVersion: string; csiVersion: string; supportsScheduledActions: boolean }[] {
        return _.reduce(
            this.contentSourceDataById,
            (
                result: { srcType: string; srcProjectId: string; srcVersion: string; csiVersion: string; supportsScheduledActions: boolean }[],
                contentSourceData
            ) => {
                return result.concat({
                    srcType: contentSourceData.srcType,
                    srcProjectId: contentSourceData.srcProjectId,
                    srcVersion: contentSourceData.version.contentSourceVersion,
                    csiVersion: contentSourceData.version.interfaceVersion,
                    supportsScheduledActions: contentSourceData?.enabledFeatures.scheduledActions ?? false
                });
            },
            []
        );
    }

    getAssetSources(): CSITypes.DistributiveOmit<CSITypes.AssetSource, 'transform' | 'preview'>[] {
        return getAssetSourcesForClient(this.stackbitConfig);
    }

    getModels(): Record<string, Record<string, Record<string, Model | ImageModel>>> {
        return _.reduce(
            this.contentSourceDataById,
            (result: Record<string, Record<string, Record<string, Model | ImageModel>>>, contentSourceData) => {
                const contentSourceType = contentSourceData.instance.getContentSourceType();
                const srcProjectId = contentSourceData.instance.getProjectId();
                const filteredModels = _.omitBy(contentSourceData.modelMap, (model) => model.name === StackbitPresetModelName);
                const mappedModels = stripModelActions({ modelMap: filteredModels });
                // if `projectId` is number (even as string) e.g., '1234', _.set() will create an array of length 1235 and insert the item at the end.
                // _.setWith(..., Object) ensures the values are always created as object keys, not as array indexes.
                _.setWith(result, [contentSourceType, srcProjectId], mappedModels, Object);
                _.setWith(result, [contentSourceType, srcProjectId, '__image_model'], IMAGE_MODEL, Object);
                return result;
            },
            {}
        );
    }

    getLocales(): ContentStoreTypes.ContentStoreLocale[] {
        return _.reduce(
            this.contentSourceDataById,
            (result: ContentStoreTypes.ContentStoreLocale[], contentSourceData) => {
                return result.concat({
                    srcType: contentSourceData.srcType,
                    srcProjectId: contentSourceData.srcProjectId,
                    locales: contentSourceData.locales?.map((locale) => locale.code) ?? [],
                    defaultLocale: contentSourceData.defaultLocaleCode
                });
            },
            []
        );
    }

    async getGlobalActions({
        pageUrl,
        user,
        locale,
        currentPageDocument
    }: {
        pageUrl?: string;
        user?: ContentStoreTypes.User;
        locale?: string;
        currentPageDocument?: ContentStoreTypes.APICustomActionDocumentSpecifier;
    }): Promise<(ContentStoreTypes.APICustomActionGlobal | ContentStoreTypes.APICustomActionBulk)[]> {
        return getGlobalAndBulkAPIActions({
            stackbitConfig: this.stackbitConfig,
            customActionRunStateMap: this.customActionRunStateMap,
            contentSourceDataById: this.contentSourceDataById,
            userLogger: this.userLogger,
            locale,
            pageUrl,
            user,
            currentPageDocument
        });
    }

    async getCustomActions(getActionRequest: ContentStoreTypes.APIGetCustomActionRequest): Promise<ContentStoreTypes.APICustomAction[]> {
        return resolveCustomActionsById({
            getActionRequest,
            customActionRunStateMap: this.customActionRunStateMap,
            contentSourceDataById: this.contentSourceDataById,
            stackbitConfig: this.stackbitConfig,
            userLogger: this.userLogger
        });
    }

    async runCustomAction(runActionRequest: ContentStoreTypes.APIRunCustomActionRequest): Promise<void> {
        this.onActionStateChangeCallback({
            actionId: runActionRequest.actionId,
            actionName: runActionRequest.actionName,
            actionType: runActionRequest.actionType,
            state: 'running'
        });
        runCustomAction({
            runActionRequest: runActionRequest,
            contentSourceDataById: this.contentSourceDataById,
            customActionRunStateMap: this.customActionRunStateMap,
            userLogger: this.userLogger,
            stackbitConfig: this.stackbitConfig
        }).then((actionStateChange) => {
            this.onActionStateChangeCallback(actionStateChange);
        });
    }

    getPresets({ locale }: { locale?: string } = {}): Record<string, any> {
        if (!this.presets || !locale) {
            return this.presets ?? {};
        }
        return _.pickBy(this.presets, (preset) => !preset.locale || preset.locale === locale);
    }

    getContentSourceEnvironment({ srcProjectId, srcType }: { srcProjectId: string; srcType: string }): string {
        const contentSourceId = getContentSourceId(srcType, srcProjectId);
        const contentSourceData = this.getContentSourceDataByIdOrThrow(contentSourceId);
        return contentSourceData.instance.getProjectEnvironment();
    }

    usesContentSourcePresets() {
        return Boolean(this.presetsContentSource);
    }

    async hasAccess({
        srcType,
        srcProjectId,
        user
    }: {
        srcType?: string;
        srcProjectId?: string;
        user?: ContentStoreTypes.User;
    }): Promise<ContentStoreTypes.HasAccessResult> {
        let contentSourceDataArr: ContentSourceData[];
        if (srcType && srcProjectId) {
            const contentSourceId = getContentSourceId(srcType, srcProjectId);
            const contentSourceData = this.getContentSourceDataByIdOrThrow(contentSourceId);
            contentSourceDataArr = [contentSourceData];
        } else {
            contentSourceDataArr = Object.values(this.contentSourceDataById);
        }
        return reducePromise(
            contentSourceDataArr,
            async (accum: ContentStoreTypes.HasAccessResult, contentSourceData) => {
                const srcType = contentSourceData.srcType;
                const srcProjectId = contentSourceData.srcProjectId;
                const userContext = getUserContextForSrcType(srcType, user);
                const result = await contentSourceData.instance.hasAccess({ userContext });
                return {
                    hasConnection: accum.hasConnection && result.hasConnection,
                    hasPermissions: accum.hasPermissions && result.hasPermissions,
                    contentSources: accum.contentSources.concat({
                        srcType,
                        srcProjectId,
                        ...result
                    })
                };
            },
            {
                hasConnection: true,
                hasPermissions: true,
                contentSources: []
            }
        );
    }

    hasChanges({
        srcType,
        srcProjectId,
        documents
    }: {
        srcType?: string;
        srcProjectId?: string;
        documents?: { srcType: string; srcProjectId: string; srcObjectId: string }[];
    }): {
        hasChanges: boolean;
        changedObjects: {
            srcType: string;
            srcProjectId: string;
            srcObjectId: string;
        }[];
    } {
        let result: (ContentStoreTypes.Document | ContentStoreTypes.Asset)[];
        if (srcType && srcProjectId) {
            const contentSourceId = getContentSourceId(srcType, srcProjectId);
            const contentSourceData = this.getContentSourceDataByIdOrThrow(contentSourceId);
            result = [...contentSourceData.documents, ...contentSourceData.assets];
        } else if (documents && documents.length > 0) {
            const documentsBySourceId = _.groupBy(documents, (document) => getContentSourceId(document.srcType, document.srcProjectId));
            result = _.reduce(
                documentsBySourceId,
                (result: (ContentStoreTypes.Document | ContentStoreTypes.Asset)[], documents, contentSourceId) => {
                    const contentSourceData = this.getContentSourceDataByIdOrThrow(contentSourceId);
                    for (const document of documents) {
                        if (document.srcObjectId in contentSourceData.documentMap) {
                            result.push(contentSourceData.documentMap[document.srcObjectId]!);
                        } else if (document.srcObjectId in contentSourceData.assetMap) {
                            result.push(contentSourceData.assetMap[document.srcObjectId]!);
                        }
                    }
                    return result;
                },
                []
            );
        } else {
            result = _.reduce(
                this.contentSourceDataById,
                (result: (ContentStoreTypes.Document | ContentStoreTypes.Asset)[], contentSourceData) => {
                    return result.concat(contentSourceData.documents, contentSourceData.assets);
                },
                []
            );
        }
        const changedDocuments = result.filter((document) => document.status === 'added' || document.status === 'modified');
        return {
            hasChanges: !_.isEmpty(changedDocuments),
            changedObjects: changedDocuments.map((item) => ({
                srcType: item.srcType,
                srcProjectId: item.srcProjectId,
                srcObjectId: item.srcObjectId
            }))
        };
    }

    getSiteMapEntries({ locale }: { locale?: string } = {}): CSITypes.SiteMapEntry[] {
        const siteMapEntries = _.reduce(
            this.siteMapEntryGroups,
            (accum: CSITypes.SiteMapEntry[], siteMapEntryGroup) => {
                return _.reduce(
                    siteMapEntryGroup,
                    (accum: CSITypes.SiteMapEntry[], siteMapEntry) => {
                        if (!siteMapEntry.label) {
                            const fieldLabelValue = getDocumentFieldLabelValueForSiteMapEntry({
                                siteMapEntry,
                                locale,
                                contentSourceDataById: this.contentSourceDataById
                            });
                            siteMapEntry = {
                                ...siteMapEntry,
                                label: fieldLabelValue ?? siteMapEntry.urlPath
                            };
                        }
                        accum.push(siteMapEntry);
                        return accum;
                    },
                    accum
                );
            },
            []
        );

        return _.isEmpty(locale) ? siteMapEntries : siteMapEntries.filter((siteMapEntry) => !siteMapEntry.locale || siteMapEntry.locale === locale);
    }

    getTreeViews(): CSITypes.TreeViewNode[] {
        return this.treeViews;
    }

    getSiteMapEntriesForDocument({
        srcType,
        srcProjectId,
        srcDocumentId,
        locale
    }: {
        srcType: string;
        srcProjectId: string;
        srcDocumentId: string;
        locale?: string;
    }): CSITypes.SiteMapEntry[] {
        const key = getSiteMapGroupKeyForDocument({
            srcType: srcType,
            srcProjectId: srcProjectId,
            srcDocumentId: srcDocumentId
        });
        const siteMapEntryGroup = this.siteMapEntryGroups[key];
        const siteMapEntries = _.values(siteMapEntryGroup);
        return _.isEmpty(locale) ? siteMapEntries : siteMapEntries.filter((siteMapEntry) => !siteMapEntry.locale || siteMapEntry.locale === locale);
    }

    getDocument({
        srcDocumentId,
        srcProjectId,
        srcType
    }: {
        srcDocumentId: string;
        srcProjectId: string;
        srcType: string;
    }): ContentStoreTypes.Document | undefined {
        const contentSourceId = getContentSourceId(srcType, srcProjectId);
        const contentSourceData = this.getContentSourceDataByIdOrThrow(contentSourceId);
        return contentSourceData.documentMap[srcDocumentId];
    }

    getDocumentsByContext({ context, srcProjectId, srcType }: { context: any; srcProjectId?: string; srcType: string }): ContentStoreTypes.Document[] {
        const contentSourcesData: ContentStoreTypes.ContentSourceData[] = findContentSourcesDataForTypeOrId({
            contentSourceDataById: this.contentSourceDataById,
            srcType,
            srcProjectId
        });
        return _.reduce(
            contentSourcesData,
            (documents: ContentStoreTypes.Document[], csData: ContentStoreTypes.ContentSourceData) => {
                const matchingDocuments = _.filter(csData.csiDocuments, { context })
                    .map((document) => csData.documentMap[document.id])
                    .filter(Boolean);
                return [...documents, ...matchingDocuments] as ContentStoreTypes.Document[];
            },
            []
        );
    }

    getDocuments({ locale }: { locale?: string } = {}): ContentStoreTypes.Document[] {
        return _.reduce(
            this.contentSourceDataById,
            (documents: ContentStoreTypes.Document[], contentSourceData) => {
                const currentDocuments = _.isEmpty(locale)
                    ? contentSourceData.documents
                    : contentSourceData.documents.filter((document) => !document.locale || document.locale === locale);
                const filteredDocuments = currentDocuments.filter((document) => document.srcModelName !== StackbitPresetModelName);
                return documents.concat(filteredDocuments);
            },
            []
        );
    }

    getAsset({ srcAssetId, srcProjectId, srcType }: { srcAssetId: string; srcProjectId: string; srcType: string }): ContentStoreTypes.Asset | undefined {
        const contentSourceId = getContentSourceId(srcType, srcProjectId);
        const contentSourceData = this.getContentSourceDataByIdOrThrow(contentSourceId);
        return contentSourceData.assetMap[srcAssetId];
    }

    getAssets({ locale }: { locale?: string }): ContentStoreTypes.Asset[] {
        return _.reduce(
            this.contentSourceDataById,
            (assets: ContentStoreTypes.Asset[], contentSourceData) => {
                const currentAssets = _.isEmpty(locale)
                    ? contentSourceData.assets
                    : contentSourceData.assets.filter((asset) => !asset.locale || asset.locale === locale);
                return assets.concat(currentAssets);
            },
            []
        );
    }

    getLocalizedApiObjects({ locale, objectIds }: { locale?: string; objectIds?: string[] }): ContentStoreTypes.APIObject[] {
        const hasExplicitLocale = !_.isEmpty(locale);
        return _.reduce(
            this.contentSourceDataById,
            (objects: ContentStoreTypes.APIObject[], contentSourceData) => {
                let documents = objectIds
                    ? contentSourceData.documents.filter((document) => objectIds.includes(document.srcObjectId))
                    : contentSourceData.documents;
                documents = hasExplicitLocale ? documents.filter((document) => !document.locale || document.locale === locale) : documents;
                let assets = objectIds ? contentSourceData.assets.filter((asset) => objectIds.includes(asset.srcObjectId)) : contentSourceData.assets;
                assets = hasExplicitLocale ? assets.filter((asset) => !asset.locale || asset.locale === locale) : assets;
                const currentLocale = locale ?? contentSourceData.defaultLocaleCode;
                const filteredDocuments = documents.filter((document) => document.srcModelName !== StackbitPresetModelName);
                const documentObjects = mapDocumentsToLocalizedApiObjects({
                    documents: filteredDocuments,
                    locale: currentLocale,
                    delegate: createConfigDelegate({ contentSourceDataById: this.contentSourceDataById, logger: this.userLogger })
                });
                const imageObjects = mapAssetsToLocalizedApiImages(assets, this.staticAssetsPublicPath, currentLocale);
                return objects.concat(documentObjects, imageObjects);
            },
            []
        );
    }

    getApiAssets({
        srcType,
        srcProjectId,
        pageSize = 20,
        pageNum = 1,
        searchQuery
    }: { srcType?: string; srcProjectId?: string; pageSize?: number; pageNum?: number; searchQuery?: string } = {}): {
        assets: ContentStoreTypes.APIAsset[];
        pageSize: number;
        pageNum: number;
        totalPages: number;
    } {
        let assets: ContentStoreTypes.APIAsset[];
        if (srcProjectId && srcType) {
            const contentSourceId = getContentSourceId(srcType, srcProjectId);
            const contentSourceData = this.getContentSourceDataByIdOrThrow(contentSourceId);
            assets = mapStoreAssetsToAPIAssets(contentSourceData.assets, this.staticAssetsPublicPath, contentSourceData.defaultLocaleCode);
        } else {
            assets = _.reduce(
                this.contentSourceDataById,
                (result: ContentStoreTypes.APIAsset[], contentSourceData) => {
                    const assets = mapStoreAssetsToAPIAssets(contentSourceData.assets, this.staticAssetsPublicPath, contentSourceData.defaultLocaleCode);
                    return result.concat(assets);
                },
                []
            );
        }

        let filteredFiles = assets;
        if (searchQuery) {
            const sanitizedSearchQuery = sanitizeFilename(searchQuery).toLowerCase();
            filteredFiles = assets.filter((asset) => asset.fileName && path.basename(asset.fileName).toLowerCase().includes(sanitizedSearchQuery));
        }
        const sortedAssets = _.orderBy(filteredFiles, ['fileName'], ['asc']);
        const skip = (pageNum - 1) * pageSize;
        const totalPages = Math.ceil(filteredFiles.length / pageSize);
        const pagesAssets = sortedAssets.slice(skip, skip + pageSize);

        return {
            assets: pagesAssets,
            pageSize: pageSize,
            pageNum: pageNum,
            totalPages: totalPages
        };
    }

    async createAndLinkDocument({
        srcType,
        srcProjectId,
        srcDocumentId,
        fieldPath,
        modelName,
        refSrcType,
        refProjectId,
        object,
        index,
        locale,
        user
    }: {
        srcType: string;
        srcProjectId: string;
        srcDocumentId: string;
        fieldPath: (string | number)[];
        modelName?: string;
        refSrcType?: string;
        refProjectId?: string;
        object?: Record<string, any>;
        index?: number;
        locale?: string;
        user?: ContentStoreTypes.User;
    }): Promise<{ srcDocumentId: string; createdDocumentId: string }> {
        this.logger.debug('createAndLinkDocument', { srcType, srcProjectId, srcDocumentId, fieldPath, modelName, refSrcType, refProjectId, index, locale });

        const contentSourceId = getContentSourceId(srcType, srcProjectId);
        const contentSourceData = this.getContentSourceDataByIdOrThrow(contentSourceId);

        // get the document that is being updated
        const document = contentSourceData.documentMap[srcDocumentId];
        const csiDocument = contentSourceData.csiDocumentMap[srcDocumentId];
        if (!document || !csiDocument) {
            throw new Error(`Document not found: '${srcDocumentId}'. Source: '${contentSourceData.id}'.`);
        }

        const modelMap = contentSourceData.modelMap;
        const csiModelMap = contentSourceData.csiModelMap;

        // get the 'reference' model field in the updated document that will be used to link the new document
        locale = locale ?? contentSourceData.defaultLocaleCode;
        const modelField = getModelFieldAtFieldPath(document, fieldPath, modelMap, locale);
        const csiModelField = getModelFieldAtFieldPath(document, fieldPath, csiModelMap, locale);
        if (!modelField || !csiModelField) {
            throw Error(`Field path not found:'${fieldPath.join('.')}'.`);
        }
        const fieldProps = modelField.type === 'list' ? modelField.items! : modelField;
        const csiFieldProps = csiModelField.type === 'list' ? csiModelField.items! : csiModelField;
        if (fieldProps.type !== 'reference' && fieldProps.type !== 'cross-reference') {
            throw new Error(`createAndLinkDocument can only be used on fields of type reference at field path: '${fieldPath.join('.')}'`);
        }

        // get the model name for the new document
        if (!modelName && fieldProps.models.length === 1) {
            if (fieldProps.type === 'reference') {
                modelName = fieldProps.models[0];
            } else if (fieldProps.type === 'cross-reference') {
                modelName = fieldProps.models[0]!.modelName;
            }
        }
        if (!modelName) {
            throw new Error(`modelName is required for createAndLinkDocument. Field path: '${fieldPath.join('.')}'.`);
        }

        if (fieldProps.type === 'reference') {
            refSrcType = srcType;
            refProjectId = srcProjectId;
        } else if (!refSrcType || !refProjectId) {
            throw new Error(`refSrcType and refProjectId are required for linking fields of type cross-reference for field path: '${fieldPath.join('.')}'.`);
        }

        // create the new document
        const result = await this.createDocument({
            object: object,
            srcProjectId: refProjectId,
            srcType: refSrcType,
            modelName: modelName,
            locale: locale,
            user: user
        });

        // update the document by linking the field to the created document
        const userContext = getUserContextForSrcType(srcType, user);
        let field: CSITypes.UpdateOperationField;
        if (fieldProps.type === 'reference') {
            field = {
                type: 'reference',
                refType: 'document',
                refId: result.srcDocumentId
            } as CSITypes.UpdateOperationReferenceField;
        } else {
            if (!isOneOfFieldTypes(csiFieldProps.type, ['string', 'text', 'json', 'cross-reference'])) {
                throw new Error(
                    `Invalid type for cross-reference field: ${
                        csiFieldProps.type
                    }. Must be one of: string, text, json, cross-reference. Field path: '${fieldPath.join('.')}'.`
                );
            }
            field = updateOperationValueFieldWithCrossReference(csiFieldProps.type, {
                refId: result.srcDocumentId,
                refSrcType: refSrcType,
                refProjectId: refProjectId
            });
        }

        const operations: CSITypes.UpdateOperation[] = [
            modelField.type === 'list'
                ? {
                      opType: 'insert',
                      fieldPath: fieldPath,
                      modelField: csiModelField as CSITypes.FieldList,
                      locale: locale,
                      index: index,
                      item: field
                  }
                : {
                      opType: 'set',
                      fieldPath: fieldPath,
                      modelField: csiModelField,
                      locale: locale,
                      field: field
                  }
        ];

        await this.updateDocumentHooked({
            updateDocumentOptions: {
                document: csiDocument,
                modelMap: csiModelMap,
                userContext: userContext,
                operations: operations
            },
            contentSourceData: contentSourceData,
            user: user
        });

        return { srcDocumentId: srcDocumentId, createdDocumentId: result.srcDocumentId };
    }

    async createPreset({
        preset,
        thumbnailAsset,
        user
    }: {
        preset: Preset;
        thumbnailAsset: ContentStoreTypes.UploadAssetData;
        user?: ContentStoreTypes.User;
    }): Promise<{ srcDocumentId: string }> {
        if (!this.presetsContentSource) {
            throw new Error('Error saving preset: No content source available.');
        }
        let thumbnail: string | undefined;
        if (thumbnailAsset) {
            const assets = await this.uploadAssets({
                srcType: this.presetsContentSource.getContentSourceType(),
                srcProjectId: this.presetsContentSource.getProjectId(),
                assets: [thumbnailAsset],
                user
            });
            thumbnail = assets[0]?.objectId;
        }
        const contentSourceData = this.getContentSourceDataByIdOrThrow(getContentSourceIdForContentSource(this.presetsContentSource));
        const document = await this.createDocument({
            srcType: this.presetsContentSource.getContentSourceType(),
            srcProjectId: this.presetsContentSource.getProjectId(),
            modelName: StackbitPresetModelName,
            object: {
                ...getDocumentObjectFromPreset(preset, contentSourceData.modelMap[StackbitPresetModelName]),
                thumbnail
            },
            user
        });
        return { srcDocumentId: document.srcDocumentId };
    }

    async deletePreset({ presetId, user }: { presetId: string; user?: ContentStoreTypes.User }) {
        if (!this.presetsContentSource) {
            throw new Error('Error deleting preset: No content source available.');
        }
        await this.deleteDocument({
            srcType: this.presetsContentSource.getContentSourceType(),
            srcProjectId: this.presetsContentSource.getProjectId(),
            srcDocumentId: presetId,
            user
        });

        // we delete presets immediately because some CMSs don't notify us
        // when documents have been deleted.
        const contentSourceId = getContentSourceIdForContentSource(this.presetsContentSource);
        this.pushContentSourceEvent({
            eventName: ContentStoreEventType.ContentSourceContentChange,
            contentSourceId: contentSourceId,
            contentChanges: {
                documents: [],
                deletedDocumentIds: [presetId],
                assets: [],
                deletedAssetIds: []
            }
        });
        await this.processContentStoreEvents();
    }

    async uploadAndLinkAsset({
        srcType,
        srcProjectId,
        srcDocumentId,
        fieldPath,
        asset,
        index,
        locale,
        user
    }: {
        srcType: string;
        srcProjectId: string;
        srcDocumentId: string;
        fieldPath: (string | number)[];
        asset: ContentStoreTypes.UploadAssetData;
        index?: number;
        locale?: string;
        user?: ContentStoreTypes.User;
    }): Promise<{ srcDocumentId: string }> {
        this.logger.debug('uploadAndLinkAsset', { srcType, srcProjectId, srcDocumentId, fieldPath, index, locale });

        // get the document that is being updated
        const contentSourceId = getContentSourceId(srcType, srcProjectId);
        const contentSourceData = this.getContentSourceDataByIdOrThrow(contentSourceId);
        const document = contentSourceData.documentMap[srcDocumentId];
        const csiDocument = contentSourceData.csiDocumentMap[srcDocumentId];
        if (!document || !csiDocument) {
            throw new Error(`Document not found: '${srcDocumentId}'. Source: '${contentSourceData.id}'.`);
        }

        const csiModelMap = contentSourceData.csiModelMap;

        // get the 'reference' model field in the updated document that will be used to link the new asset
        locale = locale ?? contentSourceData.defaultLocaleCode;
        const csiModelField = getModelFieldAtFieldPath(document, fieldPath, csiModelMap, locale);
        if (!csiModelField) {
            throw Error(`Field path not found: '${fieldPath.join('.')}'.`);
        }
        const fieldProps = csiModelField.type === 'list' ? csiModelField.items! : csiModelField;
        if (fieldProps.type !== 'reference' && fieldProps.type !== 'image') {
            throw Error(`uploadAndLinkAsset can only be used on fields of type: reference, image. Field path: '${fieldPath.join('.')}'.`);
        }

        // upload the new asset
        const userContext = getUserContextForSrcType(srcType, user);
        const result = await contentSourceData.instance.uploadAsset({
            url: asset.url,
            fileName: asset.metadata.name,
            mimeType: asset.metadata.type,
            locale: locale,
            userContext: userContext
        });

        // update the document by linking the field to the created asset
        const field = {
            type: 'reference',
            refType: 'asset',
            refId: result.id
        } as const;

        const operations: CSITypes.UpdateOperation[] = [
            csiModelField.type === 'list'
                ? {
                      opType: 'insert',
                      fieldPath: fieldPath,
                      modelField: csiModelField,
                      locale: locale,
                      index: index,
                      item: field
                  }
                : {
                      opType: 'set',
                      fieldPath: fieldPath,
                      modelField: csiModelField,
                      locale: locale,
                      field: field
                  }
        ];

        await this.updateDocumentHooked({
            updateDocumentOptions: {
                document: csiDocument,
                modelMap: csiModelMap,
                userContext: userContext,
                operations: operations
            },
            contentSourceData: contentSourceData,
            user: user
        });

        return { srcDocumentId: srcDocumentId };
    }

    async createDocument({
        srcType,
        srcProjectId,
        modelName,
        object,
        locale,
        defaultLocaleDocumentId,
        user
    }: {
        srcType: string;
        srcProjectId: string;
        modelName: string;
        object?: Record<string, any>;
        locale?: string;
        defaultLocaleDocumentId?: string;
        user?: ContentStoreTypes.User;
    }): Promise<{ srcDocumentId: string }> {
        this.logger.debug('createDocument', { srcType, srcProjectId, modelName, locale });
        logCreateDocument({ userLogger: this.userLogger, srcType, srcProjectId, modelName, locale, object });

        const contentSourceId = getContentSourceId(srcType, srcProjectId);
        const contentSourceData = this.getContentSourceDataByIdOrThrow(contentSourceId);
        const resolvedLocale = locale ?? contentSourceData.defaultLocaleCode;
        const csiModel = contentSourceData.csiModelMap[modelName];

        if (!csiModel) {
            throw new Error(`Error creating document: model not found: '${modelName}' (source: ${contentSourceId}).`);
        }

        if (this.stackbitConfig?.onContentCreate) {
            object = await this.stackbitConfig.onContentCreate({
                object: object ?? {},
                locale,
                model: {
                    srcType: contentSourceData.srcType,
                    srcProjectId: contentSourceData.srcProjectId,
                    ...csiModel
                },
                ...createConfigDelegate({
                    contentSourceDataById: this.contentSourceDataById,
                    logger: this.userLogger
                })
            });
        }

        const result = await createDocumentRecursively({
            object,
            locale: resolvedLocale,
            userLogger: this.userLogger,
            modelName,
            contentSourceId,
            contentSourceDataById: this.contentSourceDataById,
            assetSources: this.stackbitConfig?.assetSources ?? [],
            createDocument: this.getCreateDocumentThunk({
                defaultLocaleDocumentId,
                user
            })
        });

        this.logger.debug('created document', { srcType, srcProjectId, srcDocumentId: result.documentId, modelName });

        return { srcDocumentId: result.documentId };
    }

    async updateDocument({
        srcType,
        srcProjectId,
        srcDocumentId,
        updateOperations,
        user
    }: {
        srcType: string;
        srcProjectId: string;
        srcDocumentId: string;
        updateOperations: ContentStoreTypes.UpdateOperation[];
        user?: ContentStoreTypes.User;
    }): Promise<{ srcDocumentId: string }> {
        this.logger.debug('updateDocument');
        logUpdateDocument({ userLogger: this.userLogger, srcType, srcProjectId, srcDocumentId, updateOperations });

        const contentSourceId = getContentSourceId(srcType, srcProjectId);
        const contentSourceData = this.getContentSourceDataByIdOrThrow(contentSourceId);
        const userContext = getUserContextForSrcType(srcType, user);
        const document = contentSourceData.documentMap[srcDocumentId];
        const csiDocument = contentSourceData.csiDocumentMap[srcDocumentId];
        if (!document || !csiDocument) {
            throw new Error(`Document not found: '${srcDocumentId}' (Source: '${contentSourceData.id}'.)`);
        }

        const modelMap = contentSourceData.modelMap;
        const csiModelMap = contentSourceData.csiModelMap;
        const documentModelName = document.srcModelName;
        const csiModel = csiModelMap[documentModelName];
        if (!csiModel) {
            throw new Error(`Error updating document: could not find document model '${documentModelName}'.`);
        }

        const operations = await mapPromise(updateOperations, async (updateOperation): Promise<CSITypes.UpdateOperation> => {
            const locale = updateOperation.locale ?? contentSourceData.defaultLocaleCode;
            const modelField = getModelFieldAtFieldPath(document, updateOperation.fieldPath, modelMap, locale);
            const csiModelField = getModelFieldAtFieldPath(document, updateOperation.fieldPath, csiModelMap, locale);
            switch (updateOperation.opType) {
                case 'set': {
                    const field = await convertOperationField({
                        operationField: updateOperation.field,
                        fieldPath: [csiModel.name, ...updateOperation.fieldPath],
                        modelField,
                        csiModelField,
                        locale,
                        modelMap,
                        csiModelMap,
                        contentSourceId,
                        contentSourceDataById: this.contentSourceDataById,
                        assetSources: this.stackbitConfig?.assetSources ?? [],
                        createDocument: this.getCreateDocumentThunk({ user }),
                        userLogger: this.userLogger
                    });
                    return {
                        ...updateOperation,
                        modelField: csiModelField,
                        field
                    };
                }
                case 'unset':
                    return {
                        ...updateOperation,
                        modelField: csiModelField
                    };
                case 'insert': {
                    if (modelField.type !== 'list' || csiModelField.type !== 'list') {
                        throw new Error('Invalid operation. Insert operations can be performed on list fields only.');
                    }
                    const item = (await convertOperationField({
                        operationField: updateOperation.item,
                        fieldPath: [csiModel.name, ...updateOperation.fieldPath],
                        modelField: modelField.items,
                        csiModelField: csiModelField.items,
                        locale,
                        modelMap,
                        csiModelMap,
                        contentSourceId,
                        contentSourceDataById: this.contentSourceDataById,
                        assetSources: this.stackbitConfig?.assetSources ?? [],
                        createDocument: this.getCreateDocumentThunk({ user }),
                        userLogger: this.userLogger
                    })) as CSITypes.UpdateOperationListFieldItem;
                    return {
                        ...updateOperation,
                        modelField: csiModelField,
                        item
                    };
                }
                case 'remove':
                    if (csiModelField.type !== 'list') {
                        throw new Error('Invalid operation. Remove operations can be performed on list fields only.');
                    }
                    return {
                        ...updateOperation,
                        modelField: csiModelField
                    };
                case 'reorder':
                    if (csiModelField.type !== 'list') {
                        throw new Error('Invalid operation. Reorder operations can be performed on list fields only.');
                    }
                    return {
                        ...updateOperation,
                        modelField: csiModelField
                    };
            }
        });

        await this.updateDocumentHooked({
            updateDocumentOptions: {
                document: csiDocument,
                modelMap: csiModelMap,
                userContext,
                operations
            },
            contentSourceData: contentSourceData,
            user: user
        });

        return { srcDocumentId: srcDocumentId };
    }

    async duplicateDocument({
        srcType,
        srcProjectId,
        srcDocumentId,
        object,
        locale,
        user
    }: {
        srcType: string;
        srcProjectId: string;
        srcDocumentId: string;
        object?: Record<string, any>;
        locale?: string;
        user?: ContentStoreTypes.User;
    }): Promise<{ srcDocumentId: string }> {
        this.logger.debug('duplicateDocument', { srcType, srcProjectId, srcDocumentId, locale });
        logDuplicateDocument({ userLogger: this.userLogger, srcType, srcProjectId, srcDocumentId, locale });

        const contentSourceId = getContentSourceId(srcType, srcProjectId);
        const contentSourceData = this.getContentSourceDataByIdOrThrow(contentSourceId);
        const document = contentSourceData.documentMap[srcDocumentId];
        if (!document) {
            throw new Error(`Document not found: '${srcDocumentId}' (Source: '${contentSourceData.id}'.)`);
        }
        const model = contentSourceData.modelMap[document.srcModelName];
        const csiModel = contentSourceData.csiModelMap[document.srcModelName];

        if (!model || !csiModel) {
            throw new Error(`Model not found: '${document.srcModelName}' (source: ${contentSourceId})`);
        }

        const resolvedLocale = locale ?? contentSourceData.defaultLocaleCode;

        let extendedObject = mergeObjectWithDocument({
            object,
            document,
            locale: resolvedLocale,
            contentSourceId,
            contentSourceDataById: this.contentSourceDataById,
            referenceBehavior: this.stackbitConfig?.presetReferenceBehavior,
            duplicatableModels: this.stackbitConfig?.duplicatableModels,
            nonDuplicatableModels: this.stackbitConfig?.nonDuplicatableModels
        });

        if (this.stackbitConfig?.onContentCreate) {
            extendedObject = await this.stackbitConfig.onContentCreate({
                object: extendedObject ?? {},
                locale,
                model: {
                    srcType: contentSourceData.srcType,
                    srcProjectId: contentSourceData.srcProjectId,
                    ...csiModel
                },
                ...createConfigDelegate({
                    contentSourceDataById: this.contentSourceDataById,
                    logger: this.userLogger
                })
            });
        }

        const result = await createDocumentRecursively({
            object: extendedObject,
            locale: resolvedLocale,
            userLogger: this.userLogger,
            modelName: model.name,
            contentSourceId,
            contentSourceDataById: this.contentSourceDataById,
            assetSources: this.stackbitConfig?.assetSources ?? [],
            createDocument: this.getCreateDocumentThunk({ user })
        });

        this.logger.debug('duplicated document', { srcType, srcProjectId, srcDocumentId, newDocumentId: result.documentId, modelName: model.name });

        return { srcDocumentId: result.documentId };
    }

    private getCreateDocumentThunk({
        defaultLocaleDocumentId,
        user
    }: {
        defaultLocaleDocumentId?: string;
        user?: ContentStoreTypes.User;
    }): CreateDocumentThunk {
        return getCreateDocumentThunk({
            stackbitConfig: this.stackbitConfig,
            getContentSourceDataById: () => this.contentSourceDataById,
            logger: this.userLogger,
            defaultLocaleDocumentId: defaultLocaleDocumentId,
            user: user
        });
    }

    private updateDocumentHooked(options: {
        updateDocumentOptions: Parameters<BackCompatContentSourceInterface['updateDocument']>[0];
        contentSourceData: ContentSourceData;
        user?: ContentStoreTypes.User;
    }) {
        return updateDocumentHooked({
            actionOptions: options.updateDocumentOptions,
            stackbitConfig: this.stackbitConfig,
            contentSourceData: options.contentSourceData,
            getContentSourceDataById: () => this.contentSourceDataById,
            user: options.user,
            logger: this.userLogger
        });
    }

    async uploadAssets({
        srcType,
        srcProjectId,
        assets,
        locale,
        user
    }: {
        srcType: string;
        srcProjectId: string;
        assets: ContentStoreTypes.UploadAssetData[];
        locale?: string;
        user?: ContentStoreTypes.User;
    }): Promise<ContentStoreTypes.APIAsset[]> {
        this.logger.debug('uploadAssets');
        logUploadAssets({ userLogger: this.userLogger, srcType, srcProjectId, assets, locale });

        const contentSourceId = getContentSourceId(srcType, srcProjectId);
        const contentSourceData = this.getContentSourceDataByIdOrThrow(contentSourceId);
        const sourceAssets: CSITypes.Asset[] = [];
        const userContext = getUserContextForSrcType(srcType, user);

        locale = locale ?? contentSourceData.defaultLocaleCode;

        for (const asset of assets) {
            let base64 = undefined;
            if (asset.data) {
                const matchResult = asset.data.match(/;base64,([\s\S]+)$/);
                if (matchResult) {
                    base64 = matchResult[1];
                }
            }
            const sourceAsset = await contentSourceData.instance.uploadAsset({
                url: asset.url,
                base64: base64,
                fileName: asset.metadata.name,
                mimeType: asset.metadata.type,
                locale: locale,
                userContext: userContext
            });
            sourceAssets.push(sourceAsset);
        }
        const storeAssets = mapCSIAssetsToStoreAssets({
            csiAssets: sourceAssets,
            contentSourceInstance: contentSourceData.instance,
            defaultLocaleCode: contentSourceData.defaultLocaleCode
        });
        return mapStoreAssetsToAPIAssets(storeAssets, this.staticAssetsPublicPath, locale);
    }

    async deleteDocument({
        srcType,
        srcProjectId,
        srcDocumentId,
        user
    }: {
        srcType: string;
        srcProjectId: string;
        srcDocumentId: string;
        user?: ContentStoreTypes.User;
    }) {
        this.logger.debug('deleteDocument');
        logDeleteDocument({ userLogger: this.userLogger, srcType, srcProjectId, srcDocumentId });

        const userContext = getUserContextForSrcType(srcType, user);
        const contentSourceId = getContentSourceId(srcType, srcProjectId);
        const contentSourceData = this.getContentSourceDataByIdOrThrow(contentSourceId);
        const csiDocument = contentSourceData.csiDocumentMap[srcDocumentId];
        if (!csiDocument) {
            throw new Error(`Document not found: '${srcDocumentId}' (Source: '${contentSourceData.id}'.)`);
        }
        await deleteDocumentHooked({
            actionOptions: { document: csiDocument, userContext },
            stackbitConfig: this.stackbitConfig,
            contentSourceData: contentSourceData,
            getContentSourceDataById: () => this.contentSourceDataById,
            user: user,
            logger: this.userLogger
        });
    }

    getScheduledActions(): CSITypes.ScheduledActionWithSource[] {
        const scheduledActions = _.reduce(
            this.contentSourceDataById,
            (result: CSITypes.ScheduledActionWithSource[], contentSourceData) => {
                return result.concat(
                    contentSourceData.scheduledActions.map((scheduledAction) => ({
                        ...scheduledAction,
                        srcType: contentSourceData.srcType,
                        srcProjectId: contentSourceData.srcProjectId
                    }))
                );
            },
            []
        );
        return scheduledActions;
    }

    async updateScheduledAction({
        srcType,
        srcProjectId,
        scheduledActionId,
        documentIds,
        name,
        executeAt,
        user
    }: {
        srcType: string;
        srcProjectId: string;
        scheduledActionId: string;
        name?: string;
        documentIds?: string[];
        executeAt?: string;
        user?: ContentStoreTypes.User;
    }): Promise<{ updatedScheduledActionId: string }> {
        const userContext = getUserContextForSrcType(srcType, user);
        const contentSourceId = getContentSourceId(srcType, srcProjectId);
        const contentSourceData = this.getContentSourceDataByIdOrThrow(contentSourceId);
        this.logger.debug('updateScheduledAction', { srcType, srcProjectId, scheduledActionId });

        if (!contentSourceData.instance.updateScheduledAction) {
            this.logger.error('Trying to call updateScheduledAction, but it is not implemented', { srcType, srcProjectId, scheduledActionId });
            throw new Error('Content source plugin missing required method: updateScheduledAction');
        }
        return contentSourceData.instance.updateScheduledAction({ scheduledActionId, documentIds, name, executeAt, userContext });
    }

    async cancelScheduledAction({
        srcType,
        srcProjectId,
        scheduledActionId,
        user
    }: {
        srcType: string;
        srcProjectId: string;
        scheduledActionId: string;
        user?: ContentStoreTypes.User;
    }): Promise<{ cancelledScheduledActionId: string }> {
        const userContext = getUserContextForSrcType(srcType, user);
        const contentSourceId = getContentSourceId(srcType, srcProjectId);
        const contentSourceData = this.getContentSourceDataByIdOrThrow(contentSourceId);
        this.logger.debug('cancelScheduledAction', { srcType, srcProjectId, scheduledActionId });

        if (!contentSourceData.instance.cancelScheduledAction) {
            this.logger.error('Trying to call cancelScheduledAction, but it is not implemented', { srcType, srcProjectId, scheduledActionId });
            throw new Error('Content source plugin missing required method: cancelScheduledAction');
        }
        return contentSourceData.instance.cancelScheduledAction({ scheduledActionId, userContext });
    }

    async createScheduledAction({
        srcType,
        srcProjectId,
        documentIds,
        name,
        action,
        executeAt,
        user
    }: {
        srcType: string;
        srcProjectId: string;
        documentIds: string[];
        name: string;
        action: CSITypes.ScheduledActionActionType;
        executeAt: string;
        user?: ContentStoreTypes.User;
    }): Promise<{ newScheduledActionId: string }> {
        const userContext = getUserContextForSrcType(srcType, user);
        const contentSourceId = getContentSourceId(srcType, srcProjectId);
        const contentSourceData = this.getContentSourceDataByIdOrThrow(contentSourceId);
        this.logger.debug('createScheduledAction', { srcType, srcProjectId, documentIds, name, action, executeAt });

        if (!contentSourceData.instance.createScheduledAction) {
            this.logger.error('Trying to call createScheduledAction, but it is not implemented', {
                srcType,
                srcProjectId,
                documentIds,
                name,
                action,
                executeAt
            });
            throw new Error('Content source plugin missing required method: createScheduledAction');
        }

        return contentSourceData.instance.createScheduledAction({ documentIds, name, action, executeAt, userContext });
    }

    async validateDocuments({
        objects,
        locale,
        user
    }: {
        objects: { srcType: string; srcProjectId: string; srcObjectId: string }[];
        locale?: string;
        user?: ContentStoreTypes.User;
    }): Promise<{ errors: ContentStoreTypes.ValidationError[] }> {
        this.logger.debug('validateDocuments');

        const objectsBySourceId = _.groupBy(objects, (object) => getContentSourceId(object.srcType, object.srcProjectId));
        let errors: ContentStoreTypes.ValidationError[] = [];
        for (const [contentSourceId, contentSourceObjects] of Object.entries(objectsBySourceId)) {
            const contentSourceData = this.getContentSourceDataByIdOrThrow(contentSourceId);
            locale = locale ?? contentSourceData.defaultLocaleCode;
            const { documents, assets } = getCSIDocumentsAndAssetsFromContentSourceDataByIds(contentSourceData, contentSourceObjects);
            const userContext = getUserContextForSrcType(contentSourceData.srcType, user);
            const internalValidationErrors = internalValidateContent(documents, assets, contentSourceData, locale);
            const validationResult = await contentSourceData.instance.validateDocuments({ documents, assets, locale, userContext });
            errors = errors.concat(
                internalValidationErrors,
                validationResult.errors.map((validationError) => ({
                    message: validationError.message,
                    srcType: contentSourceData.srcType,
                    srcProjectId: contentSourceData.srcProjectId,
                    srcObjectType: validationError.objectType,
                    srcObjectId: validationError.objectId,
                    fieldPath: validationError.fieldPath,
                    isUniqueValidation: validationError.isUniqueValidation
                }))
            );
        }

        return { errors };

        /* validate for multiple sources
        const objectsBySourceId = _.groupBy(objects, (document) => getContentSourceId(document.srcType, document.srcProjectId));
        const contentSourceIds = Object.keys(objectsBySourceId);
        return reducePromise(
            contentSourceIds,
            async (result: ContentStoreTypes.ValidationError[], contentSourceId) => {
                const documents = documentsBySourceId[contentSourceId]!;
                const contentSourceData = this.getContentSourceDataByIdOrThrow(contentSourceId);
                const validationErrors = await contentSourceData.instance.validateDocuments({ documentIds: documents.map((document) => document.srcObjectId) });
                return result.concat(validationErrors);
            },
            []
        );
         */
    }

    async searchDocuments(data: {
        query?: string;
        filter?: SearchFilter;
        models: Array<{
            srcProjectId: string;
            srcType: string;
            modelName: string;
        }>;
        locale?: string;
    }): Promise<{
        total: number;
        items: ContentStoreTypes.Document[];
    }> {
        this.logger.debug('searchDocuments');
        const locale = data.locale;
        const objectsBySourceId = _.groupBy(data.models, (object) => getContentSourceId(object.srcType, object.srcProjectId));
        const contentSourceIds = Object.keys(objectsBySourceId);
        const documents: ContentStoreTypes.Document[] = [];
        const schema: Record<string, Record<string, Record<string, Model>>> = {};
        const scheduledActions: ScheduledAction[] = [];
        const defaultLocales: Record<string, string> = {};

        contentSourceIds.forEach((contentSourceId) => {
            const contentSourceData = this.getContentSourceDataByIdOrThrow(contentSourceId);

            _.set(schema, [contentSourceData.srcType, contentSourceData.srcProjectId], contentSourceData.modelMap);

            const contentSourceDocuments = _.isEmpty(locale)
                ? contentSourceData.documents
                : contentSourceData.documents.filter((document) => !document.locale || document.locale === locale);
            const contentSourceScheduledActions = contentSourceData.scheduledActions;
            const filteredDocuments = contentSourceDocuments.filter((document) => document.srcModelName !== StackbitPresetModelName);
            documents.push(...filteredDocuments);
            scheduledActions.push(...contentSourceScheduledActions);
            if (contentSourceData.defaultLocaleCode) {
                defaultLocales[contentSourceId] = contentSourceData.defaultLocaleCode;
            }
        });

        return searchDocuments({
            ...data,
            documents,
            schema,
            locale,
            scheduledActions,
            defaultLocales
        });
    }

    async publishDocuments({ objects, user }: { objects: { srcType: string; srcProjectId: string; srcObjectId: string }[]; user?: ContentStoreTypes.User }) {
        this.logger.debug('publishDocuments');
        logPublishDocuments({ userLogger: this.userLogger, objects });

        const objectsBySourceId = _.groupBy(objects, (object) => getContentSourceId(object.srcType, object.srcProjectId));
        for (const [contentSourceId, contentSourceObjects] of Object.entries(objectsBySourceId)) {
            const contentSourceData = this.getContentSourceDataByIdOrThrow(contentSourceId);
            const userContext = getUserContextForSrcType(contentSourceData.srcType, user);
            const { documents, assets } = getCSIDocumentsAndAssetsFromContentSourceDataByIds(contentSourceData, contentSourceObjects);
            await publishDocumentHooked({
                actionOptions: { documents, assets, userContext },
                stackbitConfig: this.stackbitConfig,
                contentSourceData: contentSourceData,
                getContentSourceDataById: () => this.contentSourceDataById,
                user: user,
                logger: this.userLogger
            });
        }
    }

    private getContentSourceDataByIdOrThrow(contentSourceId: string): ContentSourceData {
        return getContentSourceDataByIdOrThrow(contentSourceId, this.contentSourceDataById);
    }

    onWebhook({ srcType, srcProjectId, data, headers }: { srcType: string; srcProjectId: string; data: unknown; headers: Record<string, string> }) {
        const contentSourceId = getContentSourceId(srcType, srcProjectId);
        const contentSourceData = this.getContentSourceDataByIdOrThrow(contentSourceId);
        return contentSourceData.instance.onWebhook?.({ data, headers });
    }

    getWebhookUrl(contentSourceType: string, projectId: string) {
        if (!this.webhookUrl) {
            return undefined;
        }
        return `${this.webhookUrl}/${encodeURIComponent(contentSourceType)}/${encodeURIComponent(projectId)}`;
    }
}

function internalValidateContent(
    documents: CSITypes.Document[],
    assets: CSITypes.Asset[],
    contentSourceData: ContentSourceData,
    locale?: string
): ContentStoreTypes.ValidationError[] {
    const errors: ContentStoreTypes.ValidationError[] = [];
    _.forEach(documents, (document) => {
        _.forEach(document.fields, (documentField, fieldName) => {
            const localizedField = getLocalizedFieldForLocale(documentField, locale);
            if (localizedField) {
                errors.push(...validateDocumentFields(document, localizedField, [fieldName], contentSourceData, locale));
            }
        });
    });
    return errors;
}

function validateDocumentFields(
    document: CSITypes.Document,
    documentField: CSITypes.DocumentFieldNonLocalized,
    fieldPath: (string | number)[],
    contentSourceData: ContentSourceData,
    locale?: string
): ContentStoreTypes.ValidationError[] {
    const errors: ContentStoreTypes.ValidationError[] = [];

    if (documentField.type === 'object') {
        _.forEach(documentField.fields, (documentField, fieldName) => {
            const localizedField = getLocalizedFieldForLocale(documentField, locale);
            if (localizedField) {
                errors.push(...validateDocumentFields(document, localizedField, fieldPath.concat(fieldName), contentSourceData, locale));
            }
        });
    } else if (documentField.type === 'model') {
        _.forEach(documentField.fields, (documentField, fieldName) => {
            const localizedField = getLocalizedFieldForLocale(documentField, locale);
            if (localizedField) {
                errors.push(...validateDocumentFields(document, localizedField, fieldPath.concat(fieldName), contentSourceData, locale));
            }
        });
    } else if (documentField.type === 'reference') {
        const objRef = documentField.refType === 'asset' ? contentSourceData.assetMap[documentField.refId] : contentSourceData.documentMap[documentField.refId];
        if (!objRef) {
            errors.push({
                fieldPath,
                srcType: contentSourceData.srcType,
                srcProjectId: contentSourceData.srcProjectId,
                srcObjectType: documentField.refType,
                srcObjectId: document.id,
                message: `Can't find referenced ${documentField.refType}: ${documentField.refId}`
            });
        }
    } else if (documentField.type === 'list') {
        _.forEach(documentField.items, (documentField, i) => {
            errors.push(...validateDocumentFields(document, documentField, fieldPath.concat(i), contentSourceData, locale));
        });
    }

    return errors;
}
