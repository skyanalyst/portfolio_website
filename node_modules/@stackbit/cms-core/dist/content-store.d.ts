import * as CSITypes from '@stackbit/types';
import { UserCommandSpawner, CommandRunner } from '@stackbit/types';
import { Config, ImageModel, Model, Preset, PresetMap } from '@stackbit/sdk';
import * as ContentStoreTypes from './types';
import { SearchFilter } from './types';
import { GitService } from './services';
export declare type HandleConfigAssets = <T extends Model>({ models, presets }: {
    models?: T[];
    presets?: PresetMap;
}) => Promise<{
    models: T[];
    presets: PresetMap;
}>;
export interface ContentSourceOptions {
    logger: CSITypes.Logger;
    userLogger: CSITypes.Logger;
    localDev: boolean;
    staticAssetsPublicPath: string;
    webhookUrl?: string;
    runCommand: CommandRunner;
    git: GitService;
    userCommandSpawner?: UserCommandSpawner;
    onSchemaChangeCallback: () => void;
    onContentChangeCallback: (contentChanges: ContentStoreTypes.ContentChangeResult) => void;
    onActionStateChangeCallback: (actionResult: ContentStoreTypes.CustomActionStateChange) => void;
    handleConfigAssets: HandleConfigAssets;
    devAppRestartNeeded?: () => void;
}
export declare const StackbitPresetModelName = "stackbitPreset";
export declare class ContentStore {
    private readonly logger;
    private readonly userLogger;
    private readonly userCommandSpawner?;
    private readonly localDev;
    private readonly staticAssetsPublicPath;
    private readonly webhookUrl?;
    private readonly runCommand;
    private readonly git;
    private readonly onSchemaChangeCallback;
    private readonly onContentChangeCallback;
    private readonly onActionStateChangeCallback;
    private readonly handleConfigAssets;
    private readonly devAppRestartNeeded?;
    private contentSources;
    private contentSourceDataById;
    private presetsContentSource?;
    private contentUpdatesWatchTimer;
    private stackbitConfig;
    private yamlModels;
    private configModels;
    private modelExtensions;
    private presets;
    private siteMapEntryGroups;
    private processingContentSourcesPromise;
    private contentStoreEventQueue;
    private treeViews;
    private customActionRunStateMap;
    private contentEngine?;
    constructor(options: ContentSourceOptions);
    init({ stackbitConfig }: {
        stackbitConfig: Config | null;
    }): Promise<void>;
    onStackbitConfigChange({ stackbitConfig }: {
        stackbitConfig: Config | null;
    }): Promise<void>;
    /**
     * This method is called when contentUpdatesWatchTimer receives timeout.
     * This happens when the user is not using the Stackbit app for some time
     * but container is not hibernated.
     * It then notifies all content sources to stop watching for content
     * changes, which in turn stops polling CMS for content changes and helps
     * reducing the CMS API usage.
     */
    private handleTimerTimeout;
    /**
     * This method is called when user interacts with Stackbit application.
     * It is used to reset contentUpdatesWatchTimer. When the timer is over
     * all content sources are notified to stop watching for content updates.
     */
    keepAlive(): Promise<void>;
    stop(): void;
    onFilesChange(updatedFiles: string[]): Promise<void>;
    private loadYamlModels;
    private mergeConfigModels;
    private loadPresetsFromConfig;
    private loadPresetsFromContentSource;
    /**
     * If any content sources implement the `getContentEngineConfig` method then this function gets all
     * of these plugin definitions and creates the content engine.
     */
    private createContentEngineIfNeeded;
    /**
     * This function reloads the data of the specified content-sources, while
     * reusing the cached data of the rest of the content-sources, then processes
     * the content sources' data by merging it with models defined in
     * stackbit.config.js and yaml-model files.
     *
     * This function is wrapped by `deferWhileRunning` ensuring this method is
     * invoked one at a time.
     *
     * @param {boolean} init Flag specifying if the content sources need to be initialized or reset.
     *   The content sources need to be (re-)initialized only when the stackbit.config.js was reloaded.
     *   In all other cases content sources can be reset.
     * @param {string[] | undefined} contentSourceIds Array of content source IDs to reload.
     *   If not provided or set to "undefined", will reload all content sources.
     *   If set to empty array will not reload any content sources and only process their cached data.
     * @private
     */
    private loadContentSourcesAndProcessData;
    private processContentStoreEvents;
    private pushContentSourceEvent;
    private clearEventsForContentSourceId;
    private loadContentSourceData;
    private onContentChange;
    private processData;
    getContentSourceMeta(): {
        srcType: string;
        srcProjectId: string;
        srcVersion: string;
        csiVersion: string;
        supportsScheduledActions: boolean;
    }[];
    getAssetSources(): CSITypes.DistributiveOmit<CSITypes.AssetSource, 'transform' | 'preview'>[];
    getModels(): Record<string, Record<string, Record<string, Model | ImageModel>>>;
    getLocales(): ContentStoreTypes.ContentStoreLocale[];
    getGlobalActions({ pageUrl, user, locale, currentPageDocument }: {
        pageUrl?: string;
        user?: ContentStoreTypes.User;
        locale?: string;
        currentPageDocument?: ContentStoreTypes.APICustomActionDocumentSpecifier;
    }): Promise<(ContentStoreTypes.APICustomActionGlobal | ContentStoreTypes.APICustomActionBulk)[]>;
    getCustomActions(getActionRequest: ContentStoreTypes.APIGetCustomActionRequest): Promise<ContentStoreTypes.APICustomAction[]>;
    runCustomAction(runActionRequest: ContentStoreTypes.APIRunCustomActionRequest): Promise<void>;
    getPresets({ locale }?: {
        locale?: string;
    }): Record<string, any>;
    getContentSourceEnvironment({ srcProjectId, srcType }: {
        srcProjectId: string;
        srcType: string;
    }): string;
    usesContentSourcePresets(): boolean;
    hasAccess({ srcType, srcProjectId, user }: {
        srcType?: string;
        srcProjectId?: string;
        user?: ContentStoreTypes.User;
    }): Promise<ContentStoreTypes.HasAccessResult>;
    hasChanges({ srcType, srcProjectId, documents }: {
        srcType?: string;
        srcProjectId?: string;
        documents?: {
            srcType: string;
            srcProjectId: string;
            srcObjectId: string;
        }[];
    }): {
        hasChanges: boolean;
        changedObjects: {
            srcType: string;
            srcProjectId: string;
            srcObjectId: string;
        }[];
    };
    getSiteMapEntries({ locale }?: {
        locale?: string;
    }): CSITypes.SiteMapEntry[];
    getTreeViews(): CSITypes.TreeViewNode[];
    getSiteMapEntriesForDocument({ srcType, srcProjectId, srcDocumentId, locale }: {
        srcType: string;
        srcProjectId: string;
        srcDocumentId: string;
        locale?: string;
    }): CSITypes.SiteMapEntry[];
    getDocument({ srcDocumentId, srcProjectId, srcType }: {
        srcDocumentId: string;
        srcProjectId: string;
        srcType: string;
    }): ContentStoreTypes.Document | undefined;
    getDocumentsByContext({ context, srcProjectId, srcType }: {
        context: any;
        srcProjectId?: string;
        srcType: string;
    }): ContentStoreTypes.Document[];
    getDocuments({ locale }?: {
        locale?: string;
    }): ContentStoreTypes.Document[];
    getAsset({ srcAssetId, srcProjectId, srcType }: {
        srcAssetId: string;
        srcProjectId: string;
        srcType: string;
    }): ContentStoreTypes.Asset | undefined;
    getAssets({ locale }: {
        locale?: string;
    }): ContentStoreTypes.Asset[];
    getLocalizedApiObjects({ locale, objectIds }: {
        locale?: string;
        objectIds?: string[];
    }): ContentStoreTypes.APIObject[];
    getApiAssets({ srcType, srcProjectId, pageSize, pageNum, searchQuery }?: {
        srcType?: string;
        srcProjectId?: string;
        pageSize?: number;
        pageNum?: number;
        searchQuery?: string;
    }): {
        assets: ContentStoreTypes.APIAsset[];
        pageSize: number;
        pageNum: number;
        totalPages: number;
    };
    createAndLinkDocument({ srcType, srcProjectId, srcDocumentId, fieldPath, modelName, refSrcType, refProjectId, object, index, locale, user }: {
        srcType: string;
        srcProjectId: string;
        srcDocumentId: string;
        fieldPath: (string | number)[];
        modelName?: string;
        refSrcType?: string;
        refProjectId?: string;
        object?: Record<string, any>;
        index?: number;
        locale?: string;
        user?: ContentStoreTypes.User;
    }): Promise<{
        srcDocumentId: string;
        createdDocumentId: string;
    }>;
    createPreset({ preset, thumbnailAsset, user }: {
        preset: Preset;
        thumbnailAsset: ContentStoreTypes.UploadAssetData;
        user?: ContentStoreTypes.User;
    }): Promise<{
        srcDocumentId: string;
    }>;
    deletePreset({ presetId, user }: {
        presetId: string;
        user?: ContentStoreTypes.User;
    }): Promise<void>;
    uploadAndLinkAsset({ srcType, srcProjectId, srcDocumentId, fieldPath, asset, index, locale, user }: {
        srcType: string;
        srcProjectId: string;
        srcDocumentId: string;
        fieldPath: (string | number)[];
        asset: ContentStoreTypes.UploadAssetData;
        index?: number;
        locale?: string;
        user?: ContentStoreTypes.User;
    }): Promise<{
        srcDocumentId: string;
    }>;
    createDocument({ srcType, srcProjectId, modelName, object, locale, defaultLocaleDocumentId, user }: {
        srcType: string;
        srcProjectId: string;
        modelName: string;
        object?: Record<string, any>;
        locale?: string;
        defaultLocaleDocumentId?: string;
        user?: ContentStoreTypes.User;
    }): Promise<{
        srcDocumentId: string;
    }>;
    updateDocument({ srcType, srcProjectId, srcDocumentId, updateOperations, user }: {
        srcType: string;
        srcProjectId: string;
        srcDocumentId: string;
        updateOperations: ContentStoreTypes.UpdateOperation[];
        user?: ContentStoreTypes.User;
    }): Promise<{
        srcDocumentId: string;
    }>;
    duplicateDocument({ srcType, srcProjectId, srcDocumentId, object, locale, user }: {
        srcType: string;
        srcProjectId: string;
        srcDocumentId: string;
        object?: Record<string, any>;
        locale?: string;
        user?: ContentStoreTypes.User;
    }): Promise<{
        srcDocumentId: string;
    }>;
    private getCreateDocumentThunk;
    private updateDocumentHooked;
    uploadAssets({ srcType, srcProjectId, assets, locale, user }: {
        srcType: string;
        srcProjectId: string;
        assets: ContentStoreTypes.UploadAssetData[];
        locale?: string;
        user?: ContentStoreTypes.User;
    }): Promise<ContentStoreTypes.APIAsset[]>;
    deleteDocument({ srcType, srcProjectId, srcDocumentId, user }: {
        srcType: string;
        srcProjectId: string;
        srcDocumentId: string;
        user?: ContentStoreTypes.User;
    }): Promise<void>;
    getScheduledActions(): CSITypes.ScheduledActionWithSource[];
    updateScheduledAction({ srcType, srcProjectId, scheduledActionId, documentIds, name, executeAt, user }: {
        srcType: string;
        srcProjectId: string;
        scheduledActionId: string;
        name?: string;
        documentIds?: string[];
        executeAt?: string;
        user?: ContentStoreTypes.User;
    }): Promise<{
        updatedScheduledActionId: string;
    }>;
    cancelScheduledAction({ srcType, srcProjectId, scheduledActionId, user }: {
        srcType: string;
        srcProjectId: string;
        scheduledActionId: string;
        user?: ContentStoreTypes.User;
    }): Promise<{
        cancelledScheduledActionId: string;
    }>;
    createScheduledAction({ srcType, srcProjectId, documentIds, name, action, executeAt, user }: {
        srcType: string;
        srcProjectId: string;
        documentIds: string[];
        name: string;
        action: CSITypes.ScheduledActionActionType;
        executeAt: string;
        user?: ContentStoreTypes.User;
    }): Promise<{
        newScheduledActionId: string;
    }>;
    validateDocuments({ objects, locale, user }: {
        objects: {
            srcType: string;
            srcProjectId: string;
            srcObjectId: string;
        }[];
        locale?: string;
        user?: ContentStoreTypes.User;
    }): Promise<{
        errors: ContentStoreTypes.ValidationError[];
    }>;
    searchDocuments(data: {
        query?: string;
        filter?: SearchFilter;
        models: Array<{
            srcProjectId: string;
            srcType: string;
            modelName: string;
        }>;
        locale?: string;
    }): Promise<{
        total: number;
        items: ContentStoreTypes.Document[];
    }>;
    publishDocuments({ objects, user }: {
        objects: {
            srcType: string;
            srcProjectId: string;
            srcObjectId: string;
        }[];
        user?: ContentStoreTypes.User;
    }): Promise<void>;
    private getContentSourceDataByIdOrThrow;
    onWebhook({ srcType, srcProjectId, data, headers }: {
        srcType: string;
        srcProjectId: string;
        data: unknown;
        headers: Record<string, string>;
    }): void | undefined;
    getWebhookUrl(contentSourceType: string, projectId: string): string | undefined;
}
//# sourceMappingURL=content-store.d.ts.map