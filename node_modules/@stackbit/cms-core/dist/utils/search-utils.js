"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isListFieldMatches = exports.isDateFieldMatches = exports.isBooleanFieldMatches = exports.searchDocuments = void 0;
const lodash_1 = __importDefault(require("lodash"));
const utils_1 = require("@stackbit/utils");
const content_store_utils_1 = require("../content-store-utils");
const meta_fields_filters_1 = require("./meta-fields-filters");
const searchDocuments = (data) => {
    var _a, _b;
    const query = (_a = data.query) === null || _a === void 0 ? void 0 : _a.toLowerCase();
    const { documents, schema } = data;
    let allDocuments = 0;
    const activeScheduledActionsByDocumentId = groupScheduledActionsByDocumentId((_b = data.scheduledActions) !== null && _b !== void 0 ? _b : []);
    const matchedDocuments = documents.filter((document) => {
        var _a, _b, _c;
        const contentSourceId = (0, content_store_utils_1.getContentSourceId)(document.srcType, document.srcProjectId);
        const isIncludedModel = lodash_1.default.find(data.models, {
            srcType: document.srcType,
            srcProjectId: document.srcProjectId,
            modelName: document.srcModelName
        });
        if (!isIncludedModel) {
            return false;
        }
        allDocuments += 1;
        if (query) {
            const matches = isDocumentMatchesPattern(document, query, (_a = data.locale) !== null && _a !== void 0 ? _a : (_b = data.defaultLocales) === null || _b === void 0 ? void 0 : _b[contentSourceId]);
            if (!matches) {
                return false;
            }
        }
        if ((_c = data.filter) === null || _c === void 0 ? void 0 : _c.and) {
            // only 'and' supported for now; later we can add e.g. 'or'
            const matches = data.filter.and.every((filter) => {
                var _a, _b, _c, _d;
                const filterFieldResult = getFieldForFilter({
                    document,
                    filter,
                    context: {
                        activeScheduledActionsByDocumentId,
                        locale: (_a = data.locale) !== null && _a !== void 0 ? _a : (_b = data.defaultLocales) === null || _b === void 0 ? void 0 : _b[contentSourceId],
                        schema
                    }
                });
                if ('result' in filterFieldResult) {
                    return filterFieldResult.result;
                }
                const { field, model } = filterFieldResult;
                return isFieldMatchesFilter({ field, filter, document, model, locale: (_c = data.locale) !== null && _c !== void 0 ? _c : (_d = data.defaultLocales) === null || _d === void 0 ? void 0 : _d[contentSourceId] });
            });
            if (!matches) {
                return false;
            }
        }
        return true;
    });
    return {
        items: matchedDocuments,
        total: allDocuments
    };
};
exports.searchDocuments = searchDocuments;
const isDocumentMatchesPattern = (document, query, locale) => {
    if (document.srcModelLabel.toLowerCase().includes(query)) {
        return true;
    }
    return lodash_1.default.some(document.fields, (field) => {
        var _a;
        let value;
        switch (field.type) {
            case 'string':
            case 'slug':
            case 'url':
            case 'text':
            case 'markdown':
            case 'html':
                value = (_a = (0, content_store_utils_1.getDocumentFieldForLocale)(field, locale)) === null || _a === void 0 ? void 0 : _a.value;
                break;
        }
        if (value) {
            return value === null || value === void 0 ? void 0 : value.toString().toLowerCase().includes(query);
        }
        return false;
    });
};
const getFieldForFilter = ({ document, filter, context }) => {
    var _a, _b, _c;
    if (filter.isMeta) {
        const filterField = filter.field;
        if (!(filterField in meta_fields_filters_1.META_FIELDS)) {
            throw new Error(`Unsupported meta field ${filter.field}`);
        }
        return meta_fields_filters_1.META_FIELDS[filterField]({ filter, document, context });
    }
    else {
        const documentField = document.fields[filter.field];
        if (!documentField) {
            throw new Error(`Field not found ${filter.field}`);
        }
        const model = (_c = (_b = (_a = context.schema) === null || _a === void 0 ? void 0 : _a[document.srcType]) === null || _b === void 0 ? void 0 : _b[document.srcProjectId]) === null || _c === void 0 ? void 0 : _c[document.srcModelName];
        return { field: documentField, model };
    }
};
const isFieldMatchesFilter = ({ document, field, filter, locale, model }) => {
    switch (field === null || field === void 0 ? void 0 : field.type) {
        case 'string':
        case 'slug':
        case 'url':
        case 'text':
        case 'markdown':
        case 'html':
            return isStringFieldMatches({ field, filter, locale });
        case 'number':
            return isNumberFieldMatches({ field, filter, locale });
        case 'boolean':
            return (0, exports.isBooleanFieldMatches)({ field, filter, locale });
        case 'date':
        case 'datetime':
            return (0, exports.isDateFieldMatches)({ field, filter, locale });
        case 'enum':
            return isEnumFieldMatches({ field, filter, locale });
        case 'list': {
            if (!model || model.type === 'image') {
                throw new Error(`Can't find model for the ${filter.field}`);
            }
            return (0, exports.isListFieldMatches)({ field, filter, model, locale, document });
        }
        case 'cross-reference':
        case 'reference':
            return isReferenceFieldMatches({ field, filter, locale, document });
        default:
            throw new Error(`Unsupported filter for field ${filter.field} with type ${field === null || field === void 0 ? void 0 : field.type}`);
    }
};
const isStringFieldMatches = ({ field, filter, locale }) => {
    var _a, _b, _c;
    // ignoring case
    const fieldValue = (_b = (_a = (0, content_store_utils_1.getDocumentFieldForLocale)(field, locale)) === null || _a === void 0 ? void 0 : _a.value) === null || _b === void 0 ? void 0 : _b.toLowerCase();
    switch (filter.operator) {
        case 'is-undefined':
            return fieldValue === undefined;
        case 'is-not-undefined':
            return fieldValue !== undefined;
        case 'eq': // ===
        case 'neq': // !==
        case 'includes':
        case 'not-includes': {
            if (typeof filter.value !== 'string') {
                throw new Error(`Filter value should be string for field ${filter.field}`);
            }
            const filterValue = (_c = filter.value) === null || _c === void 0 ? void 0 : _c.toString().toLowerCase();
            switch (filter.operator) {
                case 'eq':
                    return fieldValue === filterValue;
                case 'neq':
                    return fieldValue !== filterValue;
                case 'includes':
                    return Boolean(fieldValue === null || fieldValue === void 0 ? void 0 : fieldValue.includes(filterValue));
                case 'not-includes':
                    return !(fieldValue === null || fieldValue === void 0 ? void 0 : fieldValue.includes(filterValue));
            }
        }
    }
    throw new Error(`Not supported operator ${filter.operator} for field ${filter.field}`);
};
const isNumberFieldMatches = ({ field, filter, locale }) => {
    var _a;
    const fieldValue = (_a = (0, content_store_utils_1.getDocumentFieldForLocale)(field, locale)) === null || _a === void 0 ? void 0 : _a.value;
    switch (filter.operator) {
        case 'is-undefined':
            return fieldValue === undefined;
        case 'is-not-undefined':
            return fieldValue !== undefined;
        case 'eq': // ===
        case 'neq': // !==
        case 'gte': // >=
        case 'lte': {
            // <=
            if (typeof filter.value !== 'number') {
                throw new Error(`Filter value should be number for field ${filter.field}`);
            }
            switch (filter.operator) {
                case 'eq':
                    return fieldValue === filter.value;
                case 'neq':
                    return fieldValue !== filter.value;
                case 'gte':
                    return Boolean(fieldValue && fieldValue >= filter.value);
                case 'lte':
                    return Boolean(fieldValue && fieldValue <= filter.value);
            }
            break;
        }
        case 'between': {
            // ..N..
            if (typeof filter.startValue !== 'number' || typeof filter.endValue !== 'number') {
                throw new Error(`Filter startValue and endValue should be number for field ${filter.field}`);
            }
            return Boolean(fieldValue && fieldValue >= filter.startValue && fieldValue <= filter.endValue);
        }
    }
    throw new Error(`Not supported operator ${filter.operator} for field ${filter.field}`);
};
const isBooleanFieldMatches = ({ field, filter, locale }) => {
    var _a;
    const fieldValue = (_a = (0, content_store_utils_1.getDocumentFieldForLocale)(field, locale)) === null || _a === void 0 ? void 0 : _a.value;
    switch (filter.operator) {
        case 'is-undefined':
            return fieldValue === undefined;
        case 'is-not-undefined':
            return fieldValue !== undefined;
        case 'eq':
        case 'neq': {
            if (typeof filter.value !== 'boolean') {
                throw new Error(`Filter value should be boolean for field ${filter.field}`);
            }
            switch (filter.operator) {
                case 'eq':
                    return fieldValue === filter.value;
                case 'neq':
                    return fieldValue !== filter.value;
            }
        }
    }
    throw new Error(`Not supported operator ${filter.operator} for field ${filter.field}`);
};
exports.isBooleanFieldMatches = isBooleanFieldMatches;
const parseDateValue = (value) => {
    let dateValue;
    if (value === null || value === void 0 ? void 0 : value.endsWith('Z')) {
        dateValue = new Date(value);
    }
    else if (value === null || value === void 0 ? void 0 : value.match(/\d{1,4}-\d{1,2}-\d{1,2}$/)) {
        // try to parse it as a date
        // when use '-' in js dates constructor, it make the date with TZ offset
        // 2022-10-04 => 03 Oct 2022 20:00 GMT-4
        // 2022/10/04 => 04 Oct 2022 00:00 GMT-4
        dateValue = new Date(value.replace(/-/g, '/'));
    }
    if (dateValue && !Number.isNaN(dateValue)) {
        return dateValue;
    }
};
const isDateFieldMatches = ({ field, filter, locale }) => {
    var _a, _b, _c, _d, _e;
    const origValue = (_a = (0, content_store_utils_1.getDocumentFieldForLocale)(field, locale)) === null || _a === void 0 ? void 0 : _a.value;
    const fieldValue = parseDateValue(origValue);
    if (origValue && !fieldValue) {
        throw new Error(`Can't parse value ${origValue} for field ${filter.field}`);
    }
    switch (filter.operator) {
        case 'is-undefined':
            return fieldValue === undefined;
        case 'is-not-undefined':
            return fieldValue !== undefined;
        case 'eq': // ===
        case 'neq': // !==
        case 'gte': // >=
        case 'lte': {
            // <=
            if (typeof filter.value !== 'string') {
                throw new Error(`Filter value should be in string date format for field ${filter.field}`);
            }
            const filterValue = parseDateValue(filter.value);
            if (!filterValue) {
                throw new Error(`Filter value should be in date format for field ${filter.field}`);
            }
            switch (filter.operator) {
                case 'eq':
                case 'neq': {
                    // check if day is the same
                    const result = (fieldValue === null || fieldValue === void 0 ? void 0 : fieldValue.getFullYear()) === filterValue.getFullYear() &&
                        (fieldValue === null || fieldValue === void 0 ? void 0 : fieldValue.getMonth()) === filterValue.getMonth() &&
                        (fieldValue === null || fieldValue === void 0 ? void 0 : fieldValue.getDate()) === filterValue.getDate();
                    return filter.operator === 'eq' ? result : !result;
                }
                case 'gte':
                    return ((_b = fieldValue === null || fieldValue === void 0 ? void 0 : fieldValue.getTime()) !== null && _b !== void 0 ? _b : 0) >= filterValue.getTime();
                case 'lte':
                    return ((_c = fieldValue === null || fieldValue === void 0 ? void 0 : fieldValue.getTime()) !== null && _c !== void 0 ? _c : 0) <= filterValue.getTime();
            }
            break;
        }
        case 'between': {
            // ..N..
            if (typeof filter.startValue !== 'string' || typeof filter.endValue !== 'string') {
                throw new Error(`Filter startValue and endValue should be in string date format for field ${filter.field}`);
            }
            const startDate = parseDateValue(filter.startValue);
            const endDate = parseDateValue(filter.endValue);
            if (!startDate || !endDate) {
                throw new Error(`Filter startValue and endValue should be in date format for field ${filter.field}`);
            }
            return ((_d = fieldValue === null || fieldValue === void 0 ? void 0 : fieldValue.getTime()) !== null && _d !== void 0 ? _d : 0) >= startDate.getTime() && ((_e = fieldValue === null || fieldValue === void 0 ? void 0 : fieldValue.getTime()) !== null && _e !== void 0 ? _e : 0) <= endDate.getTime();
        }
    }
    throw new Error(`Not supported operator ${filter.operator} for field ${filter.field}`);
};
exports.isDateFieldMatches = isDateFieldMatches;
const isEnumFieldMatches = ({ field, filter, locale }) => {
    var _a;
    const fieldValue = (_a = (0, content_store_utils_1.getDocumentFieldForLocale)(field, locale)) === null || _a === void 0 ? void 0 : _a.value;
    switch (filter.operator) {
        case 'is-undefined':
            return fieldValue === undefined;
        case 'is-not-undefined':
            return fieldValue !== undefined;
        case 'in': // one of
        case 'nin': {
            // none of
            const filterValues = filter.values;
            switch (filter.operator) {
                case 'in':
                    return filterValues.includes(fieldValue);
                case 'nin':
                    return !filterValues.includes(fieldValue);
            }
        }
    }
    throw new Error(`Not supported operator ${filter.operator} for field ${filter.field}`);
};
const isListFieldMatches = ({ field, filter, locale, model, document }) => {
    var _a, _b, _c, _d, _e;
    const fieldModel = (_a = model === null || model === void 0 ? void 0 : model.fields) === null || _a === void 0 ? void 0 : _a.find((field) => field.name === filter.field);
    const listItemsType = (fieldModel === null || fieldModel === void 0 ? void 0 : fieldModel.type) === 'list' && ((_b = fieldModel.items) === null || _b === void 0 ? void 0 : _b.type);
    const isPrimitiveList = listItemsType &&
        ['string', 'slug', 'url', 'text', 'markdown', 'boolean', 'date', 'datetime', 'number', 'enum', 'reference', 'cross-reference'].includes(listItemsType);
    if (!isPrimitiveList) {
        throw new Error(`Unsupported filter for list field ${filter.field} with children ${listItemsType}`);
    }
    const localizedField = (0, content_store_utils_1.getDocumentFieldForLocale)(field, locale);
    switch (filter.operator) {
        case 'is-empty':
            return ((_c = localizedField === null || localizedField === void 0 ? void 0 : localizedField.items.length) !== null && _c !== void 0 ? _c : 0) === 0;
        case 'is-not-empty':
            return ((_d = localizedField === null || localizedField === void 0 ? void 0 : localizedField.items.length) !== null && _d !== void 0 ? _d : 0) > 0;
        case 'in': // one of
        case 'nin': // none of
        case 'all': {
            // all of
            const filterValues = filter.values;
            switch (filter.operator) {
                case 'in':
                case 'nin': {
                    const result = (_e = localizedField === null || localizedField === void 0 ? void 0 : localizedField.items.some((item) => {
                        switch (item.type) {
                            case 'string':
                            case 'slug':
                            case 'url':
                            case 'text':
                            case 'markdown':
                            case 'boolean':
                            case 'date':
                            case 'datetime':
                            case 'number':
                            case 'enum': {
                                return filterValues.includes(item.value);
                            }
                            case 'reference':
                            case 'cross-reference': {
                                if (item.isUnset) {
                                    // include unset items for nin operator and not for in
                                    return false;
                                }
                                let { srcType, srcProjectId } = document;
                                if (item.type === 'cross-reference') {
                                    srcType = item.refSrcType;
                                    srcProjectId = item.refProjectId;
                                }
                                return filterValues.find((filterObject) => filterObject.srcType === srcType &&
                                    filterObject.srcProjectId === srcProjectId &&
                                    filterObject.srcDocumentId === item.refId);
                            }
                            default:
                                return false;
                        }
                    })) !== null && _e !== void 0 ? _e : false;
                    return filter.operator === 'in' ? result : !result;
                }
                case 'all':
                    return filterValues.every((filterValue) => {
                        return localizedField === null || localizedField === void 0 ? void 0 : localizedField.items.find((item) => {
                            switch (item.type) {
                                case 'string':
                                case 'slug':
                                case 'url':
                                case 'text':
                                case 'markdown':
                                case 'boolean':
                                case 'date':
                                case 'datetime':
                                case 'number':
                                case 'enum': {
                                    return item.value === filterValue;
                                }
                                case 'reference':
                                case 'cross-reference': {
                                    if (item.isUnset) {
                                        return false;
                                    }
                                    let { srcType, srcProjectId } = document;
                                    if ((item === null || item === void 0 ? void 0 : item.type) === 'cross-reference') {
                                        srcType = item.refSrcType;
                                        srcProjectId = item.refProjectId;
                                    }
                                    return (filterValue.srcType === srcType && filterValue.srcProjectId === srcProjectId && filterValue.srcDocumentId === item.refId);
                                }
                                default:
                                    return false;
                            }
                        });
                    });
            }
        }
    }
    throw new Error(`Not supported operator ${filter.operator} for field ${filter.field}`);
};
exports.isListFieldMatches = isListFieldMatches;
const isReferenceFieldMatches = ({ field, filter, document, locale }) => {
    var _a;
    // ignoring case
    const fieldValue = (0, content_store_utils_1.getDocumentFieldForLocale)(field, locale);
    switch (filter.operator) {
        case 'is-undefined':
            return (_a = fieldValue === null || fieldValue === void 0 ? void 0 : fieldValue.isUnset) !== null && _a !== void 0 ? _a : false;
        case 'is-not-undefined':
            return !(fieldValue === null || fieldValue === void 0 ? void 0 : fieldValue.isUnset);
        case 'in':
        case 'nin': {
            if (typeof filter.values[0] !== 'object' || filter.values[0] instanceof Date) {
                throw new Error(`Filter value should be array of objects for field ${filter.field}`);
            }
            const filterValues = filter.values;
            if (fieldValue === null || fieldValue === void 0 ? void 0 : fieldValue.isUnset) {
                // include unset items in nin operator
                return filter.operator === 'nin';
            }
            let { srcType, srcProjectId } = document;
            if ((fieldValue === null || fieldValue === void 0 ? void 0 : fieldValue.type) === 'cross-reference') {
                srcType = fieldValue.refSrcType;
                srcProjectId = fieldValue.refProjectId;
            }
            switch (filter.operator) {
                case 'in':
                    return filterValues.some((filterValue) => filterValue.srcType === srcType && filterValue.srcProjectId === srcProjectId && filterValue.srcDocumentId === (fieldValue === null || fieldValue === void 0 ? void 0 : fieldValue.refId));
                case 'nin':
                    return filterValues.every((filterValue) => filterValue.srcType !== srcType || filterValue.srcProjectId !== srcProjectId || filterValue.srcDocumentId !== (fieldValue === null || fieldValue === void 0 ? void 0 : fieldValue.refId));
            }
        }
    }
    throw new Error(`Not supported operator ${filter.operator} for field ${filter.field}`);
};
function groupScheduledActionsByDocumentId(scheduledActions) {
    return lodash_1.default.reduce(scheduledActions === null || scheduledActions === void 0 ? void 0 : scheduledActions.filter((scheduledAction) => scheduledAction.state === 'scheduled'), (res, scheduledAction) => {
        for (const docId of scheduledAction.documentIds) {
            (0, utils_1.append)(res, [docId], scheduledAction);
        }
        return res;
    }, {});
}
//# sourceMappingURL=search-utils.js.map