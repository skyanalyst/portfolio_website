import { Config } from '@stackbit/sdk';
import * as StackbitTypes from '@stackbit/types';
import * as ContentStoreTypes from '../types';
import type { ContentSourceData } from '../types';
import type { BackCompatContentSourceInterface } from './backward-compatibility';
export interface DocumentHookBaseOptions {
    stackbitConfig: Config | null;
    contentSourceData: ContentSourceData;
    getContentSourceDataById: () => Record<string, ContentStoreTypes.ContentSourceData>;
    user?: ContentStoreTypes.User;
    logger: StackbitTypes.Logger;
}
export interface DocumentHookOptions<Action extends 'createDocument' | 'updateDocument' | 'deleteDocument' | 'publishDocuments'> extends DocumentHookBaseOptions {
    actionOptions: Parameters<BackCompatContentSourceInterface[Action]>[0];
}
declare type ReturnTypeOfCSIMethod<Method extends keyof StackbitTypes.ContentSourceInterface> = ReturnType<NonNullable<StackbitTypes.ContentSourceInterface[Method]>>;
export declare function createDocumentHooked(options: DocumentHookOptions<'createDocument'>): ReturnTypeOfCSIMethod<'createDocument'>;
export declare function updateDocumentHooked(options: DocumentHookOptions<'updateDocument'>): ReturnTypeOfCSIMethod<'updateDocument'>;
export declare function deleteDocumentHooked(options: DocumentHookOptions<'deleteDocument'>): ReturnTypeOfCSIMethod<'deleteDocument'>;
export declare function publishDocumentHooked(options: DocumentHookOptions<'publishDocuments'>): ReturnTypeOfCSIMethod<'publishDocuments'>;
export declare function getContentSourceActionsForSourceThunk({ getContentSourceDataById, logger, user, stackbitConfig }: {
    getContentSourceDataById: () => Record<string, ContentStoreTypes.ContentSourceData>;
    logger: StackbitTypes.Logger;
    user?: ContentStoreTypes.User;
    stackbitConfig: Config | null;
}): (options: {
    srcType: string;
    srcProjectId?: string;
}) => StackbitTypes.ContentSourceActions | undefined;
export {};
//# sourceMappingURL=document-hooks.d.ts.map