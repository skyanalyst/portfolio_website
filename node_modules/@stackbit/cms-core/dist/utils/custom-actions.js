"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.runCustomAction = exports.resolveCustomActionsById = exports.getFieldActions = exports.getObjectFieldActionsThunk = exports.getObjectModelActionsThunk = exports.getDocumentActionsThunk = exports.getGlobalAndBulkAPIActions = exports.stripModelActions = void 0;
const lodash_1 = __importDefault(require("lodash"));
const sdk_1 = require("@stackbit/sdk");
const utils_1 = require("@stackbit/utils");
const config_delegate_1 = require("./config-delegate");
const document_hooks_1 = require("./document-hooks");
const store_to_csi_docs_converter_1 = require("./store-to-csi-docs-converter");
const field_path_utils_1 = require("./field-path-utils");
const content_store_utils_1 = require("../content-store-utils");
/**
 * Removes "run" and "state" functions from actions of models, nested objects and fields.
 * Sets "needsResolving" flag to let client know if the action needs additional resolving.
 * @param {StackbitTypes.ModelMap} modelMap
 */
function stripModelActions({ modelMap }) {
    return lodash_1.default.mapValues(modelMap, (model) => {
        if ('actions' in model) {
            const { actions, ...restModel } = model;
            model = restModel;
        }
        model = (0, sdk_1.mapModelFieldsRecursively)(model, (field) => {
            if ('actions' in field && Array.isArray(field.actions)) {
                const { actions, ...restField } = field;
                field = restField;
            }
            return field;
        });
        return model;
    });
}
exports.stripModelActions = stripModelActions;
async function getGlobalAndBulkAPIActions({ stackbitConfig, customActionRunStateMap, contentSourceDataById, userLogger, pageUrl, user, locale, currentPageDocument }) {
    if (!stackbitConfig || !Array.isArray(stackbitConfig.actions)) {
        return [];
    }
    const configDelegate = (0, config_delegate_1.createConfigDelegate)({
        contentSourceDataById: contentSourceDataById,
        logger: userLogger
    });
    return (0, utils_1.mapPromise)(stackbitConfig.actions, async (action) => {
        var _a, _b;
        const actionId = globalActionId(action);
        const actionRunState = customActionRunStateMap[actionId];
        let state;
        if (actionRunState === null || actionRunState === void 0 ? void 0 : actionRunState.runningHandler) {
            state = 'running';
        }
        else if (action.state) {
            const pageDocument = getCSIDocumentWithSourceFromDocumentSpec(currentPageDocument, configDelegate);
            state = await action.state({
                actionId: actionId,
                currentLocale: locale,
                currentUser: user ? { name: user.name, email: user.email } : undefined,
                currentPageUrl: pageUrl,
                currentPageDocument: pageDocument,
                ...configDelegate
            });
        }
        else {
            state = (_a = actionRunState === null || actionRunState === void 0 ? void 0 : actionRunState.lastResultState) !== null && _a !== void 0 ? _a : 'enabled';
        }
        return (0, utils_1.omitByNil)({
            type: action.type,
            actionId: actionId,
            name: action.name,
            label: (_b = action.label) !== null && _b !== void 0 ? _b : lodash_1.default.startCase(action.name),
            icon: action.icon,
            state: state,
            inputFields: action.inputFields
        });
    });
}
exports.getGlobalAndBulkAPIActions = getGlobalAndBulkAPIActions;
function getDocumentActionsThunk({ csiDocument, model, srcType, srcProjectId, customActionRunStateMap }) {
    if (!('actions' in model) || !Array.isArray(model.actions)) {
        return () => undefined;
    }
    const extendedDocumentActions = model.actions.map((action) => {
        var _a;
        const documentSpec = {
            srcType: srcType,
            srcProjectId: srcProjectId,
            srcDocumentId: csiDocument.id
        };
        return {
            // if configuration is updated, the new action properties will override the stored action properties
            ...action,
            type: 'document',
            actionId: documentActionId({ ...documentSpec, actionName: action.name }),
            label: (_a = action.label) !== null && _a !== void 0 ? _a : lodash_1.default.startCase(action.name),
            documentSpec: documentSpec
        };
    });
    return () => extendedDocumentActions.map((extendedAction) => {
        return (0, utils_1.omitByNil)({
            type: 'document',
            actionId: extendedAction.actionId,
            name: extendedAction.name,
            label: extendedAction.label,
            icon: extendedAction.icon,
            inputFields: extendedAction.inputFields,
            ...getAPIActionState(extendedAction, customActionRunStateMap)
        });
    });
}
exports.getDocumentActionsThunk = getDocumentActionsThunk;
function getObjectModelActionsThunk({ model, csiParentDocument, srcType, srcProjectId, customActionRunStateMap, fieldPath }) {
    if (!('actions' in model) || !Array.isArray(model.actions)) {
        return () => undefined;
    }
    const extendedObjectModelActions = model.actions.map((action) => {
        var _a;
        const documentSpec = {
            srcType: srcType,
            srcProjectId: srcProjectId,
            srcDocumentId: csiParentDocument.id
        };
        return {
            // if configuration is updated, the new action properties will override the stored action properties
            ...action,
            type: 'objectModel',
            actionId: fieldPathActionId({ ...documentSpec, fieldPath, actionName: action.name }),
            label: (_a = action.label) !== null && _a !== void 0 ? _a : lodash_1.default.startCase(action.name),
            documentSpec: documentSpec,
            fieldPath
        };
    });
    return () => extendedObjectModelActions.map((extendedAction) => {
        return (0, utils_1.omitByNil)({
            type: 'object',
            actionId: extendedAction.actionId,
            name: extendedAction.name,
            label: extendedAction.label,
            icon: extendedAction.icon,
            inputFields: extendedAction.inputFields,
            ...getAPIActionState(extendedAction, customActionRunStateMap)
        });
    });
}
exports.getObjectModelActionsThunk = getObjectModelActionsThunk;
function getObjectFieldActionsThunk({ modelField, csiParentDocument, srcType, srcProjectId, customActionRunStateMap, fieldPath }) {
    if (!('actions' in modelField) || !Array.isArray(modelField.actions)) {
        return () => undefined;
    }
    const objectFieldActions = modelField.actions.filter((action) => action.type === 'object');
    const extendedObjectFieldActions = objectFieldActions.map((action) => {
        var _a;
        const documentSpec = {
            srcType: srcType,
            srcProjectId: srcProjectId,
            srcDocumentId: csiParentDocument.id
        };
        return {
            // if configuration is updated, the new action properties will override the stored action properties
            ...action,
            type: 'objectField',
            actionId: fieldPathActionId({ ...documentSpec, fieldPath, actionName: action.name }),
            label: (_a = action.label) !== null && _a !== void 0 ? _a : lodash_1.default.startCase(action.name),
            documentSpec: documentSpec,
            fieldPath
        };
    });
    return () => extendedObjectFieldActions.map((extendedAction) => {
        return (0, utils_1.omitByNil)({
            type: 'object',
            actionId: extendedAction.actionId,
            name: extendedAction.name,
            label: extendedAction.label,
            icon: extendedAction.icon,
            inputFields: extendedAction.inputFields,
            ...getAPIActionState(extendedAction, customActionRunStateMap)
        });
    });
}
exports.getObjectFieldActionsThunk = getObjectFieldActionsThunk;
function getFieldActions({ modelField, csiParentDocument, srcType, srcProjectId, customActionRunStateMap, fieldPath }) {
    if (!('actions' in modelField) || !Array.isArray(modelField.actions)) {
        return undefined;
    }
    const fieldActions = modelField.actions.filter((action) => action.type !== 'object');
    const extendedFieldActions = fieldActions.map((action) => {
        var _a;
        const documentSpec = {
            srcType: srcType,
            srcProjectId: srcProjectId,
            srcDocumentId: csiParentDocument.id
        };
        return {
            // if configuration is updated, the new action properties will override the stored action properties
            ...action,
            type: 'field',
            actionId: fieldPathActionId({ ...documentSpec, fieldPath, actionName: action.name }),
            label: (_a = action.label) !== null && _a !== void 0 ? _a : lodash_1.default.startCase(action.name),
            documentSpec: documentSpec,
            fieldPath
        };
    });
    return extendedFieldActions.map((extendedAction) => {
        return (0, utils_1.omitByNil)({
            type: 'field',
            actionId: extendedAction.actionId,
            name: extendedAction.name,
            label: extendedAction.label,
            icon: extendedAction.icon,
            inputFields: extendedAction.inputFields,
            ...getAPIActionState(extendedAction, customActionRunStateMap)
        });
    });
}
exports.getFieldActions = getFieldActions;
async function resolveCustomActionsById({ getActionRequest, customActionRunStateMap, contentSourceDataById, stackbitConfig, userLogger }) {
    var _a;
    const result = [];
    const { customActionIds, locale, user, pageUrl, currentPageDocument } = getActionRequest;
    const configDelegate = (0, config_delegate_1.createConfigDelegate)({
        contentSourceDataById,
        logger: userLogger
    });
    for (const actionId of customActionIds) {
        const extendedAction = findCustomActionById({
            actionId,
            customActionRunStateMap,
            contentSourceDataById,
            stackbitConfig
        });
        if (!extendedAction) {
            userLogger.debug(`custom action with id: '${actionId}' was not found`);
            continue;
        }
        try {
            let state;
            if (extendedAction.runningHandler) {
                state = 'running';
            }
            else if (extendedAction.state) {
                const pageDocument = getCSIDocumentWithSourceFromDocumentSpec(currentPageDocument, configDelegate);
                const commonStateOptions = {
                    actionId: actionId,
                    currentLocale: locale,
                    currentUser: user
                        ? {
                            name: user.name,
                            email: user.email
                        }
                        : undefined,
                    currentPageUrl: pageUrl,
                    currentPageDocument: pageDocument,
                    ...configDelegate
                };
                if (extendedAction.type === 'global' || extendedAction.type === 'bulk') {
                    state = await extendedAction.state(commonStateOptions);
                }
                else if (extendedAction.type === 'document') {
                    const { document, model } = getCSIDocumentAndModelWithSourceFromDocumentSpec({
                        documentSpec: extendedAction.documentSpec,
                        contentSourceDataById
                    });
                    state = await extendedAction.state({
                        ...commonStateOptions,
                        document: document,
                        model: model
                    });
                }
                else if (extendedAction.type === 'objectModel') {
                    const stateObjectParams = getHandlerParamsForObjectModelAction({
                        extendedAction,
                        contentSourceDataById
                    });
                    state = await extendedAction.state({
                        ...commonStateOptions,
                        ...stateObjectParams
                    });
                }
                else if (extendedAction.type === 'objectField') {
                    const stateObjectParams = getHandlerParamsForObjectFieldAction({
                        extendedAction,
                        contentSourceDataById
                    });
                    state = await extendedAction.state({
                        ...commonStateOptions,
                        ...stateObjectParams
                    });
                }
                else if (extendedAction.type === 'field') {
                    const stateFieldParams = getHandlerParamsForFieldAction({
                        extendedAction,
                        contentSourceDataById
                    });
                    state = await extendedAction.state({
                        ...commonStateOptions,
                        ...stateFieldParams
                    });
                }
                else {
                    const _exhaustiveCheck = extendedAction;
                    continue;
                }
            }
            else {
                state = (_a = extendedAction.lastResultState) !== null && _a !== void 0 ? _a : 'enabled';
            }
            result.push((0, utils_1.omitByNil)({
                actionId: actionId,
                type: storeActionTypeToAPIActionType(extendedAction.type),
                name: extendedAction.name,
                label: extendedAction.label,
                icon: extendedAction.icon,
                state: state,
                inputFields: extendedAction.inputFields
            }));
        }
        catch (error) {
            userLogger.warn(`getCustomActionsById: error resolving custom action, id: '${actionId}', error: ${error.message}`);
        }
    }
    return result;
}
exports.resolveCustomActionsById = resolveCustomActionsById;
function runCustomAction({ runActionRequest, customActionRunStateMap, contentSourceDataById, stackbitConfig, userLogger }) {
    var _a, _b;
    const extendedAction = findCustomActionById({
        actionId: runActionRequest.actionId,
        customActionRunStateMap,
        contentSourceDataById,
        stackbitConfig
    });
    if (!extendedAction) {
        throw new Error(`Error running action: action not found, action name: '${runActionRequest.actionName}' action ID: '${runActionRequest.actionId}'.`);
    }
    const prevResultState = extendedAction.lastResultState;
    if (extendedAction.lastResultState && extendedAction.lastResultState !== 'enabled') {
        throw new Error(`Error running action: action is not enabled, action name: '${runActionRequest.actionName}' action ID: '${runActionRequest.actionId}'.`);
    }
    try {
        const actionLogger = userLogger.createLogger({ label: `action:${extendedAction.name}` });
        const configDelegate = (0, config_delegate_1.createConfigDelegate)({ contentSourceDataById: contentSourceDataById, logger: actionLogger });
        const currentPageDocument = getCSIDocumentWithSourceFromDocumentSpec(runActionRequest.currentPageDocument, configDelegate);
        customActionRunStateMap[runActionRequest.actionId] = {
            runningHandler: true,
            lastResultState: 'running'
        };
        const commonRunOptions = {
            actionId: extendedAction.actionId,
            inputData: runActionRequest.inputData,
            currentLocale: runActionRequest.locale,
            currentUser: runActionRequest.user,
            currentPageUrl: runActionRequest.pageUrl,
            currentPageDocument: currentPageDocument,
            getContentSourceActionsForSource: (0, document_hooks_1.getContentSourceActionsForSourceThunk)({
                getContentSourceDataById: () => contentSourceDataById,
                logger: userLogger,
                user: runActionRequest.user,
                stackbitConfig: stackbitConfig
            }),
            getUserContextForContentSourceType: (0, content_store_utils_1.getUserContextForSrcTypeThunk)(runActionRequest.user),
            ...configDelegate
        };
        let promise;
        if (extendedAction.type === 'global') {
            promise = extendedAction.run(commonRunOptions);
        }
        else if (extendedAction.type === 'bulk') {
            const documents = runActionRequest.documents.map((documentSpec) => {
                const { document } = getCSIDocumentAndModelWithSourceFromDocumentSpec({
                    documentSpec,
                    contentSourceDataById
                });
                return document;
            });
            promise = extendedAction.run({
                ...commonRunOptions,
                documents
            });
        }
        else if (extendedAction.type === 'document') {
            const { document, model } = getCSIDocumentAndModelWithSourceFromDocumentSpec({
                documentSpec: extendedAction.documentSpec,
                contentSourceDataById
            });
            promise = extendedAction.run({
                ...commonRunOptions,
                document,
                model,
                contentSourceActions: commonRunOptions.getContentSourceActionsForSource({
                    srcType: extendedAction.documentSpec.srcType,
                    srcProjectId: extendedAction.documentSpec.srcProjectId
                })
            });
        }
        else if (extendedAction.type === 'objectModel') {
            const handlerObjectParams = getHandlerParamsForObjectModelAction({
                extendedAction,
                contentSourceDataById
            });
            promise = extendedAction.run({
                ...commonRunOptions,
                ...handlerObjectParams,
                contentSourceActions: commonRunOptions.getContentSourceActionsForSource({
                    srcType: extendedAction.documentSpec.srcType,
                    srcProjectId: extendedAction.documentSpec.srcProjectId
                })
            });
        }
        else if (extendedAction.type === 'objectField') {
            const handlerObjectParams = getHandlerParamsForObjectFieldAction({
                extendedAction,
                contentSourceDataById
            });
            promise = extendedAction.run({
                ...commonRunOptions,
                ...handlerObjectParams,
                contentSourceActions: commonRunOptions.getContentSourceActionsForSource({
                    srcType: extendedAction.documentSpec.srcType,
                    srcProjectId: extendedAction.documentSpec.srcProjectId
                })
            });
        }
        else if (extendedAction.type === 'field') {
            const handlerFieldParams = getHandlerParamsForFieldAction({ extendedAction, contentSourceDataById });
            promise = extendedAction.run({
                ...commonRunOptions,
                ...handlerFieldParams,
                contentSourceActions: commonRunOptions.getContentSourceActionsForSource({
                    srcType: extendedAction.documentSpec.srcType,
                    srcProjectId: extendedAction.documentSpec.srcProjectId
                })
            });
        }
        else {
            throw new Error(`action type ${extendedAction.type} not supported`);
        }
        return promise
            .then((actionResult) => {
            var _a;
            customActionRunStateMap[runActionRequest.actionId] = {
                runningHandler: false,
                lastResultState: actionResult === null || actionResult === void 0 ? void 0 : actionResult.state
            };
            userLogger.debug(`Action completed: ${extendedAction.actionId}`);
            return Promise.resolve((0, utils_1.omitByNil)({
                actionId: extendedAction.actionId,
                actionName: extendedAction.name,
                actionType: storeActionTypeToAPIActionType(extendedAction.type),
                // TODO: resolve the state if state function is defined
                state: (_a = actionResult === null || actionResult === void 0 ? void 0 : actionResult.state) !== null && _a !== void 0 ? _a : 'enabled',
                success: actionResult === null || actionResult === void 0 ? void 0 : actionResult.success,
                error: actionResult === null || actionResult === void 0 ? void 0 : actionResult.error
            }));
        })
            .catch((error) => {
            customActionRunStateMap[runActionRequest.actionId] = {
                runningHandler: false,
                lastResultState: prevResultState
            };
            userLogger.debug(`Error running action: ${error.message}`);
            return Promise.resolve({
                actionId: extendedAction.actionId,
                actionName: extendedAction.name,
                actionType: storeActionTypeToAPIActionType(extendedAction.type),
                // TODO: resolve the state if state function is defined
                state: prevResultState !== null && prevResultState !== void 0 ? prevResultState : 'enabled',
                error: `Error running action: ${error.message}`
            });
        });
    }
    catch (error) {
        if (customActionRunStateMap[runActionRequest.actionId]) {
            customActionRunStateMap[runActionRequest.actionId] = {
                runningHandler: false,
                lastResultState: prevResultState
            };
        }
        userLogger.debug(`Error running action: ${error.message}`);
        return Promise.resolve({
            actionId: runActionRequest.actionId,
            actionName: (_a = extendedAction === null || extendedAction === void 0 ? void 0 : extendedAction.name) !== null && _a !== void 0 ? _a : runActionRequest.actionName,
            actionType: (_b = storeActionTypeToAPIActionType(extendedAction === null || extendedAction === void 0 ? void 0 : extendedAction.type)) !== null && _b !== void 0 ? _b : runActionRequest.actionType,
            // TODO: resolve the state if state function is defined
            state: prevResultState !== null && prevResultState !== void 0 ? prevResultState : 'enabled',
            error: `Error running action: ${error.message}`
        });
    }
}
exports.runCustomAction = runCustomAction;
function getCSIDocumentWithSourceFromDocumentSpec(documentSpec, configDelegate) {
    return documentSpec
        ? configDelegate.getDocumentById({
            id: documentSpec.srcDocumentId,
            srcType: documentSpec.srcType,
            srcProjectId: documentSpec.srcProjectId
        })
        : undefined;
}
function getAPIActionState(extendedAction, customActionRunStateMap) {
    var _a;
    const actionId = extendedAction.actionId;
    const actionRunState = customActionRunStateMap[actionId];
    let state;
    let needsResolving = false;
    if (actionRunState === null || actionRunState === void 0 ? void 0 : actionRunState.runningHandler) {
        state = 'running';
    }
    else if (extendedAction.state) {
        state = 'unknown';
        needsResolving = true;
    }
    else {
        state = (_a = actionRunState === null || actionRunState === void 0 ? void 0 : actionRunState.lastResultState) !== null && _a !== void 0 ? _a : 'enabled';
    }
    return { state, needsResolving };
}
function getHandlerParamsForObjectModelAction({ extendedAction, contentSourceDataById }) {
    const fieldActionCommonParams = getHandlerParamsForFieldAction({
        extendedAction,
        contentSourceDataById
    });
    if (!fieldActionCommonParams.documentField) {
        throw new Error(`object document field not found at field path: ${extendedAction.fieldPath.join('.')}`);
    }
    const documentField = fieldActionCommonParams.documentField;
    const documentSpec = extendedAction.documentSpec;
    const contentSourceData = (0, content_store_utils_1.getContentSourceDataByTypeAndProjectIdOrThrow)(documentSpec.srcType, documentSpec.srcProjectId, contentSourceDataById);
    const objectModel = contentSourceData.modelMap[documentField.modelName];
    if (!objectModel || objectModel.type !== 'object') {
        throw new Error(`object model '${documentField.modelName}' not found`);
    }
    return {
        ...fieldActionCommonParams,
        documentField,
        modelField: fieldActionCommonParams.modelField,
        objectModel: {
            ...objectModel,
            srcType: documentSpec.srcType,
            srcProjectId: documentSpec.srcProjectId
        }
    };
}
function getHandlerParamsForObjectFieldAction({ extendedAction, contentSourceDataById }) {
    const fieldActionCommonParams = getHandlerParamsForFieldAction({
        extendedAction,
        contentSourceDataById
    });
    if (!fieldActionCommonParams.documentField) {
        throw new Error(`object document field not found at field path: ${extendedAction.fieldPath.join('.')}`);
    }
    return {
        ...fieldActionCommonParams,
        documentField: fieldActionCommonParams.documentField,
        modelField: fieldActionCommonParams.modelField
    };
}
function getHandlerParamsForFieldAction({ extendedAction, contentSourceDataById }) {
    const documentSpec = extendedAction.documentSpec;
    const contentSourceData = (0, content_store_utils_1.getContentSourceDataByTypeAndProjectIdOrThrow)(documentSpec.srcType, documentSpec.srcProjectId, contentSourceDataById);
    const document = contentSourceData.documentMap[documentSpec.srcDocumentId];
    const csiDocument = contentSourceData.csiDocumentMap[documentSpec.srcDocumentId];
    if (!document || !csiDocument) {
        throw new Error(`document not found for srcType: ${documentSpec.srcType}, srcProjectId: ${documentSpec.srcProjectId}, srcDocumentId: ${documentSpec.srcDocumentId}`);
    }
    const model = contentSourceData.modelMap[document.srcModelName];
    if (!model) {
        throw new Error(`model '${document.srcModelName}' not found`);
    }
    const mappedCSIDocument = (0, store_to_csi_docs_converter_1.mapStoreDocumentToCSIDocumentWithSource)({ document, csiDocument });
    // the documentField should be localized because fieldPath includes locales
    const { modelField, documentField } = (0, field_path_utils_1.getModelAndDocumentFieldForLocalizedFieldPath)({
        document,
        fieldPath: extendedAction.fieldPath,
        modelMap: contentSourceData.modelMap
    });
    const csiDocumentField = (0, store_to_csi_docs_converter_1.mapStoreFieldToCSIField)(documentField);
    return {
        parentDocument: mappedCSIDocument,
        parentModel: {
            ...model,
            srcType: documentSpec.srcType,
            srcProjectId: documentSpec.srcProjectId
        },
        documentField: csiDocumentField,
        modelField: modelField,
        fieldPath: extendedAction.fieldPath
    };
}
function getCSIDocumentAndModelWithSourceFromDocumentSpec({ documentSpec, contentSourceDataById }) {
    const contentSourceData = (0, content_store_utils_1.getContentSourceDataByTypeAndProjectIdOrThrow)(documentSpec.srcType, documentSpec.srcProjectId, contentSourceDataById);
    const document = contentSourceData.documentMap[documentSpec.srcDocumentId];
    const csiDocument = contentSourceData.csiDocumentMap[documentSpec.srcDocumentId];
    if (!document || !csiDocument) {
        throw new Error(`document not found, srcType: ${documentSpec.srcType}, srcProjectId: ${documentSpec.srcProjectId}, srcDocumentId: ${documentSpec.srcDocumentId}`);
    }
    const mappedDocument = (0, store_to_csi_docs_converter_1.mapStoreDocumentToCSIDocumentWithSource)({
        document,
        csiDocument
    });
    const model = contentSourceData.modelMap[mappedDocument.modelName];
    if (!model) {
        throw new Error(`model '${mappedDocument.modelName}' not found`);
    }
    return {
        document: mappedDocument,
        model: {
            ...model,
            srcType: documentSpec.srcType,
            srcProjectId: documentSpec.srcProjectId
        }
    };
}
function storeActionTypeToAPIActionType(storeActionType) {
    if (storeActionType === 'objectModel' || storeActionType === 'objectField') {
        return 'object';
    }
    return storeActionType;
}
function findCustomActionById({ actionId, customActionRunStateMap, contentSourceDataById, stackbitConfig }) {
    var _a, _b, _c, _d, _e, _f;
    const actionRunState = customActionRunStateMap[actionId];
    if (isGlobalActionId(actionId)) {
        if (!stackbitConfig || !Array.isArray(stackbitConfig.actions)) {
            return undefined;
        }
        const actionName = getGlobalActionNameFromId(actionId);
        const action = stackbitConfig.actions.find((action) => action.name === actionName);
        if (!action) {
            return undefined;
        }
        return {
            ...action,
            actionId,
            label: (_a = action.label) !== null && _a !== void 0 ? _a : lodash_1.default.startCase(action.name),
            runningHandler: actionRunState === null || actionRunState === void 0 ? void 0 : actionRunState.runningHandler,
            lastResultState: actionRunState === null || actionRunState === void 0 ? void 0 : actionRunState.lastResultState
        };
    }
    const { srcType, srcProjectId, srcDocumentId, actionName, fieldPath } = (_b = parseActionId(actionId)) !== null && _b !== void 0 ? _b : {};
    if (!srcType || !srcProjectId || !srcDocumentId || !actionName) {
        return undefined;
    }
    const documentSpec = { srcType, srcProjectId, srcDocumentId };
    const contentSourceData = (0, content_store_utils_1.getContentSourceDataByTypeAndProjectIdOrThrow)(srcType, srcProjectId, contentSourceDataById);
    const document = contentSourceData.documentMap[srcDocumentId];
    if (!document) {
        return undefined;
    }
    const modelName = document.srcModelName;
    const model = contentSourceData.modelMap[modelName];
    // The model of a document is always 'page' or 'data',
    // this condition helps TS to infer the right type of model.actions
    if (!model || (model.type !== 'page' && model.type !== 'data')) {
        return undefined;
    }
    if (typeof fieldPath === 'undefined') {
        // fieldPath was not provided, therefore the model must be of type "page" or "data",
        // and the action type must be 'document'
        const action = (_c = model.actions) === null || _c === void 0 ? void 0 : _c.find((action) => action.name === actionName);
        if (!action) {
            return undefined;
        }
        return {
            // if configuration is updated, the new action properties will override the stored action properties
            ...action,
            type: 'document',
            actionId,
            label: (_d = action.label) !== null && _d !== void 0 ? _d : lodash_1.default.startCase(action.name),
            documentSpec,
            runningHandler: actionRunState === null || actionRunState === void 0 ? void 0 : actionRunState.runningHandler,
            lastResultState: actionRunState === null || actionRunState === void 0 ? void 0 : actionRunState.lastResultState
        };
    }
    else {
        const { modelField, documentField } = (0, field_path_utils_1.getModelAndDocumentFieldForLocalizedFieldPath)({
            document,
            fieldPath,
            modelMap: contentSourceData.modelMap
        });
        if ('actions' in modelField && Array.isArray(modelField.actions)) {
            const action = modelField.actions.find((action) => action.name === actionName);
            if (action) {
                return {
                    // if configuration is updated, the new action properties will override the stored action properties
                    ...action,
                    type: action.type === 'object' ? 'objectField' : 'field',
                    actionId,
                    label: (_e = action.label) !== null && _e !== void 0 ? _e : lodash_1.default.startCase(action.name),
                    documentSpec,
                    fieldPath,
                    runningHandler: actionRunState === null || actionRunState === void 0 ? void 0 : actionRunState.runningHandler,
                    lastResultState: actionRunState === null || actionRunState === void 0 ? void 0 : actionRunState.lastResultState
                };
            }
        }
        if (modelField.type === 'model') {
            if (documentField.type !== 'model' || documentField.localized || documentField.isUnset) {
                return undefined;
            }
            const modelName = documentField.srcModelName;
            const model = contentSourceData.modelMap[modelName];
            if (!model || model.type !== 'object') {
                return undefined;
            }
            if (!('actions' in model && Array.isArray(model.actions))) {
                return undefined;
            }
            // This is a nested model of type "object", so the action must be CustomActionObjectModel
            const action = model.actions.find((action) => action.name === actionName);
            if (!action) {
                return undefined;
            }
            return {
                // if configuration is updated, the new action properties will override the stored action properties
                ...action,
                type: 'objectModel',
                actionId,
                label: (_f = action.label) !== null && _f !== void 0 ? _f : lodash_1.default.startCase(action.name),
                documentSpec,
                fieldPath,
                runningHandler: actionRunState === null || actionRunState === void 0 ? void 0 : actionRunState.runningHandler,
                lastResultState: actionRunState === null || actionRunState === void 0 ? void 0 : actionRunState.lastResultState
            };
        }
    }
}
function globalActionId(action) {
    return `config.actions.${action.name}`;
}
function isGlobalActionId(actionId) {
    return actionId.startsWith('config.actions.');
}
function getGlobalActionNameFromId(actionId) {
    return actionId.substring('config.actions.'.length);
}
function documentActionId({ srcType, srcProjectId, srcDocumentId, actionName }) {
    return `${srcType}:${srcProjectId}:${srcDocumentId}:${actionName}`;
}
function fieldPathActionId({ srcType, srcProjectId, srcDocumentId, fieldPath, actionName }) {
    return `${srcType}:${srcProjectId}:${srcDocumentId}:${fieldPath.join('.')}:${actionName}`;
}
function parseActionId(actionId) {
    var _a;
    const parts = actionId.split(':');
    if (parts.length < 4 || parts.length > 5) {
        return undefined;
    }
    const srcType = parts[0];
    const srcProjectId = parts[1];
    const srcDocumentId = parts[2];
    let fieldPath;
    let actionName;
    if (parts.length === 5) {
        fieldPath = (_a = parts[3]) === null || _a === void 0 ? void 0 : _a.split('.');
        actionName = parts[4];
    }
    else {
        actionName = parts[3];
    }
    return {
        srcType,
        srcProjectId,
        srcDocumentId,
        actionName,
        fieldPath
    };
}
//# sourceMappingURL=custom-actions.js.map