"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getContentSourceActionsForSourceThunk = exports.publishDocumentHooked = exports.deleteDocumentHooked = exports.updateDocumentHooked = exports.createDocumentHooked = void 0;
const content_store_utils_1 = require("../content-store-utils");
const config_delegate_1 = require("./config-delegate");
async function createDocumentHooked(options) {
    var _a;
    // If no onDocumentCreate defined in the config, call the original content
    // source createDocument method with the provided actionOptions.
    if (!((_a = options.stackbitConfig) === null || _a === void 0 ? void 0 : _a.onDocumentCreate)) {
        return options.contentSourceData.instance.createDocument(options.actionOptions);
    }
    return options.stackbitConfig.onDocumentCreate({
        // Spread actionOptions to clone them shallowly to prevent accidental
        // property overrides within user methods.
        createDocumentOptions: { ...options.actionOptions },
        createDocument: async (actionOptions) => {
            var _a;
            if (!actionOptions) {
                actionOptions = options.actionOptions;
            }
            return options.contentSourceData.instance.createDocument({
                ...actionOptions,
                userContext: (_a = actionOptions.userContext) !== null && _a !== void 0 ? _a : options.actionOptions.userContext,
                modelMap: options.actionOptions.modelMap
            });
        },
        ...getDocumentHookOptions(options)
    });
}
exports.createDocumentHooked = createDocumentHooked;
async function updateDocumentHooked(options) {
    var _a;
    // If no onDocumentUpdate defined in the config, call the original content
    // source updateDocument method with the provided actionOptions.
    if (!((_a = options.stackbitConfig) === null || _a === void 0 ? void 0 : _a.onDocumentUpdate)) {
        return options.contentSourceData.instance.updateDocument(options.actionOptions);
    }
    return options.stackbitConfig.onDocumentUpdate({
        // Spread actionOptions to clone them shallowly to prevent accidental
        // property overrides within user methods.
        updateDocumentOptions: { ...options.actionOptions },
        updateDocument: async (actionOptions) => {
            var _a;
            if (!actionOptions) {
                actionOptions = options.actionOptions;
            }
            return options.contentSourceData.instance.updateDocument({
                ...actionOptions,
                userContext: (_a = actionOptions.userContext) !== null && _a !== void 0 ? _a : options.actionOptions.userContext,
                modelMap: options.actionOptions.modelMap
            });
        },
        ...getDocumentHookOptions(options)
    });
}
exports.updateDocumentHooked = updateDocumentHooked;
async function deleteDocumentHooked(options) {
    var _a;
    // If no onDocumentDelete defined in the config, call the original content
    // source deleteDocument method with the provided actionOptions.
    if (!((_a = options.stackbitConfig) === null || _a === void 0 ? void 0 : _a.onDocumentDelete)) {
        return options.contentSourceData.instance.deleteDocument(options.actionOptions);
    }
    return options.stackbitConfig.onDocumentDelete({
        // Spread actionOptions to clone them shallowly to prevent accidental
        // property overrides within user methods.
        deleteDocumentOptions: { ...options.actionOptions },
        deleteDocument: async (actionOptions) => {
            var _a;
            if (!actionOptions) {
                actionOptions = options.actionOptions;
            }
            return options.contentSourceData.instance.deleteDocument({
                ...actionOptions,
                userContext: (_a = actionOptions.userContext) !== null && _a !== void 0 ? _a : options.actionOptions.userContext
            });
        },
        ...getDocumentHookOptions(options)
    });
}
exports.deleteDocumentHooked = deleteDocumentHooked;
async function publishDocumentHooked(options) {
    var _a;
    // If no onDocumentsPublish defined in the config, call the original content
    // source publishDocuments method with the provided actionOptions.
    if (!((_a = options.stackbitConfig) === null || _a === void 0 ? void 0 : _a.onDocumentsPublish)) {
        return options.contentSourceData.instance.publishDocuments(options.actionOptions);
    }
    return options.stackbitConfig.onDocumentsPublish({
        // Spread actionOptions to clone them shallowly to prevent accidental
        // property overrides within user methods.
        publishDocumentsOptions: { ...options.actionOptions },
        publishDocuments: async (actionOptions) => {
            var _a;
            if (!actionOptions) {
                actionOptions = options.actionOptions;
            }
            return options.contentSourceData.instance.publishDocuments({
                ...actionOptions,
                userContext: (_a = actionOptions.userContext) !== null && _a !== void 0 ? _a : options.actionOptions.userContext
            });
        },
        ...getDocumentHookOptions(options)
    });
}
exports.publishDocumentHooked = publishDocumentHooked;
function getDocumentHookOptions(options) {
    const srcType = options.contentSourceData.srcType;
    const srcProjectId = options.contentSourceData.srcProjectId;
    const contentSourceDataById = options.getContentSourceDataById();
    const configDelegate = (0, config_delegate_1.createConfigDelegate)({
        contentSourceDataById,
        logger: options.logger
    });
    return {
        srcType: srcType,
        srcProjectId: srcProjectId,
        contentSourceActions: getContentSourceActionsForContentSourceData({
            contentSourceData: options.contentSourceData,
            user: options.user,
            stackbitConfig: options.stackbitConfig,
            getContentSourceDataById: options.getContentSourceDataById,
            logger: options.logger
        }),
        getContentSourceActionsForSource: getContentSourceActionsForSourceThunk({
            getContentSourceDataById: options.getContentSourceDataById,
            logger: options.logger,
            user: options.user,
            stackbitConfig: options.stackbitConfig
        }),
        getUserContextForContentSourceType: (0, content_store_utils_1.getUserContextForSrcTypeThunk)(options.user),
        ...configDelegate
    };
}
function getContentSourceActionsForSourceThunk({ getContentSourceDataById, logger, user, stackbitConfig }) {
    return (options) => {
        return getContentSourceActionsForSource({
            logger: logger,
            srcType: options.srcType,
            srcProjectId: options.srcProjectId,
            user: user,
            stackbitConfig,
            getContentSourceDataById
        });
    };
}
exports.getContentSourceActionsForSourceThunk = getContentSourceActionsForSourceThunk;
function getContentSourceActionsForSource({ srcType, srcProjectId, logger, user, stackbitConfig, getContentSourceDataById }) {
    const contentSourcesData = (0, content_store_utils_1.findContentSourcesDataForTypeOrId)({
        contentSourceDataById: getContentSourceDataById(),
        srcType,
        srcProjectId
    });
    if (contentSourcesData.length === 0) {
        logger.warn(`The getContentSourceActionsForContentSource() did not find content sources for srcType: '${srcType}', srcProjectId:'${srcProjectId}'.`);
        return undefined;
    }
    else if (contentSourcesData.length > 1) {
        logger.warn(`The getContentSourceActionsForContentSource() found more than one content sources for '${srcType}'. ` +
            `Please specify 'srcType' and 'srcProjectId' to narrow down the search.`);
        return undefined;
    }
    const contentSourceData = contentSourcesData[0];
    return getContentSourceActionsForContentSourceData({
        contentSourceData,
        user,
        stackbitConfig,
        getContentSourceDataById,
        logger
    });
}
function getContentSourceActionsForContentSourceData({ contentSourceData, user, stackbitConfig, getContentSourceDataById, logger }) {
    return {
        createDocument: async (options) => {
            var _a;
            return createDocumentHooked({
                actionOptions: {
                    ...options,
                    userContext: (_a = options.userContext) !== null && _a !== void 0 ? _a : (0, content_store_utils_1.getUserContextForSrcType)(contentSourceData.srcType, user),
                    modelMap: contentSourceData.csiModelMap
                },
                contentSourceData,
                user,
                stackbitConfig,
                getContentSourceDataById,
                logger
            });
        },
        updateDocument: (options) => {
            var _a;
            return updateDocumentHooked({
                actionOptions: {
                    ...options,
                    userContext: (_a = options.userContext) !== null && _a !== void 0 ? _a : (0, content_store_utils_1.getUserContextForSrcType)(contentSourceData.srcType, user),
                    modelMap: contentSourceData.csiModelMap
                },
                contentSourceData,
                user,
                stackbitConfig,
                getContentSourceDataById,
                logger
            });
        },
        deleteDocument: (options) => {
            var _a;
            return deleteDocumentHooked({
                actionOptions: {
                    ...options,
                    userContext: (_a = options.userContext) !== null && _a !== void 0 ? _a : (0, content_store_utils_1.getUserContextForSrcType)(contentSourceData.srcType, user)
                },
                contentSourceData,
                user,
                stackbitConfig,
                getContentSourceDataById,
                logger
            });
        },
        publishDocuments: (options) => {
            var _a;
            return publishDocumentHooked({
                actionOptions: {
                    ...options,
                    userContext: (_a = options.userContext) !== null && _a !== void 0 ? _a : (0, content_store_utils_1.getUserContextForSrcType)(contentSourceData.srcType, user)
                },
                contentSourceData,
                user,
                stackbitConfig,
                getContentSourceDataById,
                logger
            });
        }
    };
}
//# sourceMappingURL=document-hooks.js.map