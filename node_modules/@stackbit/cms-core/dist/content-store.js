"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContentStore = exports.StackbitPresetModelName = void 0;
const lodash_1 = __importDefault(require("lodash"));
const path_1 = __importDefault(require("path"));
const sanitize_filename_1 = __importDefault(require("sanitize-filename"));
const types_1 = require("@stackbit/types");
const sdk_1 = require("@stackbit/sdk");
const utils_1 = require("@stackbit/utils");
const timer_1 = require("./utils/timer");
const search_utils_1 = require("./utils/search-utils");
const csi_to_store_docs_converter_1 = require("./utils/csi-to-store-docs-converter");
const content_store_utils_1 = require("./content-store-utils");
const site_map_1 = require("./utils/site-map");
const store_to_api_docs_converter_1 = require("./utils/store-to-api-docs-converter");
const create_update_csi_docs_1 = require("./utils/create-update-csi-docs");
const duplicate_document_1 = require("./utils/duplicate-document");
const model_utils_1 = require("./utils/model-utils");
const common_schema_1 = require("./common/common-schema");
const preset_utils_1 = require("./utils/preset-utils");
const backward_compatibility_1 = require("./utils/backward-compatibility");
const config_delegate_1 = require("./utils/config-delegate");
const asset_sources_utils_1 = require("./utils/asset-sources-utils");
const document_hooks_1 = require("./utils/document-hooks");
const custom_actions_1 = require("./utils/custom-actions");
const tree_views_1 = require("./utils/tree-views");
const field_path_utils_1 = require("./utils/field-path-utils");
const user_log_utils_1 = require("./utils/user-log-utils");
const content_engine_1 = require("content-engine");
const ContentStoreEventType = {
    YamlModelFilesChange: 'yamlModelFilesChange',
    PresetFilesChange: 'presetFilesChange',
    ContentSourceInvalidateSchema: 'contentSourceInvalidateSchema',
    ContentSourceContentChange: 'contentSourceContentChange'
};
exports.StackbitPresetModelName = 'stackbitPreset';
class ContentStore {
    constructor(options) {
        this.contentSources = [];
        this.contentSourceDataById = {};
        this.stackbitConfig = null;
        this.yamlModels = [];
        this.configModels = [];
        this.modelExtensions = null;
        this.presets = {};
        this.siteMapEntryGroups = {};
        this.processingContentSourcesPromise = null;
        this.contentStoreEventQueue = [];
        this.treeViews = [];
        this.customActionRunStateMap = {};
        this.logger = options.logger.createLogger({ label: 'content-store' });
        this.userLogger = options.userLogger.createLogger({ label: 'content-store' });
        this.localDev = options.localDev;
        this.staticAssetsPublicPath = options.staticAssetsPublicPath;
        this.webhookUrl = options.webhookUrl;
        this.runCommand = options.runCommand;
        this.git = options.git;
        this.userCommandSpawner = options.userCommandSpawner;
        this.onSchemaChangeCallback = options.onSchemaChangeCallback;
        this.onContentChangeCallback = options.onContentChangeCallback;
        this.onActionStateChangeCallback = options.onActionStateChangeCallback;
        this.handleConfigAssets = options.handleConfigAssets;
        this.contentUpdatesWatchTimer = new timer_1.Timer({ timerCallback: () => this.handleTimerTimeout(), logger: this.logger });
        this.devAppRestartNeeded = options.devAppRestartNeeded;
        // The `loadContentSourcesAndProcessData` method can be called multiple times rapidly for several reasons:
        // stackbit.config.js updated, one of the preset or the yaml-model files changed, one of the content-source's
        // schema files updated (for example Sanity's schema files).
        // Therefore, to prevent parallel executions of this method and corrupting the ContentStore state,
        // debounce rapid invocations of this method and defer invocation while this method is running.
        this.loadContentSourcesAndProcessData = (0, utils_1.deferWhileRunning)(this.loadContentSourcesAndProcessData, {
            thisArg: this,
            debounceDelay: 100,
            debounceMaxDelay: 500,
            // When the loadContentSourcesAndProcessData is called multiple times with different arguments,
            // ensure that the deferred call will be called with the lowest denominator of the passed arguments.
            argsResolver: ({ nextArgs, prevArgs }) => {
                // If at least one call had "init: true" then call the deferred
                // function with "init: true" and without contentSourceIds.
                const init = nextArgs[0].init || Boolean(prevArgs === null || prevArgs === void 0 ? void 0 : prevArgs[0].init);
                if (init) {
                    return [{ init }];
                }
                // If at least one call had "startWatchingContentUpdates: true" then call the deferred
                // function with "startWatchingContentUpdates: true".
                const startWatchingContentUpdates = nextArgs[0].startWatchingContentUpdates || Boolean(prevArgs === null || prevArgs === void 0 ? void 0 : prevArgs[0].startWatchingContentUpdates);
                // If at least one call had "contentSourceIds: undefined" (signal to reload all content sources)
                // then call the deferred function with "contentSourceIds: undefined",
                // otherwise call it with union of content source ids.
                const contentSourceIds = typeof nextArgs[0].contentSourceIds === 'undefined' || (prevArgs && typeof prevArgs[0].contentSourceIds === 'undefined')
                    ? undefined
                    : lodash_1.default.union(nextArgs[0].contentSourceIds, prevArgs === null || prevArgs === void 0 ? void 0 : prevArgs[0].contentSourceIds);
                return [{ init, startWatchingContentUpdates, contentSourceIds }];
            }
        });
    }
    async init({ stackbitConfig }) {
        var _a;
        this.logger.debug('init');
        this.stackbitConfig = stackbitConfig;
        if (stackbitConfig) {
            if (stackbitConfig.modelExtensions) {
                this.modelExtensions = stackbitConfig.modelExtensions;
            }
            else {
                this.yamlModels = await this.loadYamlModels({ stackbitConfig });
                this.configModels = this.mergeConfigModels((_a = stackbitConfig.models) !== null && _a !== void 0 ? _a : [], this.yamlModels);
            }
        }
        await this.loadContentSourcesAndProcessData({ init: true });
        this.contentUpdatesWatchTimer.startTimer();
    }
    async onStackbitConfigChange({ stackbitConfig }) {
        var _a;
        this.logger.debug('onStackbitConfigChange');
        this.stackbitConfig = stackbitConfig;
        if (stackbitConfig) {
            if (stackbitConfig.modelExtensions) {
                this.modelExtensions = stackbitConfig.modelExtensions;
            }
            else {
                this.configModels = this.mergeConfigModels((_a = stackbitConfig.models) !== null && _a !== void 0 ? _a : [], this.yamlModels);
            }
        }
        await this.loadContentSourcesAndProcessData({ init: true });
    }
    /**
     * This method is called when contentUpdatesWatchTimer receives timeout.
     * This happens when the user is not using the Stackbit app for some time
     * but container is not hibernated.
     * It then notifies all content sources to stop watching for content
     * changes, which in turn stops polling CMS for content changes and helps
     * reducing the CMS API usage.
     */
    handleTimerTimeout() {
        var _a;
        for (const contentSourceInstance of this.contentSources) {
            (_a = contentSourceInstance.stopWatchingContentUpdates) === null || _a === void 0 ? void 0 : _a.call(contentSourceInstance);
        }
    }
    /**
     * This method is called when user interacts with Stackbit application.
     * It is used to reset contentUpdatesWatchTimer. When the timer is over
     * all content sources are notified to stop watching for content updates.
     */
    async keepAlive() {
        if (this.contentUpdatesWatchTimer.isRunning()) {
            this.contentUpdatesWatchTimer.resetTimer();
            return;
        }
        this.logger.debug('keepAlive => contentUpdatesWatchTimer is not running => load content source data');
        this.contentUpdatesWatchTimer.startTimer();
        await this.loadContentSourcesAndProcessData({ init: false, startWatchingContentUpdates: true });
    }
    stop() {
        this.contentUpdatesWatchTimer.stopTimer();
    }
    async onFilesChange(updatedFiles) {
        var _a;
        this.logger.debug('onFilesChange');
        if (this.stackbitConfig && !this.stackbitConfig.modelExtensions) {
            // Check if any of the yaml models files were changed. If yaml model files were changed,
            // reload them and merge them with models defined in stackbit config.
            const modelDirs = (0, sdk_1.getYamlModelDirs)(this.stackbitConfig);
            const yamlModelsChanged = updatedFiles.find((updatedFile) => lodash_1.default.some(modelDirs, (modelDir) => updatedFile.startsWith(modelDir)));
            if (yamlModelsChanged) {
                this.logger.debug('identified change in stackbit model files');
                this.yamlModels = await this.loadYamlModels({ stackbitConfig: this.stackbitConfig });
                this.configModels = this.mergeConfigModels((_a = this.stackbitConfig.models) !== null && _a !== void 0 ? _a : [], this.yamlModels);
                this.pushContentSourceEvent({
                    eventName: ContentStoreEventType.YamlModelFilesChange
                });
            }
        }
        if (this.stackbitConfig) {
            // Check if any of the preset files were changed. If presets were changed, reload them.
            const presetDirs = (0, sdk_1.getPresetDirs)(this.stackbitConfig);
            const presetsChanged = updatedFiles.find((updatedFile) => lodash_1.default.some(presetDirs, (presetDir) => updatedFile.startsWith(presetDir)));
            if (presetsChanged && !this.usesContentSourcePresets()) {
                this.logger.debug('identified change in stackbit preset files');
                this.presets = await this.loadPresetsFromConfig({ stackbitConfig: this.stackbitConfig });
                this.pushContentSourceEvent({
                    eventName: ContentStoreEventType.PresetFilesChange
                });
            }
        }
        for (const contentSourceInstance of this.contentSources) {
            const contentSourceId = (0, content_store_utils_1.getContentSourceIdForContentSource)(contentSourceInstance);
            const contentSourceData = this.contentSourceDataById[contentSourceId];
            if (contentSourceData === null || contentSourceData === void 0 ? void 0 : contentSourceData.destroyed) {
                this.logger.debug(`contentSource '${contentSourceId}' was destroyed, don't call onFilesChange`);
                continue;
            }
            this.logger.debug(`call onFilesChange for contentSource: ${contentSourceId}`);
            const onFilesChangeResult = await contentSourceInstance.onFilesChange({ updatedFiles: updatedFiles });
            // If the schema was changed in a specific content source, there is no need to process and notify for content changes.
            // Because the schema changes will trigger loadContentSourcesAndProcessData and reload all models and content of that
            // content source and send the schemaChanged notification that will cause the Studio to reload the schema and documents.
            if (onFilesChangeResult.invalidateSchema) {
                this.logger.debug(`schema was invalidated for contentSource: ${contentSourceId}`);
                this.pushContentSourceEvent({
                    eventName: ContentStoreEventType.ContentSourceInvalidateSchema,
                    contentSourceId: contentSourceId
                });
            }
            else if (!(0, content_store_utils_1.isContentChangesEmpty)(onFilesChangeResult.contentChanges)) {
                this.logger.debug(`content was changed for contentSource: ${contentSourceId}`);
                this.pushContentSourceEvent({
                    eventName: ContentStoreEventType.ContentSourceContentChange,
                    contentSourceId: contentSourceId,
                    contentChanges: onFilesChangeResult.contentChanges
                });
            }
        }
        await this.processContentStoreEvents();
    }
    async loadYamlModels({ stackbitConfig }) {
        const yamlModelsResult = await (0, sdk_1.loadYamlModelsFromFiles)(stackbitConfig);
        for (const error of yamlModelsResult.errors) {
            this.userLogger.warn(error.message);
        }
        return yamlModelsResult.models;
    }
    mergeConfigModels(configModels, modelsFromFiles) {
        const configModelsResult = (0, sdk_1.mergeConfigModelsWithModelsFromFiles)(configModels, modelsFromFiles);
        for (const error of configModelsResult.errors) {
            this.userLogger.warn(error.message);
        }
        return configModelsResult.models;
    }
    async loadPresetsFromConfig({ stackbitConfig }) {
        var _a;
        const contentSources = (_a = stackbitConfig === null || stackbitConfig === void 0 ? void 0 : stackbitConfig.contentSources) !== null && _a !== void 0 ? _a : [];
        const singleContentSource = contentSources.length === 1 ? contentSources[0] : null;
        const presetResult = await (0, sdk_1.loadPresets)({
            config: stackbitConfig,
            ...(singleContentSource
                ? {
                    fallbackSrcType: singleContentSource.getContentSourceType(),
                    fallbackSrcProjectId: singleContentSource.getProjectId()
                }
                : null)
        });
        for (const error of presetResult.errors) {
            this.userLogger.warn(error.message);
        }
        const { presets } = await this.handleConfigAssets({ presets: presetResult.presets });
        return presets;
    }
    async loadPresetsFromContentSource(contentSourceData) {
        const presets = lodash_1.default.reduce(contentSourceData.csiDocuments, (result, csiDocument) => {
            if (csiDocument.modelName === exports.StackbitPresetModelName) {
                const preset = (0, preset_utils_1.getPresetFromDocument)({
                    srcType: contentSourceData.srcType,
                    srcProjectId: contentSourceData.srcProjectId,
                    csiDocument,
                    csiAssetMap: contentSourceData.csiAssetMap,
                    logger: this.logger
                });
                if (preset) {
                    result[csiDocument.id] = preset;
                }
            }
            return result;
        }, {});
        return presets;
    }
    /**
     * If any content sources implement the `getContentEngineConfig` method then this function gets all
     * of these plugin definitions and creates the content engine.
     */
    async createContentEngineIfNeeded() {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        const logger = this.userLogger.createLogger({ label: 'content-engine' });
        if (this.contentEngine) {
            logger.info('stopping content engine');
            this.contentEngine.clearListeners();
            await this.contentEngine.stop();
            this.contentEngine = null;
        }
        const plugins = Array.from(new Set((_a = this.contentSources) === null || _a === void 0 ? void 0 : _a.flatMap((contentSource) => { var _a, _b; return (_b = (_a = contentSource.getContentEngineConfig) === null || _a === void 0 ? void 0 : _a.call(contentSource)) === null || _b === void 0 ? void 0 : _b.plugins; }).filter(Boolean)));
        if (plugins.length < 1) {
            return;
        }
        logger.info('creating content engine');
        this.contentEngine = (0, content_engine_1.contentEngine)({
            directory: (_b = this.stackbitConfig) === null || _b === void 0 ? void 0 : _b.dirPath,
            port: (_d = (_c = this.stackbitConfig) === null || _c === void 0 ? void 0 : _c.contentEngine) === null || _d === void 0 ? void 0 : _d.port,
            host: (_f = (_e = this.stackbitConfig) === null || _e === void 0 ? void 0 : _e.contentEngine) === null || _f === void 0 ? void 0 : _f.host,
            engineConfig: {
                plugins
            }
        });
        (_g = this.contentEngine) === null || _g === void 0 ? void 0 : _g.onStdOut((data) => {
            logger.info(data.toString());
        });
        (_h = this.contentEngine) === null || _h === void 0 ? void 0 : _h.onStdErr((data) => {
            logger.error(data.toString());
        });
    }
    /**
     * This function reloads the data of the specified content-sources, while
     * reusing the cached data of the rest of the content-sources, then processes
     * the content sources' data by merging it with models defined in
     * stackbit.config.js and yaml-model files.
     *
     * This function is wrapped by `deferWhileRunning` ensuring this method is
     * invoked one at a time.
     *
     * @param {boolean} init Flag specifying if the content sources need to be initialized or reset.
     *   The content sources need to be (re-)initialized only when the stackbit.config.js was reloaded.
     *   In all other cases content sources can be reset.
     * @param {string[] | undefined} contentSourceIds Array of content source IDs to reload.
     *   If not provided or set to "undefined", will reload all content sources.
     *   If set to empty array will not reload any content sources and only process their cached data.
     * @private
     */
    async loadContentSourcesAndProcessData({ init, startWatchingContentUpdates, contentSourceIds }) {
        var _a, _b, _c, _d, _e, _f;
        this.logger.debug('loadContentSourcesAndProcessData', { init, contentSourceIds });
        if (this.processingContentSourcesPromise) {
            // for internal monitoring
            this.logger.error('ALERT, called loadContentSourcesAndProcessData while still processing the previous call');
        }
        this.processingContentSourcesPromise = (0, utils_1.deferredPromise)();
        // On init, get the new content source instances from the config and wrap them with backward compatibility Proxy.
        // Otherwise, reuse existing proxy wrapped backward compatible content sources.
        const contentSources = init || this.contentSources.length === 0
            ? ((_b = (_a = this.stackbitConfig) === null || _a === void 0 ? void 0 : _a.contentSources) !== null && _b !== void 0 ? _b : []).map((contentSource) => {
                return (0, backward_compatibility_1.backwardCompatibleContentSource)(contentSource);
            })
            : this.contentSources;
        this.contentSources = contentSources;
        if (init) {
            this.logger.debug('init content sources');
            await this.createContentEngineIfNeeded();
            await ((_c = this.contentEngine) === null || _c === void 0 ? void 0 : _c.sync({
                runServer: true
            }));
        }
        const promises = contentSources.map((contentSourceInstance) => {
            const contentSourceId = (0, content_store_utils_1.getContentSourceIdForContentSource)(contentSourceInstance);
            if (init || !contentSourceIds || contentSourceIds.includes(contentSourceId)) {
                return this.loadContentSourceData({ contentSourceInstance, init, startWatchingContentUpdates });
            }
            else {
                return Promise.resolve(lodash_1.default.omit(this.contentSourceDataById[contentSourceId], ['models', 'modelMap', 'documents', 'documentMap']));
            }
        });
        const contentSourceRawDataArr = await Promise.all(promises);
        // find first content source that supports presets
        for (let i = 0; i < contentSources.length; i++) {
            const contentSourceDataRaw = contentSourceRawDataArr[i];
            if ((_d = contentSourceDataRaw === null || contentSourceDataRaw === void 0 ? void 0 : contentSourceDataRaw.csiModelMap) === null || _d === void 0 ? void 0 : _d[exports.StackbitPresetModelName]) {
                this.presetsContentSource = contentSourceDataRaw.instance;
                // reload presets from content source only if needed
                if (init || !contentSourceIds || contentSourceIds.includes(contentSourceDataRaw.id)) {
                    this.presets = await this.loadPresetsFromContentSource(contentSourceDataRaw);
                }
                break;
            }
        }
        // fallback to loading presets from config as usual
        if (init && this.stackbitConfig && !this.presetsContentSource) {
            this.presets = await this.loadPresetsFromConfig({ stackbitConfig: this.stackbitConfig });
        }
        // update all content sources at once to prevent race conditions
        this.contentSourceDataById = await this.processData({
            stackbitConfig: this.stackbitConfig,
            configModels: (_f = (_e = this.modelExtensions) !== null && _e !== void 0 ? _e : this.configModels) !== null && _f !== void 0 ? _f : [],
            presets: this.presets,
            contentSourceRawDataArr: contentSourceRawDataArr
        });
        const configDelegate = (0, config_delegate_1.createConfigDelegate)({
            contentSourceDataById: this.contentSourceDataById,
            logger: this.userLogger
        });
        // generate create site map entries
        this.siteMapEntryGroups = await (0, site_map_1.getSiteMapEntriesFromStackbitConfig)({
            stackbitConfig: this.stackbitConfig,
            contentSourceDataById: this.contentSourceDataById,
            configDelegate
        });
        this.treeViews = await (0, tree_views_1.getSanitizedTreeViews)({
            configDelegate,
            stackbitConfig: this.stackbitConfig,
            contentSourceDataById: this.contentSourceDataById,
            logger: this.userLogger
        });
        if (!init) {
            this.onSchemaChangeCallback();
        }
        this.logger.debug('loadContentSourcesAndProcessData finished', { init, contentSourceIds });
        const processingPromise = this.processingContentSourcesPromise;
        this.processingContentSourcesPromise = null;
        // Do not "await" on processContentStoreEvents as it may introduce a deadlock with
        // the nested loadContentSourcesAndProcessData call which is wrapped by deferWhileRunning.
        this.processContentStoreEvents()
            .catch((error) => {
            this.logger.error('error processing content source events', { error });
        })
            .finally(() => {
            processingPromise.resolve();
        });
    }
    async processContentStoreEvents() {
        // If the ContentStore is currently loading content sources, return to prevent parallel data updates.
        // This method will be called once current loading cycle ends.
        if (this.processingContentSourcesPromise) {
            this.logger.debug('processContentStoreEvents, processing content sources, delaying execution');
            return this.processingContentSourcesPromise.promise;
        }
        this.logger.debug('processContentStoreEvents');
        const contentSourceIdsWithInvalidatedSchema = [];
        const contentChanges = {
            updatedDocuments: [],
            updatedAssets: [],
            updatedScheduledActions: [],
            deletedDocuments: [],
            deletedAssets: [],
            deletedScheduledActions: []
        };
        let invalidateSchema = false;
        let presetsUpdated = false;
        const contentSourceEvents = this.contentStoreEventQueue;
        this.contentStoreEventQueue = [];
        for (const contentSourceEvent of contentSourceEvents) {
            if (contentSourceEvent.eventName === ContentStoreEventType.YamlModelFilesChange ||
                contentSourceEvent.eventName === ContentStoreEventType.PresetFilesChange) {
                invalidateSchema = true;
            }
            else if (contentSourceEvent.eventName === ContentStoreEventType.ContentSourceInvalidateSchema) {
                invalidateSchema = true;
                contentSourceIdsWithInvalidatedSchema.push(contentSourceEvent.contentSourceId);
            }
            else if (contentSourceEvent.eventName === ContentStoreEventType.ContentSourceContentChange) {
                const result = this.onContentChange(contentSourceEvent.contentSourceId, contentSourceEvent.contentChanges);
                contentChanges.updatedDocuments = contentChanges.updatedDocuments.concat(result.contentChangeResult.updatedDocuments);
                contentChanges.updatedAssets = contentChanges.updatedAssets.concat(result.contentChangeResult.updatedAssets);
                contentChanges.updatedScheduledActions = contentChanges.updatedScheduledActions.concat(result.contentChangeResult.updatedScheduledActions);
                contentChanges.deletedDocuments = contentChanges.deletedDocuments.concat(result.contentChangeResult.deletedDocuments);
                contentChanges.deletedAssets = contentChanges.deletedAssets.concat(result.contentChangeResult.deletedAssets);
                contentChanges.deletedScheduledActions = contentChanges.deletedScheduledActions.concat(result.contentChangeResult.deletedScheduledActions);
                if (result.presetsUpdated) {
                    presetsUpdated = true;
                }
            }
        }
        // If the schema was changed, call loadContentSourcesAndProcessData method, this will reload all the SiteMapEntries and call the onSchemaChangeCallback.
        // As soon as the Studio receives the schemaChanged notification it will reload all the models and the documents.
        if (invalidateSchema) {
            this.logger.debug('processContentStoreEvents => invalidateSchema');
            await this.loadContentSourcesAndProcessData({
                init: false,
                contentSourceIds: contentSourceIdsWithInvalidatedSchema
            });
        }
        else {
            this.logger.debug('processContentStoreEvents => content changes', { ...(0, content_store_utils_1.contentChangeResultCounts)(contentChanges), presetsUpdated });
            const configDelegate = (0, config_delegate_1.createConfigDelegate)({
                contentSourceDataById: this.contentSourceDataById,
                logger: this.userLogger
            });
            // If the schema wasn't changed, update SiteMapEntries with the changed content.
            this.siteMapEntryGroups = await (0, site_map_1.updateSiteMapEntriesWithContentChanges)({
                siteMapEntryGroups: this.siteMapEntryGroups,
                contentChanges: contentChanges,
                stackbitConfig: this.stackbitConfig,
                contentSourceDataById: this.contentSourceDataById,
                configDelegate
            });
            this.treeViews = await (0, tree_views_1.getSanitizedTreeViews)({
                configDelegate,
                stackbitConfig: this.stackbitConfig,
                contentSourceDataById: this.contentSourceDataById,
                logger: this.userLogger
            });
            // If presets were updated, call onSchemaChangeCallback to notify the Studio.
            // The Studio will refresh the models and the documents, so no need to notify
            // content changes in this case.
            if (presetsUpdated) {
                this.onSchemaChangeCallback();
            }
            else if (!(0, content_store_utils_1.isContentChangeResultEmpty)(contentChanges)) {
                this.onContentChangeCallback(contentChanges);
            }
        }
    }
    pushContentSourceEvent(contentStoreEvent) {
        if (contentStoreEvent.eventName === ContentStoreEventType.ContentSourceContentChange) {
            // If a content source enqueued the 'contentSourceInvalidateSchema' event,
            // don't push the 'contentSourceContentChange' event, because 'contentSourceInvalidateSchema'
            // will reload all the content source data.
            const hasContentSourceSchemaChangeEvent = this.contentStoreEventQueue.find((event) => event.eventName === ContentStoreEventType.ContentSourceInvalidateSchema && event.contentSourceId === contentStoreEvent.contentSourceId);
            if (!hasContentSourceSchemaChangeEvent) {
                this.contentStoreEventQueue.push(contentStoreEvent);
            }
        }
        else if (contentStoreEvent.eventName === ContentStoreEventType.ContentSourceInvalidateSchema) {
            // Clear any 'contentSourceContentChange' events for a content source,
            // the 'contentSourceInvalidateSchema' will reload all the content source data.
            this.clearEventsForContentSourceId(contentStoreEvent.contentSourceId);
            this.contentStoreEventQueue.push(contentStoreEvent);
        }
        else if (contentStoreEvent.eventName === ContentStoreEventType.YamlModelFilesChange) {
            this.contentStoreEventQueue = this.contentStoreEventQueue.filter((event) => event.eventName !== ContentStoreEventType.YamlModelFilesChange);
            this.contentStoreEventQueue.push(contentStoreEvent);
        }
        else if (contentStoreEvent.eventName === ContentStoreEventType.PresetFilesChange) {
            this.contentStoreEventQueue = this.contentStoreEventQueue.filter((event) => event.eventName !== ContentStoreEventType.PresetFilesChange);
            this.contentStoreEventQueue.push(contentStoreEvent);
        }
    }
    clearEventsForContentSourceId(contentSourceId) {
        this.contentStoreEventQueue = this.contentStoreEventQueue.filter((contentSourceEvent) => {
            if (contentSourceEvent.eventName === ContentStoreEventType.ContentSourceContentChange ||
                contentSourceEvent.eventName === ContentStoreEventType.ContentSourceInvalidateSchema) {
                return contentSourceEvent.contentSourceId !== contentSourceId;
            }
            return true;
        });
    }
    async loadContentSourceData({ contentSourceInstance, init, startWatchingContentUpdates }) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        const contentSourceId = (0, content_store_utils_1.getContentSourceIdForContentSource)(contentSourceInstance);
        const contentEngineConfig = (_a = contentSourceInstance.getContentEngineConfig) === null || _a === void 0 ? void 0 : _a.call(contentSourceInstance);
        this.logger.debug('loadContentSourceData', { contentSourceId, init });
        // clear content source events emitted by this content source because all the content source data is reloaded
        this.clearEventsForContentSourceId(contentSourceId);
        const localCache = {};
        const getContentSourceDataForCurrentInstance = (methodName) => {
            const contentSourceData = this.contentSourceDataById[contentSourceId];
            if (!contentSourceData) {
                // When loading the content sources for the first time, this.contentSourceDataById will be empty.
                // However, while being loaded, content sources may call cache methods, for example a content
                // source may call getModelByName from within getDocuments. In this case, return locally cached data.
                if (this.processingContentSourcesPromise) {
                    return localCache;
                }
                const atLine = (0, content_store_utils_1.getErrorAtLine)(2, getContentSourceDataForCurrentInstance);
                const errorMessage = `Error executing 'cache.${methodName}' method${atLine}. The content source with id '${contentSourceId}' was not found.`;
                this.logger.error(errorMessage);
                return;
            }
            if (!this.contentSources.includes(contentSourceInstance)) {
                const atLine = (0, content_store_utils_1.getErrorAtLine)(2, getContentSourceDataForCurrentInstance);
                const errorMessage = `Content source life cycle error! The content source with id '${contentSourceId}' called the 'cache.${methodName}' ` +
                    `method${atLine} after the destroy() method was called.`;
                this.logger.error(errorMessage);
                return;
            }
            // While loading the content source, it may call cache methods, when this happens, return the
            // stale data overridden with the most frequent loaded data
            if (this.processingContentSourcesPromise) {
                return Object.assign(contentSourceData, localCache);
            }
            return contentSourceData;
        };
        const cache = {
            getSchema: () => {
                const contentSourceData = getContentSourceDataForCurrentInstance('getSchema');
                if (!(contentSourceData === null || contentSourceData === void 0 ? void 0 : contentSourceData.csiSchema)) {
                    if (contentSourceData) {
                        const atLine = (0, content_store_utils_1.getErrorAtLine)(1);
                        const errorMessage = `Content source life cycle error! The content source with id '${contentSourceId}' called the 'cache.getSchema' ` +
                            `method${atLine} before the content source's getSchema() method was called.`;
                        this.logger.error(errorMessage);
                    }
                    return { models: [], locales: [], context: null };
                }
                return contentSourceData.csiSchema;
            },
            getModelByName: (modelName) => {
                const contentSourceData = getContentSourceDataForCurrentInstance('getModelByName');
                if (!(contentSourceData === null || contentSourceData === void 0 ? void 0 : contentSourceData.csiModelMap)) {
                    if (contentSourceData) {
                        const atLine = (0, content_store_utils_1.getErrorAtLine)(1);
                        const errorMessage = `Content source life cycle error! The content source with id '${contentSourceId}' called the 'cache.getModelByName' ` +
                            `method${atLine} before the content source's getSchema() method was called.`;
                        this.logger.error(errorMessage);
                    }
                    return;
                }
                return contentSourceData.csiModelMap[modelName];
            },
            getDocuments: () => {
                var _a;
                const contentSourceData = getContentSourceDataForCurrentInstance('getDocuments');
                return (_a = contentSourceData === null || contentSourceData === void 0 ? void 0 : contentSourceData.csiDocuments) !== null && _a !== void 0 ? _a : [];
            },
            getDocumentById: (documentId) => {
                var _a;
                const contentSourceData = getContentSourceDataForCurrentInstance('getDocumentById');
                return (_a = contentSourceData === null || contentSourceData === void 0 ? void 0 : contentSourceData.csiDocumentMap) === null || _a === void 0 ? void 0 : _a[documentId];
            },
            getAssets: () => {
                var _a;
                const contentSourceData = getContentSourceDataForCurrentInstance('getAssets');
                return (_a = contentSourceData === null || contentSourceData === void 0 ? void 0 : contentSourceData.csiAssets) !== null && _a !== void 0 ? _a : [];
            },
            getScheduledActions: () => {
                var _a;
                const contentSourceData = getContentSourceDataForCurrentInstance('getScheduledActions');
                return (_a = contentSourceData === null || contentSourceData === void 0 ? void 0 : contentSourceData.scheduledActions) !== null && _a !== void 0 ? _a : [];
            },
            getScheduledActionsForDocumentId: (documentId) => {
                var _a, _b;
                const contentSourceData = getContentSourceDataForCurrentInstance('getScheduledActionsForDocumentId');
                return (_b = (_a = contentSourceData === null || contentSourceData === void 0 ? void 0 : contentSourceData.scheduledActions) === null || _a === void 0 ? void 0 : _a.filter((scheduledAction) => scheduledAction.documentIds.includes(documentId))) !== null && _b !== void 0 ? _b : [];
            },
            getAssetById: (assetId) => {
                var _a;
                const contentSourceData = getContentSourceDataForCurrentInstance('getAssetById');
                return (_a = contentSourceData === null || contentSourceData === void 0 ? void 0 : contentSourceData.csiAssetMap) === null || _a === void 0 ? void 0 : _a[assetId];
            },
            updateContent: async (contentChanges) => {
                if ((0, content_store_utils_1.isContentChangesEmpty)(contentChanges)) {
                    return;
                }
                const contentSourceData = getContentSourceDataForCurrentInstance('updateContent');
                if (!contentSourceData) {
                    return;
                }
                this.logger.debug('content source called updateContent', { contentSourceId });
                if (contentEngineConfig && this.contentEngine) {
                    this.logger.debug(`syncing ${contentEngineConfig.connector}`);
                    await this.contentEngine.sync({
                        buildSchema: false,
                        connector: contentEngineConfig.connector
                    });
                }
                this.pushContentSourceEvent({
                    eventName: ContentStoreEventType.ContentSourceContentChange,
                    contentSourceId: contentSourceId,
                    contentChanges: contentChanges
                });
                await this.processContentStoreEvents();
            },
            invalidateSchema: async () => {
                const contentSourceData = getContentSourceDataForCurrentInstance('invalidateSchema');
                if (!contentSourceData) {
                    return;
                }
                this.logger.debug('content source called invalidateSchema', { contentSourceId });
                if (contentEngineConfig && this.contentEngine) {
                    this.logger.debug(`syncing ${contentEngineConfig.connector}`);
                    await this.contentEngine.sync({
                        buildSchema: true,
                        connector: contentEngineConfig.connector
                    });
                }
                this.pushContentSourceEvent({
                    eventName: ContentStoreEventType.ContentSourceInvalidateSchema,
                    contentSourceId: contentSourceId
                });
                await this.processContentStoreEvents();
            }
        };
        if (init) {
            this.userLogger.info(`Initializing content source: ${contentSourceInstance.getContentSourceType()} (project: ${contentSourceInstance.getProjectId()})`);
            // When stackbit.config.js reloads, it loads new content source instances.
            // Previously loaded content source instances must be destroyed.
            const contentSourceData = this.contentSourceDataById[contentSourceId];
            if (contentSourceData && contentSourceData.instance !== contentSourceInstance) {
                this.logger.debug('destroy previous content source instance', { contentSourceId });
                try {
                    (_c = (_b = contentSourceData.instance).stopWatchingContentUpdates) === null || _c === void 0 ? void 0 : _c.call(_b);
                    await contentSourceData.instance.destroy();
                }
                catch (error) {
                    this.logger.debug('error destroying content source instance', { error });
                }
                contentSourceData.destroyed = true;
            }
            // If an instance that wasn't destroyed calls one of the InitOptions method don't return any data.
            await contentSourceInstance.init({
                logger: this.logger,
                userLogger: this.userLogger,
                localDev: this.localDev,
                webhookUrl: this.getWebhookUrl(contentSourceInstance.getContentSourceType(), contentSourceInstance.getProjectId()),
                userCommandSpawner: this.userCommandSpawner,
                devAppRestartNeeded: this.devAppRestartNeeded,
                cache: cache,
                runCommand: this.runCommand,
                git: this.git
            });
        }
        else {
            this.userLogger.info(`reset content source`);
            await contentSourceInstance.reset();
        }
        const version = await contentSourceInstance.getVersion();
        const csiSchema = await contentSourceInstance.getSchema();
        const csiModels = csiSchema.models;
        const csiModelMap = lodash_1.default.keyBy(csiModels, 'name');
        const locales = csiSchema.locales;
        const defaultLocaleCode = (_d = locales === null || locales === void 0 ? void 0 : locales.find((locale) => locale.default)) === null || _d === void 0 ? void 0 : _d.code;
        localCache.csiSchema = csiSchema;
        localCache.csiModels = csiModels;
        localCache.csiModelMap = csiModelMap;
        localCache.locales = locales;
        const csiDocuments = await contentSourceInstance.getDocuments({ modelMap: csiModelMap });
        const csiDocumentMap = lodash_1.default.keyBy(csiDocuments, 'id');
        localCache.csiDocuments = csiDocuments;
        localCache.csiDocumentMap = csiDocumentMap;
        const csiAssets = await contentSourceInstance.getAssets();
        const csiAssetMap = lodash_1.default.keyBy(csiAssets, 'id');
        localCache.csiAssets = csiAssets;
        localCache.csiAssetMap = csiAssetMap;
        let scheduledActions = [];
        let enabledScheduledActions = false;
        const scheduledActionsMethodsImplemented = !!(contentSourceInstance.createScheduledAction &&
            contentSourceInstance.updateScheduledAction &&
            contentSourceInstance.cancelScheduledAction &&
            contentSourceInstance.getScheduledActions);
        try {
            if (scheduledActionsMethodsImplemented) {
                scheduledActions = (_f = (await ((_e = contentSourceInstance.getScheduledActions) === null || _e === void 0 ? void 0 : _e.call(contentSourceInstance)))) !== null && _f !== void 0 ? _f : [];
                localCache.scheduledActions = scheduledActions;
                enabledScheduledActions = true;
            }
        }
        catch (err) {
            this.userLogger.warn('Failed to fetch scheduled actions:', { error: err });
        }
        const contentStoreAssets = (0, csi_to_store_docs_converter_1.mapCSIAssetsToStoreAssets)({
            csiAssets: csiAssets,
            contentSourceInstance,
            defaultLocaleCode
        });
        const assetMap = lodash_1.default.keyBy(contentStoreAssets, 'srcObjectId');
        this.logger.debug('loaded content source data', {
            contentSourceId,
            defaultLocaleCode,
            localesCount: (_g = locales === null || locales === void 0 ? void 0 : locales.length) !== null && _g !== void 0 ? _g : 0,
            modelCount: csiModels.length,
            documentCount: csiDocuments.length,
            assetCount: csiAssets.length
        });
        this.userLogger.info(`→ Loaded content source data: ${csiModels.length} ${(0, user_log_utils_1.pluralize)('model', csiModels.length)}, ` +
            `${csiDocuments.length} ${(0, user_log_utils_1.pluralize)('document', csiDocuments.length)} and ` +
            `${csiAssets.length} ${(0, user_log_utils_1.pluralize)('asset', csiAssets.length)}`);
        if (init || startWatchingContentUpdates) {
            // backward compatibility
            (_h = contentSourceInstance.startWatchingContentUpdates) === null || _h === void 0 ? void 0 : _h.call(contentSourceInstance, {
                getModelMap: () => {
                    var _a;
                    const contentSourceData = getContentSourceDataForCurrentInstance('getModelMap');
                    return (_a = contentSourceData === null || contentSourceData === void 0 ? void 0 : contentSourceData.csiModelMap) !== null && _a !== void 0 ? _a : {};
                },
                getDocument: ({ documentId }) => {
                    var _a;
                    const contentSourceData = getContentSourceDataForCurrentInstance('getDocument');
                    return (_a = contentSourceData === null || contentSourceData === void 0 ? void 0 : contentSourceData.csiDocumentMap) === null || _a === void 0 ? void 0 : _a[documentId];
                },
                getAsset: ({ assetId }) => {
                    var _a;
                    const contentSourceData = getContentSourceDataForCurrentInstance('getAsset');
                    return (_a = contentSourceData === null || contentSourceData === void 0 ? void 0 : contentSourceData.csiAssetMap) === null || _a === void 0 ? void 0 : _a[assetId];
                },
                onContentChange: cache.updateContent,
                onSchemaChange: cache.invalidateSchema
            });
        }
        return {
            id: contentSourceId,
            version: version,
            srcType: contentSourceInstance.getContentSourceType(),
            srcProjectId: contentSourceInstance.getProjectId(),
            instance: contentSourceInstance,
            destroyed: false,
            locales: locales,
            defaultLocaleCode: defaultLocaleCode,
            csiSchema: csiSchema,
            csiModels: csiModels,
            csiModelMap: csiModelMap,
            csiDocuments: csiDocuments,
            csiDocumentMap: csiDocumentMap,
            csiAssets: csiAssets,
            csiAssetMap: csiAssetMap,
            assets: contentStoreAssets,
            assetMap: assetMap,
            scheduledActions: scheduledActions,
            enabledFeatures: { scheduledActions: enabledScheduledActions }
        };
    }
    onContentChange(contentSourceId, contentChanges) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;
        // certain content changes, like preset changes are interpreted as schema changes
        let presetsUpdated = false;
        const contentChangesFull = {
            documents: (_a = contentChanges.documents) !== null && _a !== void 0 ? _a : [],
            assets: (_b = contentChanges.assets) !== null && _b !== void 0 ? _b : [],
            scheduledActions: (_c = contentChanges.scheduledActions) !== null && _c !== void 0 ? _c : [],
            deletedDocumentIds: (_d = contentChanges.deletedDocumentIds) !== null && _d !== void 0 ? _d : [],
            deletedAssetIds: (_e = contentChanges.deletedAssetIds) !== null && _e !== void 0 ? _e : [],
            deletedScheduledActionIds: (_f = contentChanges.deletedScheduledActionIds) !== null && _f !== void 0 ? _f : []
        };
        this.logger.debug('onContentChange', {
            contentSourceId,
            documentCount: contentChangesFull.documents.length,
            assetCount: contentChangesFull.assets.length,
            scheduledActionCount: contentChangesFull.scheduledActions.length,
            deletedDocumentCount: contentChangesFull.deletedDocumentIds.length,
            deletedAssetCount: contentChangesFull.deletedAssetIds.length,
            deletedScheduledActionCount: contentChangesFull.deletedScheduledActionIds.length
        });
        const result = {
            updatedDocuments: [],
            updatedAssets: [],
            updatedScheduledActions: [],
            deletedDocuments: [],
            deletedAssets: [],
            deletedScheduledActions: []
        };
        const contentSourceData = this.getContentSourceDataByIdOrThrow(contentSourceId);
        // update contentSourceData with deleted documents
        contentChangesFull.deletedDocumentIds.forEach((docId) => {
            var _a;
            // remove preset, make sure there is something to remove first because
            // were explicitly calling onContentChange from deletePreset as well
            if (this.presets[docId] && ((_a = contentSourceData.csiDocumentMap[docId]) === null || _a === void 0 ? void 0 : _a.modelName) === exports.StackbitPresetModelName) {
                presetsUpdated = true;
                const preset = this.presets[docId];
                const model = contentSourceData.modelMap[preset.modelName];
                delete this.presets[docId];
                if (model && model.presets) {
                    const presetIdIndex = model.presets.findIndex((presetId) => presetId === docId);
                    model.presets.splice(presetIdIndex, 1);
                }
            }
            // delete document from documents map
            delete contentSourceData.documentMap[docId];
            delete contentSourceData.csiDocumentMap[docId];
            // delete document from document array
            const index = contentSourceData.documents.findIndex((document) => document.srcObjectId === docId);
            if (index !== -1) {
                // the indexes of documents and csiDocuments are always the same as they are always updated at the same time
                contentSourceData.documents.splice(index, 1);
                contentSourceData.csiDocuments.splice(index, 1);
            }
            result.deletedDocuments.push({
                srcType: contentSourceData.srcType,
                srcProjectId: contentSourceData.srcProjectId,
                srcObjectId: docId
            });
        });
        // update contentSourceData with deleted assets
        contentChangesFull.deletedAssetIds.forEach((assetId) => {
            // delete document from asset map
            delete contentSourceData.assetMap[assetId];
            delete contentSourceData.csiAssetMap[assetId];
            // delete document from asset array
            const index = contentSourceData.assets.findIndex((asset) => asset.srcObjectId === assetId);
            if (index !== -1) {
                // the indexes of assets and csiAssets are always the same as they are always updated at the same time
                contentSourceData.assets.splice(index, 1);
                contentSourceData.csiAssets.splice(index, 1);
            }
            result.deletedAssets.push({
                srcType: contentSourceData.srcType,
                srcProjectId: contentSourceData.srcProjectId,
                srcObjectId: assetId
            });
        });
        // update contentSourceData with deleted scheduledActions
        contentChangesFull.deletedScheduledActionIds.forEach((scheduledActionId) => {
            // delete scheduledAction from scheduledActions array
            const index = contentSourceData.scheduledActions.findIndex((scheduledAction) => scheduledAction.id === scheduledActionId);
            if (index !== -1) {
                contentSourceData.scheduledActions.splice(index, 1);
            }
            result.deletedScheduledActions.push({
                srcType: contentSourceData.srcType,
                srcProjectId: contentSourceData.srcProjectId,
                scheduledActionId: scheduledActionId
            });
        });
        // map csi documents through stackbitConfig.mapDocuments
        let mappedDocs = contentChangesFull.documents;
        if ((_g = this.stackbitConfig) === null || _g === void 0 ? void 0 : _g.mapDocuments) {
            const csiDocumentsWithSource = contentChangesFull.documents.map((csiDocument) => ({
                srcType: contentSourceData.srcType,
                srcProjectId: contentSourceData.srcProjectId,
                ...csiDocument
            }));
            const modelsWithSource = contentSourceData.models.map((model) => {
                return {
                    srcType: contentSourceData.srcType,
                    srcProjectId: contentSourceData.srcProjectId,
                    ...model
                };
            });
            mappedDocs =
                (_k = (_j = (_h = this.stackbitConfig) === null || _h === void 0 ? void 0 : _h.mapDocuments) === null || _j === void 0 ? void 0 : _j.call(_h, {
                    documents: lodash_1.default.cloneDeep(csiDocumentsWithSource),
                    models: lodash_1.default.cloneDeep(modelsWithSource)
                })) !== null && _k !== void 0 ? _k : csiDocumentsWithSource;
        }
        // map csi documents and assets to content store documents and assets
        const documents = (0, csi_to_store_docs_converter_1.mapCSIDocumentsToStoreDocuments)({
            csiDocuments: mappedDocs,
            contentSourceInstance: contentSourceData.instance,
            modelMap: contentSourceData.modelMap,
            defaultLocaleCode: contentSourceData.defaultLocaleCode,
            assetSources: (_m = (_l = this.stackbitConfig) === null || _l === void 0 ? void 0 : _l.assetSources) !== null && _m !== void 0 ? _m : [],
            customActionRunStateMap: this.customActionRunStateMap,
            createConfigDelegate: (0, config_delegate_1.getCreateConfigDelegateThunk)({
                getContentSourceDataById: () => this.contentSourceDataById,
                logger: this.userLogger
            })
        });
        const assets = (0, csi_to_store_docs_converter_1.mapCSIAssetsToStoreAssets)({
            csiAssets: contentChangesFull.assets,
            contentSourceInstance: contentSourceData.instance,
            defaultLocaleCode: contentSourceData.defaultLocaleCode
        });
        // update contentSourceData with new or updated documents and assets
        Object.assign(contentSourceData.csiDocumentMap, lodash_1.default.keyBy(contentChangesFull.documents, 'id'));
        Object.assign(contentSourceData.csiAssetMap, lodash_1.default.keyBy(contentChangesFull.assets, 'id'));
        Object.assign(contentSourceData.documentMap, lodash_1.default.keyBy(documents, 'srcObjectId'));
        Object.assign(contentSourceData.assetMap, lodash_1.default.keyBy(assets, 'srcObjectId'));
        for (let idx = 0; idx < documents.length; idx++) {
            // the indexes of mapped documents and documents from changeEvent are the same
            const document = documents[idx];
            const csiDocument = contentChangesFull.documents[idx];
            const dataIndex = contentSourceData.documents.findIndex((existingDoc) => existingDoc.srcObjectId === document.srcObjectId);
            if (dataIndex === -1) {
                contentSourceData.documents.push(document);
                contentSourceData.csiDocuments.push(csiDocument);
            }
            else {
                contentSourceData.documents.splice(dataIndex, 1, document);
                contentSourceData.csiDocuments.splice(dataIndex, 1, csiDocument);
            }
            if (csiDocument.modelName === exports.StackbitPresetModelName) {
                presetsUpdated = true;
                const preset = (0, preset_utils_1.getPresetFromDocument)({
                    srcType: contentSourceData.srcType,
                    srcProjectId: contentSourceData.srcProjectId,
                    csiDocument,
                    csiAssetMap: contentSourceData.csiAssetMap,
                    logger: this.logger
                });
                if (preset) {
                    this.presets[csiDocument.id] = preset;
                    if (dataIndex === -1) {
                        //TODO recalculate assets as well
                        (_p = (_o = contentSourceData.modelMap[preset.modelName]) === null || _o === void 0 ? void 0 : _o.presets) === null || _p === void 0 ? void 0 : _p.push(csiDocument.id);
                    }
                }
            }
            result.updatedDocuments.push({
                srcType: contentSourceData.srcType,
                srcProjectId: contentSourceData.srcProjectId,
                srcObjectId: document.srcObjectId
            });
        }
        for (let idx = 0; idx < assets.length; idx++) {
            // the indexes of mapped assets and assets from changeEvent are the same
            const asset = assets[idx];
            const csiAsset = contentChangesFull.assets[idx];
            const index = contentSourceData.assets.findIndex((existingAsset) => existingAsset.srcObjectId === asset.srcObjectId);
            if (index === -1) {
                contentSourceData.assets.push(asset);
                contentSourceData.csiAssets.push(csiAsset);
            }
            else {
                // the indexes of assets and csiAssets are always the same as they are always updated at the same time
                contentSourceData.assets.splice(index, 1, asset);
                contentSourceData.csiAssets.splice(index, 1, csiAsset);
            }
            result.updatedAssets.push({
                srcType: contentSourceData.srcType,
                srcProjectId: contentSourceData.srcProjectId,
                srcObjectId: asset.srcObjectId
            });
        }
        const scheduledActions = contentChangesFull.scheduledActions;
        for (let idx = 0; idx < scheduledActions.length; idx++) {
            // the indexes of mapped assets and assets from changeEvent are the same
            const scheduledAction = scheduledActions[idx];
            const index = contentSourceData.scheduledActions.findIndex((existingScheduledAction) => existingScheduledAction.id === scheduledAction.id);
            if (index === -1) {
                contentSourceData.scheduledActions.push(scheduledAction);
            }
            else {
                contentSourceData.scheduledActions.splice(index, 1, scheduledAction);
            }
            result.updatedScheduledActions.push({
                srcType: contentSourceData.srcType,
                srcProjectId: contentSourceData.srcProjectId,
                scheduledActionId: scheduledAction.id
            });
        }
        return {
            contentChangeResult: result,
            presetsUpdated
        };
    }
    async processData({ stackbitConfig, configModels, presets, contentSourceRawDataArr }) {
        var _a, _b, _c, _d;
        this.logger.debug('processData');
        // Group models from all content sources by their names
        const csiModelGroups = contentSourceRawDataArr.reduce((modelGroups, csData) => {
            return csData.csiModels.reduce((modelGroups, model) => {
                if (!(model.name in modelGroups)) {
                    modelGroups[model.name] = [];
                }
                modelGroups[model.name].push({
                    srcType: csData.srcType,
                    srcProjectId: csData.srcProjectId,
                    ...model
                });
                return modelGroups;
            }, modelGroups);
        }, {});
        // Match config models to the group of content source models with the same name.
        // Then, match the config model to content source model by comparing srcType and
        // srcProjectId. If after the comparison, there are more than one model left,
        // log a warning and filter out that config model so it won't be merged with any
        // of the content source models.
        const nonMatchedModels = [];
        const configModelsByContentSourceId = configModels.reduce((modelGroups, configModel) => {
            const csiModels = csiModelGroups[configModel.name];
            if (!csiModels) {
                nonMatchedModels.push({
                    configModel,
                    matchedCSIModels: []
                });
                return modelGroups;
            }
            const matchedCSIModels = csiModels.filter((model) => {
                const matchesType = !configModel.srcType || model.srcType === configModel.srcType;
                const matchesId = !configModel.srcProjectId || model.srcProjectId === configModel.srcProjectId;
                return matchesType && matchesId;
            });
            if (matchedCSIModels.length !== 1) {
                nonMatchedModels.push({
                    configModel,
                    matchedCSIModels
                });
                return modelGroups;
            }
            const contentSource = matchedCSIModels[0];
            const contentSourceId = (0, content_store_utils_1.getContentSourceId)(contentSource.srcType, contentSource.srcProjectId);
            (0, utils_1.append)(modelGroups, contentSourceId, configModel);
            return modelGroups;
        }, {});
        // Log model matching warnings using user logger
        for (const { configModel, matchedCSIModels } of nonMatchedModels) {
            let configModelMessage = `model name: '${configModel.name}'`;
            if (configModel.srcType) {
                configModelMessage += `, srcType: '${configModel.srcType}'`;
            }
            if (configModel.srcProjectId) {
                configModelMessage += `, srcProjectId: '${configModel.srcProjectId}'`;
            }
            configModelMessage = configModelMessage + ` defined in stackbit config`;
            let contentSourceModelsMessage;
            if (matchedCSIModels.length) {
                const matchesModelsMessage = matchedCSIModels.map((model) => `srcType: '${model.srcType}', srcProjectId: '${model.srcProjectId}'`).join('; ');
                contentSourceModelsMessage = ` matches more that 1 model in the following content sources: ${matchesModelsMessage}`;
            }
            else {
                contentSourceModelsMessage = ' does not match any content source model';
            }
            this.userLogger.warn(configModelMessage + contentSourceModelsMessage);
        }
        const modelsWithSource = contentSourceRawDataArr.reduce((accum, csData) => {
            var _a;
            const contentSourceId = (0, content_store_utils_1.getContentSourceId)(csData.srcType, csData.srcProjectId);
            const mergedModels = (0, sdk_1.mergeConfigModelsWithExternalModels)({
                configModels: (_a = configModelsByContentSourceId[contentSourceId]) !== null && _a !== void 0 ? _a : [],
                externalModels: csData.csiModels,
                logger: this.userLogger
            });
            const modelsWithSource = mergedModels.map((model) => {
                return {
                    srcType: csData.srcType,
                    srcProjectId: csData.srcProjectId,
                    ...model
                };
            });
            return accum.concat(modelsWithSource);
        }, []);
        // TODO: Is there a better way than deep cloning objects before passing them to user methods?
        //   Not cloning mutable objects will break the internal state if user mutates the objects.
        const mappedModels = (_b = (_a = stackbitConfig === null || stackbitConfig === void 0 ? void 0 : stackbitConfig.mapModels) === null || _a === void 0 ? void 0 : _a.call(stackbitConfig, { models: lodash_1.default.cloneDeep(modelsWithSource) })) !== null && _b !== void 0 ? _b : modelsWithSource;
        const normalizedModels = (0, model_utils_1.normalizeModels)({ models: mappedModels, logger: this.userLogger });
        const validatedModels = (0, model_utils_1.validateModels)({ models: normalizedModels, logger: this.userLogger });
        const modelsWithPresetsIds = (0, sdk_1.extendModelsWithPresetsIds)({ models: validatedModels, presets });
        const { models } = await this.handleConfigAssets({ models: modelsWithPresetsIds });
        let documentMapByContentSource = null;
        if (stackbitConfig === null || stackbitConfig === void 0 ? void 0 : stackbitConfig.mapDocuments) {
            const csiDocumentsWithSource = contentSourceRawDataArr.reduce((accum, csData) => {
                const csiDocumentsWithSource = csData.csiDocuments.map((csiDocument) => ({
                    srcType: csData.srcType,
                    srcProjectId: csData.srcProjectId,
                    ...csiDocument
                }));
                return accum.concat(csiDocumentsWithSource);
            }, []);
            // TODO: Is there a better way than deep cloning objects before passing them to user methods?
            //   Not cloning mutable objects will break the internal state if user mutates the objects.
            const mappedDocs = (_d = (_c = stackbitConfig === null || stackbitConfig === void 0 ? void 0 : stackbitConfig.mapDocuments) === null || _c === void 0 ? void 0 : _c.call(stackbitConfig, {
                documents: lodash_1.default.cloneDeep(csiDocumentsWithSource),
                models: lodash_1.default.cloneDeep(models)
            })) !== null && _d !== void 0 ? _d : csiDocumentsWithSource;
            documentMapByContentSource = (0, content_store_utils_1.groupDocumentsByContentSource)({ documents: mappedDocs });
        }
        const modelMapByContentSource = (0, content_store_utils_1.groupModelsByContentSource)({ models: models });
        const contentSourceDataArr = contentSourceRawDataArr.map((csData) => {
            var _a, _b;
            const modelMap = lodash_1.default.get(modelMapByContentSource, [csData.srcType, csData.srcProjectId], {});
            const csiDocuments = documentMapByContentSource
                ? lodash_1.default.get(documentMapByContentSource, [csData.srcType, csData.srcProjectId], [])
                : csData.csiDocuments;
            const documents = (0, csi_to_store_docs_converter_1.mapCSIDocumentsToStoreDocuments)({
                csiDocuments: csiDocuments,
                contentSourceInstance: csData.instance,
                modelMap: modelMap,
                defaultLocaleCode: csData.defaultLocaleCode,
                assetSources: (_b = (_a = this.stackbitConfig) === null || _a === void 0 ? void 0 : _a.assetSources) !== null && _b !== void 0 ? _b : [],
                customActionRunStateMap: this.customActionRunStateMap,
                createConfigDelegate: (0, config_delegate_1.getCreateConfigDelegateThunk)({
                    getContentSourceDataById: () => this.contentSourceDataById,
                    logger: this.userLogger
                })
            });
            return {
                ...csData,
                models: Object.values(modelMap),
                modelMap,
                documents,
                documentMap: lodash_1.default.keyBy(documents, 'srcObjectId')
            };
        });
        this.logger.debug('processData finished');
        return lodash_1.default.keyBy(contentSourceDataArr, 'id');
    }
    getContentSourceMeta() {
        return lodash_1.default.reduce(this.contentSourceDataById, (result, contentSourceData) => {
            var _a;
            return result.concat({
                srcType: contentSourceData.srcType,
                srcProjectId: contentSourceData.srcProjectId,
                srcVersion: contentSourceData.version.contentSourceVersion,
                csiVersion: contentSourceData.version.interfaceVersion,
                supportsScheduledActions: (_a = contentSourceData === null || contentSourceData === void 0 ? void 0 : contentSourceData.enabledFeatures.scheduledActions) !== null && _a !== void 0 ? _a : false
            });
        }, []);
    }
    getAssetSources() {
        return (0, asset_sources_utils_1.getAssetSourcesForClient)(this.stackbitConfig);
    }
    getModels() {
        return lodash_1.default.reduce(this.contentSourceDataById, (result, contentSourceData) => {
            const contentSourceType = contentSourceData.instance.getContentSourceType();
            const srcProjectId = contentSourceData.instance.getProjectId();
            const filteredModels = lodash_1.default.omitBy(contentSourceData.modelMap, (model) => model.name === exports.StackbitPresetModelName);
            const mappedModels = (0, custom_actions_1.stripModelActions)({ modelMap: filteredModels });
            // if `projectId` is number (even as string) e.g., '1234', _.set() will create an array of length 1235 and insert the item at the end.
            // _.setWith(..., Object) ensures the values are always created as object keys, not as array indexes.
            lodash_1.default.setWith(result, [contentSourceType, srcProjectId], mappedModels, Object);
            lodash_1.default.setWith(result, [contentSourceType, srcProjectId, '__image_model'], common_schema_1.IMAGE_MODEL, Object);
            return result;
        }, {});
    }
    getLocales() {
        return lodash_1.default.reduce(this.contentSourceDataById, (result, contentSourceData) => {
            var _a, _b;
            return result.concat({
                srcType: contentSourceData.srcType,
                srcProjectId: contentSourceData.srcProjectId,
                locales: (_b = (_a = contentSourceData.locales) === null || _a === void 0 ? void 0 : _a.map((locale) => locale.code)) !== null && _b !== void 0 ? _b : [],
                defaultLocale: contentSourceData.defaultLocaleCode
            });
        }, []);
    }
    async getGlobalActions({ pageUrl, user, locale, currentPageDocument }) {
        return (0, custom_actions_1.getGlobalAndBulkAPIActions)({
            stackbitConfig: this.stackbitConfig,
            customActionRunStateMap: this.customActionRunStateMap,
            contentSourceDataById: this.contentSourceDataById,
            userLogger: this.userLogger,
            locale,
            pageUrl,
            user,
            currentPageDocument
        });
    }
    async getCustomActions(getActionRequest) {
        return (0, custom_actions_1.resolveCustomActionsById)({
            getActionRequest,
            customActionRunStateMap: this.customActionRunStateMap,
            contentSourceDataById: this.contentSourceDataById,
            stackbitConfig: this.stackbitConfig,
            userLogger: this.userLogger
        });
    }
    async runCustomAction(runActionRequest) {
        this.onActionStateChangeCallback({
            actionId: runActionRequest.actionId,
            actionName: runActionRequest.actionName,
            actionType: runActionRequest.actionType,
            state: 'running'
        });
        (0, custom_actions_1.runCustomAction)({
            runActionRequest: runActionRequest,
            contentSourceDataById: this.contentSourceDataById,
            customActionRunStateMap: this.customActionRunStateMap,
            userLogger: this.userLogger,
            stackbitConfig: this.stackbitConfig
        }).then((actionStateChange) => {
            this.onActionStateChangeCallback(actionStateChange);
        });
    }
    getPresets({ locale } = {}) {
        var _a;
        if (!this.presets || !locale) {
            return (_a = this.presets) !== null && _a !== void 0 ? _a : {};
        }
        return lodash_1.default.pickBy(this.presets, (preset) => !preset.locale || preset.locale === locale);
    }
    getContentSourceEnvironment({ srcProjectId, srcType }) {
        const contentSourceId = (0, content_store_utils_1.getContentSourceId)(srcType, srcProjectId);
        const contentSourceData = this.getContentSourceDataByIdOrThrow(contentSourceId);
        return contentSourceData.instance.getProjectEnvironment();
    }
    usesContentSourcePresets() {
        return Boolean(this.presetsContentSource);
    }
    async hasAccess({ srcType, srcProjectId, user }) {
        let contentSourceDataArr;
        if (srcType && srcProjectId) {
            const contentSourceId = (0, content_store_utils_1.getContentSourceId)(srcType, srcProjectId);
            const contentSourceData = this.getContentSourceDataByIdOrThrow(contentSourceId);
            contentSourceDataArr = [contentSourceData];
        }
        else {
            contentSourceDataArr = Object.values(this.contentSourceDataById);
        }
        return (0, utils_1.reducePromise)(contentSourceDataArr, async (accum, contentSourceData) => {
            const srcType = contentSourceData.srcType;
            const srcProjectId = contentSourceData.srcProjectId;
            const userContext = (0, content_store_utils_1.getUserContextForSrcType)(srcType, user);
            const result = await contentSourceData.instance.hasAccess({ userContext });
            return {
                hasConnection: accum.hasConnection && result.hasConnection,
                hasPermissions: accum.hasPermissions && result.hasPermissions,
                contentSources: accum.contentSources.concat({
                    srcType,
                    srcProjectId,
                    ...result
                })
            };
        }, {
            hasConnection: true,
            hasPermissions: true,
            contentSources: []
        });
    }
    hasChanges({ srcType, srcProjectId, documents }) {
        let result;
        if (srcType && srcProjectId) {
            const contentSourceId = (0, content_store_utils_1.getContentSourceId)(srcType, srcProjectId);
            const contentSourceData = this.getContentSourceDataByIdOrThrow(contentSourceId);
            result = [...contentSourceData.documents, ...contentSourceData.assets];
        }
        else if (documents && documents.length > 0) {
            const documentsBySourceId = lodash_1.default.groupBy(documents, (document) => (0, content_store_utils_1.getContentSourceId)(document.srcType, document.srcProjectId));
            result = lodash_1.default.reduce(documentsBySourceId, (result, documents, contentSourceId) => {
                const contentSourceData = this.getContentSourceDataByIdOrThrow(contentSourceId);
                for (const document of documents) {
                    if (document.srcObjectId in contentSourceData.documentMap) {
                        result.push(contentSourceData.documentMap[document.srcObjectId]);
                    }
                    else if (document.srcObjectId in contentSourceData.assetMap) {
                        result.push(contentSourceData.assetMap[document.srcObjectId]);
                    }
                }
                return result;
            }, []);
        }
        else {
            result = lodash_1.default.reduce(this.contentSourceDataById, (result, contentSourceData) => {
                return result.concat(contentSourceData.documents, contentSourceData.assets);
            }, []);
        }
        const changedDocuments = result.filter((document) => document.status === 'added' || document.status === 'modified');
        return {
            hasChanges: !lodash_1.default.isEmpty(changedDocuments),
            changedObjects: changedDocuments.map((item) => ({
                srcType: item.srcType,
                srcProjectId: item.srcProjectId,
                srcObjectId: item.srcObjectId
            }))
        };
    }
    getSiteMapEntries({ locale } = {}) {
        const siteMapEntries = lodash_1.default.reduce(this.siteMapEntryGroups, (accum, siteMapEntryGroup) => {
            return lodash_1.default.reduce(siteMapEntryGroup, (accum, siteMapEntry) => {
                if (!siteMapEntry.label) {
                    const fieldLabelValue = (0, site_map_1.getDocumentFieldLabelValueForSiteMapEntry)({
                        siteMapEntry,
                        locale,
                        contentSourceDataById: this.contentSourceDataById
                    });
                    siteMapEntry = {
                        ...siteMapEntry,
                        label: fieldLabelValue !== null && fieldLabelValue !== void 0 ? fieldLabelValue : siteMapEntry.urlPath
                    };
                }
                accum.push(siteMapEntry);
                return accum;
            }, accum);
        }, []);
        return lodash_1.default.isEmpty(locale) ? siteMapEntries : siteMapEntries.filter((siteMapEntry) => !siteMapEntry.locale || siteMapEntry.locale === locale);
    }
    getTreeViews() {
        return this.treeViews;
    }
    getSiteMapEntriesForDocument({ srcType, srcProjectId, srcDocumentId, locale }) {
        const key = (0, site_map_1.getSiteMapGroupKeyForDocument)({
            srcType: srcType,
            srcProjectId: srcProjectId,
            srcDocumentId: srcDocumentId
        });
        const siteMapEntryGroup = this.siteMapEntryGroups[key];
        const siteMapEntries = lodash_1.default.values(siteMapEntryGroup);
        return lodash_1.default.isEmpty(locale) ? siteMapEntries : siteMapEntries.filter((siteMapEntry) => !siteMapEntry.locale || siteMapEntry.locale === locale);
    }
    getDocument({ srcDocumentId, srcProjectId, srcType }) {
        const contentSourceId = (0, content_store_utils_1.getContentSourceId)(srcType, srcProjectId);
        const contentSourceData = this.getContentSourceDataByIdOrThrow(contentSourceId);
        return contentSourceData.documentMap[srcDocumentId];
    }
    getDocumentsByContext({ context, srcProjectId, srcType }) {
        const contentSourcesData = (0, content_store_utils_1.findContentSourcesDataForTypeOrId)({
            contentSourceDataById: this.contentSourceDataById,
            srcType,
            srcProjectId
        });
        return lodash_1.default.reduce(contentSourcesData, (documents, csData) => {
            const matchingDocuments = lodash_1.default.filter(csData.csiDocuments, { context })
                .map((document) => csData.documentMap[document.id])
                .filter(Boolean);
            return [...documents, ...matchingDocuments];
        }, []);
    }
    getDocuments({ locale } = {}) {
        return lodash_1.default.reduce(this.contentSourceDataById, (documents, contentSourceData) => {
            const currentDocuments = lodash_1.default.isEmpty(locale)
                ? contentSourceData.documents
                : contentSourceData.documents.filter((document) => !document.locale || document.locale === locale);
            const filteredDocuments = currentDocuments.filter((document) => document.srcModelName !== exports.StackbitPresetModelName);
            return documents.concat(filteredDocuments);
        }, []);
    }
    getAsset({ srcAssetId, srcProjectId, srcType }) {
        const contentSourceId = (0, content_store_utils_1.getContentSourceId)(srcType, srcProjectId);
        const contentSourceData = this.getContentSourceDataByIdOrThrow(contentSourceId);
        return contentSourceData.assetMap[srcAssetId];
    }
    getAssets({ locale }) {
        return lodash_1.default.reduce(this.contentSourceDataById, (assets, contentSourceData) => {
            const currentAssets = lodash_1.default.isEmpty(locale)
                ? contentSourceData.assets
                : contentSourceData.assets.filter((asset) => !asset.locale || asset.locale === locale);
            return assets.concat(currentAssets);
        }, []);
    }
    getLocalizedApiObjects({ locale, objectIds }) {
        const hasExplicitLocale = !lodash_1.default.isEmpty(locale);
        return lodash_1.default.reduce(this.contentSourceDataById, (objects, contentSourceData) => {
            let documents = objectIds
                ? contentSourceData.documents.filter((document) => objectIds.includes(document.srcObjectId))
                : contentSourceData.documents;
            documents = hasExplicitLocale ? documents.filter((document) => !document.locale || document.locale === locale) : documents;
            let assets = objectIds ? contentSourceData.assets.filter((asset) => objectIds.includes(asset.srcObjectId)) : contentSourceData.assets;
            assets = hasExplicitLocale ? assets.filter((asset) => !asset.locale || asset.locale === locale) : assets;
            const currentLocale = locale !== null && locale !== void 0 ? locale : contentSourceData.defaultLocaleCode;
            const filteredDocuments = documents.filter((document) => document.srcModelName !== exports.StackbitPresetModelName);
            const documentObjects = (0, store_to_api_docs_converter_1.mapDocumentsToLocalizedApiObjects)({
                documents: filteredDocuments,
                locale: currentLocale,
                delegate: (0, config_delegate_1.createConfigDelegate)({ contentSourceDataById: this.contentSourceDataById, logger: this.userLogger })
            });
            const imageObjects = (0, store_to_api_docs_converter_1.mapAssetsToLocalizedApiImages)(assets, this.staticAssetsPublicPath, currentLocale);
            return objects.concat(documentObjects, imageObjects);
        }, []);
    }
    getApiAssets({ srcType, srcProjectId, pageSize = 20, pageNum = 1, searchQuery } = {}) {
        let assets;
        if (srcProjectId && srcType) {
            const contentSourceId = (0, content_store_utils_1.getContentSourceId)(srcType, srcProjectId);
            const contentSourceData = this.getContentSourceDataByIdOrThrow(contentSourceId);
            assets = (0, store_to_api_docs_converter_1.mapStoreAssetsToAPIAssets)(contentSourceData.assets, this.staticAssetsPublicPath, contentSourceData.defaultLocaleCode);
        }
        else {
            assets = lodash_1.default.reduce(this.contentSourceDataById, (result, contentSourceData) => {
                const assets = (0, store_to_api_docs_converter_1.mapStoreAssetsToAPIAssets)(contentSourceData.assets, this.staticAssetsPublicPath, contentSourceData.defaultLocaleCode);
                return result.concat(assets);
            }, []);
        }
        let filteredFiles = assets;
        if (searchQuery) {
            const sanitizedSearchQuery = (0, sanitize_filename_1.default)(searchQuery).toLowerCase();
            filteredFiles = assets.filter((asset) => asset.fileName && path_1.default.basename(asset.fileName).toLowerCase().includes(sanitizedSearchQuery));
        }
        const sortedAssets = lodash_1.default.orderBy(filteredFiles, ['fileName'], ['asc']);
        const skip = (pageNum - 1) * pageSize;
        const totalPages = Math.ceil(filteredFiles.length / pageSize);
        const pagesAssets = sortedAssets.slice(skip, skip + pageSize);
        return {
            assets: pagesAssets,
            pageSize: pageSize,
            pageNum: pageNum,
            totalPages: totalPages
        };
    }
    async createAndLinkDocument({ srcType, srcProjectId, srcDocumentId, fieldPath, modelName, refSrcType, refProjectId, object, index, locale, user }) {
        this.logger.debug('createAndLinkDocument', { srcType, srcProjectId, srcDocumentId, fieldPath, modelName, refSrcType, refProjectId, index, locale });
        const contentSourceId = (0, content_store_utils_1.getContentSourceId)(srcType, srcProjectId);
        const contentSourceData = this.getContentSourceDataByIdOrThrow(contentSourceId);
        // get the document that is being updated
        const document = contentSourceData.documentMap[srcDocumentId];
        const csiDocument = contentSourceData.csiDocumentMap[srcDocumentId];
        if (!document || !csiDocument) {
            throw new Error(`Document not found: '${srcDocumentId}'. Source: '${contentSourceData.id}'.`);
        }
        const modelMap = contentSourceData.modelMap;
        const csiModelMap = contentSourceData.csiModelMap;
        // get the 'reference' model field in the updated document that will be used to link the new document
        locale = locale !== null && locale !== void 0 ? locale : contentSourceData.defaultLocaleCode;
        const modelField = (0, field_path_utils_1.getModelFieldAtFieldPath)(document, fieldPath, modelMap, locale);
        const csiModelField = (0, field_path_utils_1.getModelFieldAtFieldPath)(document, fieldPath, csiModelMap, locale);
        if (!modelField || !csiModelField) {
            throw Error(`Field path not found:'${fieldPath.join('.')}'.`);
        }
        const fieldProps = modelField.type === 'list' ? modelField.items : modelField;
        const csiFieldProps = csiModelField.type === 'list' ? csiModelField.items : csiModelField;
        if (fieldProps.type !== 'reference' && fieldProps.type !== 'cross-reference') {
            throw new Error(`createAndLinkDocument can only be used on fields of type reference at field path: '${fieldPath.join('.')}'`);
        }
        // get the model name for the new document
        if (!modelName && fieldProps.models.length === 1) {
            if (fieldProps.type === 'reference') {
                modelName = fieldProps.models[0];
            }
            else if (fieldProps.type === 'cross-reference') {
                modelName = fieldProps.models[0].modelName;
            }
        }
        if (!modelName) {
            throw new Error(`modelName is required for createAndLinkDocument. Field path: '${fieldPath.join('.')}'.`);
        }
        if (fieldProps.type === 'reference') {
            refSrcType = srcType;
            refProjectId = srcProjectId;
        }
        else if (!refSrcType || !refProjectId) {
            throw new Error(`refSrcType and refProjectId are required for linking fields of type cross-reference for field path: '${fieldPath.join('.')}'.`);
        }
        // create the new document
        const result = await this.createDocument({
            object: object,
            srcProjectId: refProjectId,
            srcType: refSrcType,
            modelName: modelName,
            locale: locale,
            user: user
        });
        // update the document by linking the field to the created document
        const userContext = (0, content_store_utils_1.getUserContextForSrcType)(srcType, user);
        let field;
        if (fieldProps.type === 'reference') {
            field = {
                type: 'reference',
                refType: 'document',
                refId: result.srcDocumentId
            };
        }
        else {
            if (!(0, types_1.isOneOfFieldTypes)(csiFieldProps.type, ['string', 'text', 'json', 'cross-reference'])) {
                throw new Error(`Invalid type for cross-reference field: ${csiFieldProps.type}. Must be one of: string, text, json, cross-reference. Field path: '${fieldPath.join('.')}'.`);
            }
            field = (0, content_store_utils_1.updateOperationValueFieldWithCrossReference)(csiFieldProps.type, {
                refId: result.srcDocumentId,
                refSrcType: refSrcType,
                refProjectId: refProjectId
            });
        }
        const operations = [
            modelField.type === 'list'
                ? {
                    opType: 'insert',
                    fieldPath: fieldPath,
                    modelField: csiModelField,
                    locale: locale,
                    index: index,
                    item: field
                }
                : {
                    opType: 'set',
                    fieldPath: fieldPath,
                    modelField: csiModelField,
                    locale: locale,
                    field: field
                }
        ];
        await this.updateDocumentHooked({
            updateDocumentOptions: {
                document: csiDocument,
                modelMap: csiModelMap,
                userContext: userContext,
                operations: operations
            },
            contentSourceData: contentSourceData,
            user: user
        });
        return { srcDocumentId: srcDocumentId, createdDocumentId: result.srcDocumentId };
    }
    async createPreset({ preset, thumbnailAsset, user }) {
        var _a;
        if (!this.presetsContentSource) {
            throw new Error('Error saving preset: No content source available.');
        }
        let thumbnail;
        if (thumbnailAsset) {
            const assets = await this.uploadAssets({
                srcType: this.presetsContentSource.getContentSourceType(),
                srcProjectId: this.presetsContentSource.getProjectId(),
                assets: [thumbnailAsset],
                user
            });
            thumbnail = (_a = assets[0]) === null || _a === void 0 ? void 0 : _a.objectId;
        }
        const contentSourceData = this.getContentSourceDataByIdOrThrow((0, content_store_utils_1.getContentSourceIdForContentSource)(this.presetsContentSource));
        const document = await this.createDocument({
            srcType: this.presetsContentSource.getContentSourceType(),
            srcProjectId: this.presetsContentSource.getProjectId(),
            modelName: exports.StackbitPresetModelName,
            object: {
                ...(0, preset_utils_1.getDocumentObjectFromPreset)(preset, contentSourceData.modelMap[exports.StackbitPresetModelName]),
                thumbnail
            },
            user
        });
        return { srcDocumentId: document.srcDocumentId };
    }
    async deletePreset({ presetId, user }) {
        if (!this.presetsContentSource) {
            throw new Error('Error deleting preset: No content source available.');
        }
        await this.deleteDocument({
            srcType: this.presetsContentSource.getContentSourceType(),
            srcProjectId: this.presetsContentSource.getProjectId(),
            srcDocumentId: presetId,
            user
        });
        // we delete presets immediately because some CMSs don't notify us
        // when documents have been deleted.
        const contentSourceId = (0, content_store_utils_1.getContentSourceIdForContentSource)(this.presetsContentSource);
        this.pushContentSourceEvent({
            eventName: ContentStoreEventType.ContentSourceContentChange,
            contentSourceId: contentSourceId,
            contentChanges: {
                documents: [],
                deletedDocumentIds: [presetId],
                assets: [],
                deletedAssetIds: []
            }
        });
        await this.processContentStoreEvents();
    }
    async uploadAndLinkAsset({ srcType, srcProjectId, srcDocumentId, fieldPath, asset, index, locale, user }) {
        this.logger.debug('uploadAndLinkAsset', { srcType, srcProjectId, srcDocumentId, fieldPath, index, locale });
        // get the document that is being updated
        const contentSourceId = (0, content_store_utils_1.getContentSourceId)(srcType, srcProjectId);
        const contentSourceData = this.getContentSourceDataByIdOrThrow(contentSourceId);
        const document = contentSourceData.documentMap[srcDocumentId];
        const csiDocument = contentSourceData.csiDocumentMap[srcDocumentId];
        if (!document || !csiDocument) {
            throw new Error(`Document not found: '${srcDocumentId}'. Source: '${contentSourceData.id}'.`);
        }
        const csiModelMap = contentSourceData.csiModelMap;
        // get the 'reference' model field in the updated document that will be used to link the new asset
        locale = locale !== null && locale !== void 0 ? locale : contentSourceData.defaultLocaleCode;
        const csiModelField = (0, field_path_utils_1.getModelFieldAtFieldPath)(document, fieldPath, csiModelMap, locale);
        if (!csiModelField) {
            throw Error(`Field path not found: '${fieldPath.join('.')}'.`);
        }
        const fieldProps = csiModelField.type === 'list' ? csiModelField.items : csiModelField;
        if (fieldProps.type !== 'reference' && fieldProps.type !== 'image') {
            throw Error(`uploadAndLinkAsset can only be used on fields of type: reference, image. Field path: '${fieldPath.join('.')}'.`);
        }
        // upload the new asset
        const userContext = (0, content_store_utils_1.getUserContextForSrcType)(srcType, user);
        const result = await contentSourceData.instance.uploadAsset({
            url: asset.url,
            fileName: asset.metadata.name,
            mimeType: asset.metadata.type,
            locale: locale,
            userContext: userContext
        });
        // update the document by linking the field to the created asset
        const field = {
            type: 'reference',
            refType: 'asset',
            refId: result.id
        };
        const operations = [
            csiModelField.type === 'list'
                ? {
                    opType: 'insert',
                    fieldPath: fieldPath,
                    modelField: csiModelField,
                    locale: locale,
                    index: index,
                    item: field
                }
                : {
                    opType: 'set',
                    fieldPath: fieldPath,
                    modelField: csiModelField,
                    locale: locale,
                    field: field
                }
        ];
        await this.updateDocumentHooked({
            updateDocumentOptions: {
                document: csiDocument,
                modelMap: csiModelMap,
                userContext: userContext,
                operations: operations
            },
            contentSourceData: contentSourceData,
            user: user
        });
        return { srcDocumentId: srcDocumentId };
    }
    async createDocument({ srcType, srcProjectId, modelName, object, locale, defaultLocaleDocumentId, user }) {
        var _a, _b, _c;
        this.logger.debug('createDocument', { srcType, srcProjectId, modelName, locale });
        (0, user_log_utils_1.logCreateDocument)({ userLogger: this.userLogger, srcType, srcProjectId, modelName, locale, object });
        const contentSourceId = (0, content_store_utils_1.getContentSourceId)(srcType, srcProjectId);
        const contentSourceData = this.getContentSourceDataByIdOrThrow(contentSourceId);
        const resolvedLocale = locale !== null && locale !== void 0 ? locale : contentSourceData.defaultLocaleCode;
        const csiModel = contentSourceData.csiModelMap[modelName];
        if (!csiModel) {
            throw new Error(`Error creating document: model not found: '${modelName}' (source: ${contentSourceId}).`);
        }
        if ((_a = this.stackbitConfig) === null || _a === void 0 ? void 0 : _a.onContentCreate) {
            object = await this.stackbitConfig.onContentCreate({
                object: object !== null && object !== void 0 ? object : {},
                locale,
                model: {
                    srcType: contentSourceData.srcType,
                    srcProjectId: contentSourceData.srcProjectId,
                    ...csiModel
                },
                ...(0, config_delegate_1.createConfigDelegate)({
                    contentSourceDataById: this.contentSourceDataById,
                    logger: this.userLogger
                })
            });
        }
        const result = await (0, create_update_csi_docs_1.createDocumentRecursively)({
            object,
            locale: resolvedLocale,
            userLogger: this.userLogger,
            modelName,
            contentSourceId,
            contentSourceDataById: this.contentSourceDataById,
            assetSources: (_c = (_b = this.stackbitConfig) === null || _b === void 0 ? void 0 : _b.assetSources) !== null && _c !== void 0 ? _c : [],
            createDocument: this.getCreateDocumentThunk({
                defaultLocaleDocumentId,
                user
            })
        });
        this.logger.debug('created document', { srcType, srcProjectId, srcDocumentId: result.documentId, modelName });
        return { srcDocumentId: result.documentId };
    }
    async updateDocument({ srcType, srcProjectId, srcDocumentId, updateOperations, user }) {
        this.logger.debug('updateDocument');
        (0, user_log_utils_1.logUpdateDocument)({ userLogger: this.userLogger, srcType, srcProjectId, srcDocumentId, updateOperations });
        const contentSourceId = (0, content_store_utils_1.getContentSourceId)(srcType, srcProjectId);
        const contentSourceData = this.getContentSourceDataByIdOrThrow(contentSourceId);
        const userContext = (0, content_store_utils_1.getUserContextForSrcType)(srcType, user);
        const document = contentSourceData.documentMap[srcDocumentId];
        const csiDocument = contentSourceData.csiDocumentMap[srcDocumentId];
        if (!document || !csiDocument) {
            throw new Error(`Document not found: '${srcDocumentId}' (Source: '${contentSourceData.id}'.)`);
        }
        const modelMap = contentSourceData.modelMap;
        const csiModelMap = contentSourceData.csiModelMap;
        const documentModelName = document.srcModelName;
        const csiModel = csiModelMap[documentModelName];
        if (!csiModel) {
            throw new Error(`Error updating document: could not find document model '${documentModelName}'.`);
        }
        const operations = await (0, utils_1.mapPromise)(updateOperations, async (updateOperation) => {
            var _a, _b, _c, _d, _e;
            const locale = (_a = updateOperation.locale) !== null && _a !== void 0 ? _a : contentSourceData.defaultLocaleCode;
            const modelField = (0, field_path_utils_1.getModelFieldAtFieldPath)(document, updateOperation.fieldPath, modelMap, locale);
            const csiModelField = (0, field_path_utils_1.getModelFieldAtFieldPath)(document, updateOperation.fieldPath, csiModelMap, locale);
            switch (updateOperation.opType) {
                case 'set': {
                    const field = await (0, create_update_csi_docs_1.convertOperationField)({
                        operationField: updateOperation.field,
                        fieldPath: [csiModel.name, ...updateOperation.fieldPath],
                        modelField,
                        csiModelField,
                        locale,
                        modelMap,
                        csiModelMap,
                        contentSourceId,
                        contentSourceDataById: this.contentSourceDataById,
                        assetSources: (_c = (_b = this.stackbitConfig) === null || _b === void 0 ? void 0 : _b.assetSources) !== null && _c !== void 0 ? _c : [],
                        createDocument: this.getCreateDocumentThunk({ user }),
                        userLogger: this.userLogger
                    });
                    return {
                        ...updateOperation,
                        modelField: csiModelField,
                        field
                    };
                }
                case 'unset':
                    return {
                        ...updateOperation,
                        modelField: csiModelField
                    };
                case 'insert': {
                    if (modelField.type !== 'list' || csiModelField.type !== 'list') {
                        throw new Error('Invalid operation. Insert operations can be performed on list fields only.');
                    }
                    const item = (await (0, create_update_csi_docs_1.convertOperationField)({
                        operationField: updateOperation.item,
                        fieldPath: [csiModel.name, ...updateOperation.fieldPath],
                        modelField: modelField.items,
                        csiModelField: csiModelField.items,
                        locale,
                        modelMap,
                        csiModelMap,
                        contentSourceId,
                        contentSourceDataById: this.contentSourceDataById,
                        assetSources: (_e = (_d = this.stackbitConfig) === null || _d === void 0 ? void 0 : _d.assetSources) !== null && _e !== void 0 ? _e : [],
                        createDocument: this.getCreateDocumentThunk({ user }),
                        userLogger: this.userLogger
                    }));
                    return {
                        ...updateOperation,
                        modelField: csiModelField,
                        item
                    };
                }
                case 'remove':
                    if (csiModelField.type !== 'list') {
                        throw new Error('Invalid operation. Remove operations can be performed on list fields only.');
                    }
                    return {
                        ...updateOperation,
                        modelField: csiModelField
                    };
                case 'reorder':
                    if (csiModelField.type !== 'list') {
                        throw new Error('Invalid operation. Reorder operations can be performed on list fields only.');
                    }
                    return {
                        ...updateOperation,
                        modelField: csiModelField
                    };
            }
        });
        await this.updateDocumentHooked({
            updateDocumentOptions: {
                document: csiDocument,
                modelMap: csiModelMap,
                userContext,
                operations
            },
            contentSourceData: contentSourceData,
            user: user
        });
        return { srcDocumentId: srcDocumentId };
    }
    async duplicateDocument({ srcType, srcProjectId, srcDocumentId, object, locale, user }) {
        var _a, _b, _c, _d, _e, _f;
        this.logger.debug('duplicateDocument', { srcType, srcProjectId, srcDocumentId, locale });
        (0, user_log_utils_1.logDuplicateDocument)({ userLogger: this.userLogger, srcType, srcProjectId, srcDocumentId, locale });
        const contentSourceId = (0, content_store_utils_1.getContentSourceId)(srcType, srcProjectId);
        const contentSourceData = this.getContentSourceDataByIdOrThrow(contentSourceId);
        const document = contentSourceData.documentMap[srcDocumentId];
        if (!document) {
            throw new Error(`Document not found: '${srcDocumentId}' (Source: '${contentSourceData.id}'.)`);
        }
        const model = contentSourceData.modelMap[document.srcModelName];
        const csiModel = contentSourceData.csiModelMap[document.srcModelName];
        if (!model || !csiModel) {
            throw new Error(`Model not found: '${document.srcModelName}' (source: ${contentSourceId})`);
        }
        const resolvedLocale = locale !== null && locale !== void 0 ? locale : contentSourceData.defaultLocaleCode;
        let extendedObject = (0, duplicate_document_1.mergeObjectWithDocument)({
            object,
            document,
            locale: resolvedLocale,
            contentSourceId,
            contentSourceDataById: this.contentSourceDataById,
            referenceBehavior: (_a = this.stackbitConfig) === null || _a === void 0 ? void 0 : _a.presetReferenceBehavior,
            duplicatableModels: (_b = this.stackbitConfig) === null || _b === void 0 ? void 0 : _b.duplicatableModels,
            nonDuplicatableModels: (_c = this.stackbitConfig) === null || _c === void 0 ? void 0 : _c.nonDuplicatableModels
        });
        if ((_d = this.stackbitConfig) === null || _d === void 0 ? void 0 : _d.onContentCreate) {
            extendedObject = await this.stackbitConfig.onContentCreate({
                object: extendedObject !== null && extendedObject !== void 0 ? extendedObject : {},
                locale,
                model: {
                    srcType: contentSourceData.srcType,
                    srcProjectId: contentSourceData.srcProjectId,
                    ...csiModel
                },
                ...(0, config_delegate_1.createConfigDelegate)({
                    contentSourceDataById: this.contentSourceDataById,
                    logger: this.userLogger
                })
            });
        }
        const result = await (0, create_update_csi_docs_1.createDocumentRecursively)({
            object: extendedObject,
            locale: resolvedLocale,
            userLogger: this.userLogger,
            modelName: model.name,
            contentSourceId,
            contentSourceDataById: this.contentSourceDataById,
            assetSources: (_f = (_e = this.stackbitConfig) === null || _e === void 0 ? void 0 : _e.assetSources) !== null && _f !== void 0 ? _f : [],
            createDocument: this.getCreateDocumentThunk({ user })
        });
        this.logger.debug('duplicated document', { srcType, srcProjectId, srcDocumentId, newDocumentId: result.documentId, modelName: model.name });
        return { srcDocumentId: result.documentId };
    }
    getCreateDocumentThunk({ defaultLocaleDocumentId, user }) {
        return (0, create_update_csi_docs_1.getCreateDocumentThunk)({
            stackbitConfig: this.stackbitConfig,
            getContentSourceDataById: () => this.contentSourceDataById,
            logger: this.userLogger,
            defaultLocaleDocumentId: defaultLocaleDocumentId,
            user: user
        });
    }
    updateDocumentHooked(options) {
        return (0, document_hooks_1.updateDocumentHooked)({
            actionOptions: options.updateDocumentOptions,
            stackbitConfig: this.stackbitConfig,
            contentSourceData: options.contentSourceData,
            getContentSourceDataById: () => this.contentSourceDataById,
            user: options.user,
            logger: this.userLogger
        });
    }
    async uploadAssets({ srcType, srcProjectId, assets, locale, user }) {
        this.logger.debug('uploadAssets');
        (0, user_log_utils_1.logUploadAssets)({ userLogger: this.userLogger, srcType, srcProjectId, assets, locale });
        const contentSourceId = (0, content_store_utils_1.getContentSourceId)(srcType, srcProjectId);
        const contentSourceData = this.getContentSourceDataByIdOrThrow(contentSourceId);
        const sourceAssets = [];
        const userContext = (0, content_store_utils_1.getUserContextForSrcType)(srcType, user);
        locale = locale !== null && locale !== void 0 ? locale : contentSourceData.defaultLocaleCode;
        for (const asset of assets) {
            let base64 = undefined;
            if (asset.data) {
                const matchResult = asset.data.match(/;base64,([\s\S]+)$/);
                if (matchResult) {
                    base64 = matchResult[1];
                }
            }
            const sourceAsset = await contentSourceData.instance.uploadAsset({
                url: asset.url,
                base64: base64,
                fileName: asset.metadata.name,
                mimeType: asset.metadata.type,
                locale: locale,
                userContext: userContext
            });
            sourceAssets.push(sourceAsset);
        }
        const storeAssets = (0, csi_to_store_docs_converter_1.mapCSIAssetsToStoreAssets)({
            csiAssets: sourceAssets,
            contentSourceInstance: contentSourceData.instance,
            defaultLocaleCode: contentSourceData.defaultLocaleCode
        });
        return (0, store_to_api_docs_converter_1.mapStoreAssetsToAPIAssets)(storeAssets, this.staticAssetsPublicPath, locale);
    }
    async deleteDocument({ srcType, srcProjectId, srcDocumentId, user }) {
        this.logger.debug('deleteDocument');
        (0, user_log_utils_1.logDeleteDocument)({ userLogger: this.userLogger, srcType, srcProjectId, srcDocumentId });
        const userContext = (0, content_store_utils_1.getUserContextForSrcType)(srcType, user);
        const contentSourceId = (0, content_store_utils_1.getContentSourceId)(srcType, srcProjectId);
        const contentSourceData = this.getContentSourceDataByIdOrThrow(contentSourceId);
        const csiDocument = contentSourceData.csiDocumentMap[srcDocumentId];
        if (!csiDocument) {
            throw new Error(`Document not found: '${srcDocumentId}' (Source: '${contentSourceData.id}'.)`);
        }
        await (0, document_hooks_1.deleteDocumentHooked)({
            actionOptions: { document: csiDocument, userContext },
            stackbitConfig: this.stackbitConfig,
            contentSourceData: contentSourceData,
            getContentSourceDataById: () => this.contentSourceDataById,
            user: user,
            logger: this.userLogger
        });
    }
    getScheduledActions() {
        const scheduledActions = lodash_1.default.reduce(this.contentSourceDataById, (result, contentSourceData) => {
            return result.concat(contentSourceData.scheduledActions.map((scheduledAction) => ({
                ...scheduledAction,
                srcType: contentSourceData.srcType,
                srcProjectId: contentSourceData.srcProjectId
            })));
        }, []);
        return scheduledActions;
    }
    async updateScheduledAction({ srcType, srcProjectId, scheduledActionId, documentIds, name, executeAt, user }) {
        const userContext = (0, content_store_utils_1.getUserContextForSrcType)(srcType, user);
        const contentSourceId = (0, content_store_utils_1.getContentSourceId)(srcType, srcProjectId);
        const contentSourceData = this.getContentSourceDataByIdOrThrow(contentSourceId);
        this.logger.debug('updateScheduledAction', { srcType, srcProjectId, scheduledActionId });
        if (!contentSourceData.instance.updateScheduledAction) {
            this.logger.error('Trying to call updateScheduledAction, but it is not implemented', { srcType, srcProjectId, scheduledActionId });
            throw new Error('Content source plugin missing required method: updateScheduledAction');
        }
        return contentSourceData.instance.updateScheduledAction({ scheduledActionId, documentIds, name, executeAt, userContext });
    }
    async cancelScheduledAction({ srcType, srcProjectId, scheduledActionId, user }) {
        const userContext = (0, content_store_utils_1.getUserContextForSrcType)(srcType, user);
        const contentSourceId = (0, content_store_utils_1.getContentSourceId)(srcType, srcProjectId);
        const contentSourceData = this.getContentSourceDataByIdOrThrow(contentSourceId);
        this.logger.debug('cancelScheduledAction', { srcType, srcProjectId, scheduledActionId });
        if (!contentSourceData.instance.cancelScheduledAction) {
            this.logger.error('Trying to call cancelScheduledAction, but it is not implemented', { srcType, srcProjectId, scheduledActionId });
            throw new Error('Content source plugin missing required method: cancelScheduledAction');
        }
        return contentSourceData.instance.cancelScheduledAction({ scheduledActionId, userContext });
    }
    async createScheduledAction({ srcType, srcProjectId, documentIds, name, action, executeAt, user }) {
        const userContext = (0, content_store_utils_1.getUserContextForSrcType)(srcType, user);
        const contentSourceId = (0, content_store_utils_1.getContentSourceId)(srcType, srcProjectId);
        const contentSourceData = this.getContentSourceDataByIdOrThrow(contentSourceId);
        this.logger.debug('createScheduledAction', { srcType, srcProjectId, documentIds, name, action, executeAt });
        if (!contentSourceData.instance.createScheduledAction) {
            this.logger.error('Trying to call createScheduledAction, but it is not implemented', {
                srcType,
                srcProjectId,
                documentIds,
                name,
                action,
                executeAt
            });
            throw new Error('Content source plugin missing required method: createScheduledAction');
        }
        return contentSourceData.instance.createScheduledAction({ documentIds, name, action, executeAt, userContext });
    }
    async validateDocuments({ objects, locale, user }) {
        this.logger.debug('validateDocuments');
        const objectsBySourceId = lodash_1.default.groupBy(objects, (object) => (0, content_store_utils_1.getContentSourceId)(object.srcType, object.srcProjectId));
        let errors = [];
        for (const [contentSourceId, contentSourceObjects] of Object.entries(objectsBySourceId)) {
            const contentSourceData = this.getContentSourceDataByIdOrThrow(contentSourceId);
            locale = locale !== null && locale !== void 0 ? locale : contentSourceData.defaultLocaleCode;
            const { documents, assets } = (0, content_store_utils_1.getCSIDocumentsAndAssetsFromContentSourceDataByIds)(contentSourceData, contentSourceObjects);
            const userContext = (0, content_store_utils_1.getUserContextForSrcType)(contentSourceData.srcType, user);
            const internalValidationErrors = internalValidateContent(documents, assets, contentSourceData, locale);
            const validationResult = await contentSourceData.instance.validateDocuments({ documents, assets, locale, userContext });
            errors = errors.concat(internalValidationErrors, validationResult.errors.map((validationError) => ({
                message: validationError.message,
                srcType: contentSourceData.srcType,
                srcProjectId: contentSourceData.srcProjectId,
                srcObjectType: validationError.objectType,
                srcObjectId: validationError.objectId,
                fieldPath: validationError.fieldPath,
                isUniqueValidation: validationError.isUniqueValidation
            })));
        }
        return { errors };
        /* validate for multiple sources
        const objectsBySourceId = _.groupBy(objects, (document) => getContentSourceId(document.srcType, document.srcProjectId));
        const contentSourceIds = Object.keys(objectsBySourceId);
        return reducePromise(
            contentSourceIds,
            async (result: ContentStoreTypes.ValidationError[], contentSourceId) => {
                const documents = documentsBySourceId[contentSourceId]!;
                const contentSourceData = this.getContentSourceDataByIdOrThrow(contentSourceId);
                const validationErrors = await contentSourceData.instance.validateDocuments({ documentIds: documents.map((document) => document.srcObjectId) });
                return result.concat(validationErrors);
            },
            []
        );
         */
    }
    async searchDocuments(data) {
        this.logger.debug('searchDocuments');
        const locale = data.locale;
        const objectsBySourceId = lodash_1.default.groupBy(data.models, (object) => (0, content_store_utils_1.getContentSourceId)(object.srcType, object.srcProjectId));
        const contentSourceIds = Object.keys(objectsBySourceId);
        const documents = [];
        const schema = {};
        const scheduledActions = [];
        const defaultLocales = {};
        contentSourceIds.forEach((contentSourceId) => {
            const contentSourceData = this.getContentSourceDataByIdOrThrow(contentSourceId);
            lodash_1.default.set(schema, [contentSourceData.srcType, contentSourceData.srcProjectId], contentSourceData.modelMap);
            const contentSourceDocuments = lodash_1.default.isEmpty(locale)
                ? contentSourceData.documents
                : contentSourceData.documents.filter((document) => !document.locale || document.locale === locale);
            const contentSourceScheduledActions = contentSourceData.scheduledActions;
            const filteredDocuments = contentSourceDocuments.filter((document) => document.srcModelName !== exports.StackbitPresetModelName);
            documents.push(...filteredDocuments);
            scheduledActions.push(...contentSourceScheduledActions);
            if (contentSourceData.defaultLocaleCode) {
                defaultLocales[contentSourceId] = contentSourceData.defaultLocaleCode;
            }
        });
        return (0, search_utils_1.searchDocuments)({
            ...data,
            documents,
            schema,
            locale,
            scheduledActions,
            defaultLocales
        });
    }
    async publishDocuments({ objects, user }) {
        this.logger.debug('publishDocuments');
        (0, user_log_utils_1.logPublishDocuments)({ userLogger: this.userLogger, objects });
        const objectsBySourceId = lodash_1.default.groupBy(objects, (object) => (0, content_store_utils_1.getContentSourceId)(object.srcType, object.srcProjectId));
        for (const [contentSourceId, contentSourceObjects] of Object.entries(objectsBySourceId)) {
            const contentSourceData = this.getContentSourceDataByIdOrThrow(contentSourceId);
            const userContext = (0, content_store_utils_1.getUserContextForSrcType)(contentSourceData.srcType, user);
            const { documents, assets } = (0, content_store_utils_1.getCSIDocumentsAndAssetsFromContentSourceDataByIds)(contentSourceData, contentSourceObjects);
            await (0, document_hooks_1.publishDocumentHooked)({
                actionOptions: { documents, assets, userContext },
                stackbitConfig: this.stackbitConfig,
                contentSourceData: contentSourceData,
                getContentSourceDataById: () => this.contentSourceDataById,
                user: user,
                logger: this.userLogger
            });
        }
    }
    getContentSourceDataByIdOrThrow(contentSourceId) {
        return (0, content_store_utils_1.getContentSourceDataByIdOrThrow)(contentSourceId, this.contentSourceDataById);
    }
    onWebhook({ srcType, srcProjectId, data, headers }) {
        var _a, _b;
        const contentSourceId = (0, content_store_utils_1.getContentSourceId)(srcType, srcProjectId);
        const contentSourceData = this.getContentSourceDataByIdOrThrow(contentSourceId);
        return (_b = (_a = contentSourceData.instance).onWebhook) === null || _b === void 0 ? void 0 : _b.call(_a, { data, headers });
    }
    getWebhookUrl(contentSourceType, projectId) {
        if (!this.webhookUrl) {
            return undefined;
        }
        return `${this.webhookUrl}/${encodeURIComponent(contentSourceType)}/${encodeURIComponent(projectId)}`;
    }
}
exports.ContentStore = ContentStore;
function internalValidateContent(documents, assets, contentSourceData, locale) {
    const errors = [];
    lodash_1.default.forEach(documents, (document) => {
        lodash_1.default.forEach(document.fields, (documentField, fieldName) => {
            const localizedField = (0, types_1.getLocalizedFieldForLocale)(documentField, locale);
            if (localizedField) {
                errors.push(...validateDocumentFields(document, localizedField, [fieldName], contentSourceData, locale));
            }
        });
    });
    return errors;
}
function validateDocumentFields(document, documentField, fieldPath, contentSourceData, locale) {
    const errors = [];
    if (documentField.type === 'object') {
        lodash_1.default.forEach(documentField.fields, (documentField, fieldName) => {
            const localizedField = (0, types_1.getLocalizedFieldForLocale)(documentField, locale);
            if (localizedField) {
                errors.push(...validateDocumentFields(document, localizedField, fieldPath.concat(fieldName), contentSourceData, locale));
            }
        });
    }
    else if (documentField.type === 'model') {
        lodash_1.default.forEach(documentField.fields, (documentField, fieldName) => {
            const localizedField = (0, types_1.getLocalizedFieldForLocale)(documentField, locale);
            if (localizedField) {
                errors.push(...validateDocumentFields(document, localizedField, fieldPath.concat(fieldName), contentSourceData, locale));
            }
        });
    }
    else if (documentField.type === 'reference') {
        const objRef = documentField.refType === 'asset' ? contentSourceData.assetMap[documentField.refId] : contentSourceData.documentMap[documentField.refId];
        if (!objRef) {
            errors.push({
                fieldPath,
                srcType: contentSourceData.srcType,
                srcProjectId: contentSourceData.srcProjectId,
                srcObjectType: documentField.refType,
                srcObjectId: document.id,
                message: `Can't find referenced ${documentField.refType}: ${documentField.refId}`
            });
        }
    }
    else if (documentField.type === 'list') {
        lodash_1.default.forEach(documentField.items, (documentField, i) => {
            errors.push(...validateDocumentFields(document, documentField, fieldPath.concat(i), contentSourceData, locale));
        });
    }
    return errors;
}
//# sourceMappingURL=content-store.js.map