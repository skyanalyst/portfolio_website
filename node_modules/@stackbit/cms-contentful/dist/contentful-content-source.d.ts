import { WebhookProps } from 'contentful-management';
import type { Schema, Model } from '@stackbit/types';
import type * as ContentSourceTypes from '@stackbit/types';
import { DocumentContext, AssetContext, ContextualDocument, ContextualAsset } from './contentful-entries-converter';
export interface ContentSourceOptions {
    /** Contentful Space ID */
    spaceId: string;
    /** Contentful Space Environment. Default: 'master' */
    environment?: string;
    /** Contentful Preview Token */
    previewToken: string;
    /** Contentful Personal Access Token */
    accessToken: string;
    /**
     * Allow localization of Contentful Asset fields. This is useful when the
     * Contentful Space has multiple locales, and the fields of the new asset
     * uploaded from Stackbit (`title` and `file`) should be set to the locale
     * selected in Stackbit.
     * By default, this option's value is `false`, meaning that new Asset fields
     * will be set to the default locale of the Contentful Space.
     */
    useLocalizedAssetFields?: boolean;
    /**
     * Use webhook for content updates.
     */
    useWebhookForContentUpdates?: boolean;
}
declare type UserContext = {
    accessToken: string;
};
declare type SchemaContext = unknown;
export declare class ContentfulContentSource implements ContentSourceTypes.ContentSourceInterface<UserContext, SchemaContext, DocumentContext, AssetContext> {
    private readonly spaceId;
    private readonly environment;
    private readonly accessToken;
    private readonly previewToken;
    private readonly useLocalizedAssetFields;
    private logger;
    private userLogger;
    private localDev;
    private contentPoller;
    private useWebhookForContentUpdates;
    private locales;
    private defaultLocale?;
    private userMap;
    private cloudinaryImagesAsList;
    private bynderImagesAsList;
    private plainClient;
    private webhookUrl?;
    private devAppRestartNeeded?;
    private cache;
    constructor(options: ContentSourceOptions);
    getVersion(): Promise<ContentSourceTypes.Version>;
    getContentSourceType(): string;
    getProjectId(): string;
    getProjectEnvironment(): string;
    getProjectManageUrl(): string;
    init({ logger, userLogger, localDev, webhookUrl, devAppRestartNeeded, cache }: ContentSourceTypes.InitOptions<SchemaContext, DocumentContext, AssetContext>): Promise<void>;
    reset(): Promise<void>;
    destroy(): Promise<void>;
    validateConfig(): Promise<void>;
    createWebhookIfNeeded(): Promise<void>;
    createWebhook(webhookURL: string): Promise<WebhookProps>;
    startWatchingContentUpdates(): void;
    stopWatchingContentUpdates(): void;
    private fetchUsers;
    private convertSyncResult;
    getSchema(): Promise<Schema<SchemaContext>>;
    getDocuments(): Promise<ContextualDocument[]>;
    getAssets(): Promise<ContextualAsset[]>;
    hasAccess({ userContext }: {
        userContext?: UserContext;
    }): Promise<{
        hasConnection: boolean;
        hasPermissions: boolean;
    }>;
    createDocument({ updateOperationFields, model, locale, userContext }: {
        updateOperationFields: Record<string, ContentSourceTypes.UpdateOperationField>;
        model: Model;
        locale?: string;
        userContext?: UserContext;
    }): Promise<{
        documentId: string;
    }>;
    updateDocument({ document, operations, userContext }: {
        document: ContextualDocument;
        operations: ContentSourceTypes.UpdateOperation[];
        userContext?: UserContext;
    }): Promise<void>;
    deleteDocument({ document, userContext }: {
        document: ContextualDocument;
        userContext?: UserContext;
    }): Promise<void>;
    uploadAsset({ url, base64, fileName, mimeType, locale, userContext }: {
        url?: string;
        base64?: string;
        fileName: string;
        mimeType: string;
        locale?: string;
        userContext?: UserContext;
    }): Promise<ContextualAsset>;
    validateDocuments({ documents, assets, locale, userContext }: {
        documents: ContextualDocument[];
        assets: ContextualAsset[];
        locale?: string;
        userContext?: UserContext;
    }): Promise<{
        errors: ContentSourceTypes.ValidationError[];
    }>;
    publishDocuments({ documents, assets, userContext }: {
        documents: ContextualDocument[];
        assets: ContextualAsset[];
        userContext?: UserContext;
    }): Promise<void>;
    onWebhook({ data, headers }: {
        data: unknown;
        headers: Record<string, string>;
    }): Promise<void>;
    private getPlainApiClientForUser;
    private convertEntries;
    private convertAssets;
    private localeOrDefaultOrThrow;
    cancelScheduledAction({ scheduledActionId, userContext }: {
        scheduledActionId: string;
        userContext?: UserContext;
    }): Promise<{
        cancelledScheduledActionId: string;
    }>;
    createScheduledAction({ documentIds, name, action, executeAt, userContext }: {
        documentIds: string[];
        name: string;
        action: ContentSourceTypes.ScheduledActionActionType;
        executeAt: string;
        userContext?: UserContext;
    }): Promise<{
        newScheduledActionId: string;
    }>;
    getScheduledActions(): Promise<ContentSourceTypes.ScheduledAction[]>;
    updateScheduledAction({ scheduledActionId, documentIds, name, executeAt, userContext }: {
        scheduledActionId: string;
        documentIds?: string[];
        name?: string;
        executeAt?: string;
        userContext?: UserContext;
    }): Promise<{
        updatedScheduledActionId: string;
    }>;
}
export {};
//# sourceMappingURL=contentful-content-source.d.ts.map