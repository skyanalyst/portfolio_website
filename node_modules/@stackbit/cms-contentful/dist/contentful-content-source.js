"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContentfulContentSource = void 0;
const path = __importStar(require("path"));
const lodash_1 = __importDefault(require("lodash"));
const stackbitUtils = __importStar(require("@stackbit/types"));
const utils_1 = require("@stackbit/utils");
const contentful_api_client_1 = require("./contentful-api-client");
const contentful_schema_converter_1 = require("./contentful-schema-converter");
const contentful_entries_converter_1 = require("./contentful-entries-converter");
const contentful_scheduled_actions_converter_1 = require("./contentful-scheduled-actions-converter");
const content_poller_1 = require("./content-poller");
const stream_1 = require("stream");
const contentful_consts_1 = require("./contentful-consts");
class ContentfulContentSource {
    constructor(options) {
        var _a, _b, _c, _d, _e, _f, _g;
        this.contentPoller = null;
        this.locales = [];
        this.userMap = {};
        this.spaceId = (_a = options.spaceId) !== null && _a !== void 0 ? _a : process.env.CONTENTFUL_SPACE_ID;
        this.environment = (_c = (_b = options.environment) !== null && _b !== void 0 ? _b : process.env.CONTENTFUL_ENVIRONMENT) !== null && _c !== void 0 ? _c : 'master';
        this.accessToken = (_d = options.accessToken) !== null && _d !== void 0 ? _d : process.env.CONTENTFUL_ACCESS_TOKEN;
        this.previewToken = (_e = options.previewToken) !== null && _e !== void 0 ? _e : process.env.CONTENTFUL_PREVIEW_TOKEN;
        this.useLocalizedAssetFields = (_f = options.useLocalizedAssetFields) !== null && _f !== void 0 ? _f : false;
        this.useWebhookForContentUpdates = (_g = options.useWebhookForContentUpdates) !== null && _g !== void 0 ? _g : false;
    }
    async getVersion() {
        return stackbitUtils.getVersion({ packageJsonPath: path.join(__dirname, '../package.json') });
    }
    getContentSourceType() {
        return 'contentful';
    }
    getProjectId() {
        return this.spaceId;
    }
    getProjectEnvironment() {
        return this.environment;
    }
    getProjectManageUrl() {
        return `https://app.contentful.com/spaces/${this.spaceId}/home`;
    }
    async init({ logger, userLogger, localDev, webhookUrl, devAppRestartNeeded, cache }) {
        this.logger = logger.createLogger({ label: 'cms-contentful' });
        this.userLogger = userLogger.createLogger({ label: 'cms-contentful' });
        this.localDev = localDev;
        this.webhookUrl = webhookUrl;
        this.devAppRestartNeeded = devAppRestartNeeded;
        this.cache = cache;
        // If running locally, use sync poller instead of webhook unless explicitly debugging webhooks
        if (localDev && !webhookUrl) {
            this.useWebhookForContentUpdates = false;
        }
        if (this.useWebhookForContentUpdates) {
            this.userLogger.info('Using webhook for content updates');
        }
        this.plainClient = (0, contentful_api_client_1.createPlainApiClient)({
            spaceId: this.spaceId,
            accessToken: this.accessToken,
            environment: this.environment
        });
        await this.validateConfig();
        await this.createWebhookIfNeeded();
        await this.reset();
    }
    async reset() {
        const locales = await (0, contentful_api_client_1.fetchAllLocales)(this.plainClient);
        const appInstallations = await (0, contentful_api_client_1.fetchAllAppInstallations)(this.plainClient);
        await this.fetchUsers();
        // replace all data at once in atomic action
        this.locales = locales.filter((locale) => {
            // filter out disabled locales
            return locale.contentManagementApi;
        });
        this.defaultLocale = this.locales.find((locale) => locale.default);
        // Fetch up installations, and find the cloudinary app installation.
        // If cloudinary app is installed, use its 'maxFiles' parameter to decide
        // if cloudinary images should be presented as a single 'image' field or
        // as an array of 'images'.
        const cloudinaryAppInstallation = appInstallations.find((appInstallation) => appInstallation.sys.appDefinition.sys.id === contentful_consts_1.CONTENTFUL_CLOUDINARY_APP);
        const maxFiles = lodash_1.default.get(cloudinaryAppInstallation, 'parameters.maxFiles', 1);
        this.cloudinaryImagesAsList = maxFiles > 1;
        if (cloudinaryAppInstallation) {
            this.logger.debug(`found cloudinary app installation, maxFiles=${maxFiles}, treating cloudinary images as ${this.cloudinaryImagesAsList ? 'list of images' : 'a single image field'}`);
        }
        // same story with bynder as with cloudinary images - either array or one
        const bynderAppInstallation = appInstallations.find((appInstallation) => appInstallation.sys.appDefinition.sys.id === contentful_consts_1.CONTENTFUL_BYNDER_APP);
        const viewMode = lodash_1.default.get(bynderAppInstallation, 'parameters.compactViewMode', 'MultiSelect');
        this.bynderImagesAsList = viewMode === 'MultiSelect';
        if (bynderAppInstallation) {
            this.logger.debug(`found bynder app installation, viewMode=${viewMode}, treating bynder images as ${this.bynderImagesAsList ? 'list of images' : 'a single image field'}`);
        }
    }
    async destroy() { }
    async validateConfig() {
        var _a;
        this.logger.debug('Validating config...');
        let previewTokens;
        let environments;
        try {
            previewTokens = await this.plainClient.previewApiKey.getMany({});
            environments = await this.plainClient.environment.getMany({});
        }
        catch (err) {
            if ((_a = err === null || err === void 0 ? void 0 : err.message) === null || _a === void 0 ? void 0 : _a.includes('The resource could not be found')) {
                throw new Error(`Can't find Contentful space '${this.spaceId}'. Verify that the space exists and accessible with the provided access token.`);
            }
            else {
                throw new Error(`Can't access Contentful. Verify that the access token you provided is valid.`);
            }
        }
        const foundPreviewToken = previewTokens === null || previewTokens === void 0 ? void 0 : previewTokens.items.find((item) => item.accessToken === this.previewToken);
        if (!foundPreviewToken) {
            throw new Error(`Can't find Contentful preview token. Verify that the preview token is valid and associated with the provided Contentful space-id.`);
        }
        const foundEnvironment = environments === null || environments === void 0 ? void 0 : environments.items.find((item) => { var _a, _b; return item.name === this.environment || ((_b = (_a = item.sys) === null || _a === void 0 ? void 0 : _a.aliases) === null || _b === void 0 ? void 0 : _b.map((alias) => { var _a; return (_a = alias === null || alias === void 0 ? void 0 : alias.sys) === null || _a === void 0 ? void 0 : _a.id; }).includes(this.environment)); });
        if (!foundEnvironment) {
            throw new Error(`Can't find Contentful environment '${this.environment}'. Verify that the environment exists in the provided Contentful space-id.`);
        }
    }
    async createWebhookIfNeeded() {
        if (!this.webhookUrl) {
            return;
        }
        try {
            this.logger.debug('Creating webhook...');
            const webhooks = await (0, contentful_api_client_1.fetchAllWebhooks)(this.plainClient);
            if (!webhooks.find((webhook) => webhook.url === this.webhookUrl)) {
                await this.createWebhook(this.webhookUrl);
            }
        }
        catch (err) {
            this.userLogger.error('Error fetching or creating a contentful webhook', {
                srcProjectId: this.getProjectId(),
                error: err
            });
            if (this.useWebhookForContentUpdates) {
                this.userLogger.error('Falling back to using sync poller', { srcProjectId: this.getProjectId() });
                this.useWebhookForContentUpdates = false;
            }
        }
    }
    async createWebhook(webhookURL) {
        return (0, contentful_api_client_1.createWebhook)(this.plainClient, {
            url: webhookURL,
            name: 'stackbit-content-source-webhook',
            topics: ['*.*'],
            transformation: {
                contentType: 'application/json'
            }
        });
    }
    startWatchingContentUpdates() {
        this.logger.debug('startWatchingContentUpdates');
        if (this.useWebhookForContentUpdates) {
            return;
        }
        if (this.contentPoller) {
            this.stopWatchingContentUpdates();
        }
        this.contentPoller = new content_poller_1.ContentPoller({
            spaceId: this.spaceId,
            environment: this.environment,
            accessToken: this.previewToken,
            managementToken: this.accessToken,
            notificationCallback: async (syncResult) => {
                const result = await this.convertSyncResult(syncResult);
                await this.cache.updateContent(result);
            },
            logger: this.logger
        });
        this.contentPoller.start();
    }
    stopWatchingContentUpdates() {
        this.logger.debug('stopWatchingContentUpdates');
        if (this.contentPoller) {
            this.contentPoller.stop();
            this.contentPoller = null;
        }
    }
    async fetchUsers() {
        const users = await (0, contentful_api_client_1.fetchAllUsers)(this.plainClient);
        this.userMap = lodash_1.default.keyBy(users, 'sys.id');
    }
    async convertSyncResult(syncResult) {
        // remove deleted entries and assets from fieldData
        // generally, the "sync" method of the preview API never notifies of deleted objects, therefore we rely on
        // the deleteObject method to notify the user that restart is needed. Then, once user restarts the SSG, it
        // will re-fetch the data effectively removing deleted objects
        // https://www.notion.so/stackbit/Contentful-Sync-API-preview-issue-6b4816ebceef4ab181cdf1603058d324
        this.logger.debug('received sync data', {
            entries: syncResult.entries.length,
            assets: syncResult.assets.length,
            deletedEntries: syncResult.deletedEntries.length,
            deletedAssets: syncResult.deletedAssets.length
        });
        const resultHasNoCachedAuthor = [...syncResult.entries, ...syncResult.assets].some((data) => { var _a, _b; return !this.userMap[(_b = (_a = data.sys.updatedBy) === null || _a === void 0 ? void 0 : _a.sys.id) !== null && _b !== void 0 ? _b : '']; });
        if (resultHasNoCachedAuthor) {
            await this.fetchUsers();
        }
        // convert updated/new entries and assets
        const documents = this.convertEntries(syncResult.entries, this.cache.getModelByName);
        const assets = this.convertAssets(syncResult.assets);
        return {
            documents,
            assets,
            deletedDocumentIds: syncResult.deletedEntries.map((entry) => entry.sys.id),
            deletedAssetIds: syncResult.deletedAssets.map((asset) => asset.sys.id)
        };
    }
    async getSchema() {
        this.logger.debug('getSchema');
        const contentTypes = await (0, contentful_api_client_1.fetchAllContentTypes)(this.plainClient);
        const editorInterfaces = await (0, contentful_api_client_1.fetchAllEditorInterfaces)(this.plainClient);
        const defaultLocaleCode = this.localeOrDefaultOrThrow();
        const { models } = (0, contentful_schema_converter_1.convertSchema)({
            contentTypes: contentTypes,
            editorInterfaces: editorInterfaces,
            defaultLocaleCode: defaultLocaleCode,
            cloudinaryImagesAsList: this.cloudinaryImagesAsList,
            bynderImagesAsList: this.bynderImagesAsList
        });
        return {
            models,
            locales: this.locales.map((locale) => ({
                code: locale.code,
                default: locale.default
            })),
            context: {}
        };
    }
    async getDocuments() {
        this.logger.debug('getDocuments');
        let entries;
        try {
            entries = await (0, contentful_api_client_1.fetchAllEntries)(this.plainClient, this.userLogger);
        }
        catch (error) {
            // Stackbit won't be able to work properly even if one of the entries was not fetched.
            // All fetch methods use Contentful's API client that handles errors and retries automatically.
            this.logger.error(`Failed fetching documents from Contentful, error: ${error.message}`);
            return [];
        }
        this.logger.debug(`fetched ${entries.length} entries from space ${this.spaceId} and environment ${this.environment}`);
        return this.convertEntries(entries, this.cache.getModelByName);
    }
    async getAssets() {
        this.logger.debug('getAssets');
        let assets;
        try {
            assets = await (0, contentful_api_client_1.fetchAllAssets)(this.plainClient, this.userLogger);
        }
        catch (error) {
            // Stackbit won't be able to work properly even if one of the entries or the assets was not fetched.
            // All fetch methods use Contentful's API client that handles errors and retries automatically.
            this.logger.error(`Failed fetching assets from Contentful, error: ${error.message}`);
            return [];
        }
        this.logger.debug(`fetched ${assets.length} assets from space ${this.spaceId} and environment ${this.environment}`);
        return this.convertAssets(assets);
    }
    async hasAccess({ userContext }) {
        if (!this.localDev && !(userContext === null || userContext === void 0 ? void 0 : userContext.accessToken)) {
            return {
                hasConnection: false,
                hasPermissions: false
            };
        }
        try {
            const apiClient = this.getPlainApiClientForUser({ userContext });
            await apiClient.entry.getMany({ query: { limit: 1 } });
            return {
                hasConnection: true,
                hasPermissions: true
            };
        }
        catch (error) {
            return {
                hasConnection: true,
                hasPermissions: false
            };
        }
    }
    async createDocument({ updateOperationFields, model, locale, userContext }) {
        this.logger.debug('createDocument');
        const entry = { fields: {} };
        lodash_1.default.forEach(updateOperationFields, (operationField, fieldName) => {
            var _a;
            const modelField = (_a = model.fields) === null || _a === void 0 ? void 0 : _a.find((field) => field.name === fieldName);
            if (!modelField) {
                return;
            }
            const value = mapOperationFieldToContentfulValue(operationField, modelField, false);
            const localeOrDefault = this.localeOrDefaultOrThrow(locale);
            setEntryField(entry, value, [fieldName], modelField.localized ? localeOrDefault : this.defaultLocale.code);
        });
        const apiClient = this.getPlainApiClientForUser({ userContext });
        const entryResult = await (0, contentful_api_client_1.createEntry)(apiClient, model.name, entry);
        return { documentId: entryResult.sys.id };
    }
    async updateDocument({ document, operations, userContext }) {
        var _a, _b, _c;
        this.logger.debug('updateDocument');
        const documentId = document.id;
        const entry = await (0, contentful_api_client_1.fetchEntryById)(this.plainClient, documentId);
        const modelName = entry.sys.contentType.sys.id;
        const model = this.cache.getModelByName(modelName);
        if (!model) {
            throw new Error(`Error updating document: could not find document model '${modelName}'.`);
        }
        const defaultLocale = (_b = (_a = this.defaultLocale) === null || _a === void 0 ? void 0 : _a.code) !== null && _b !== void 0 ? _b : 'en-US';
        for (const operation of operations) {
            const locale = 'localized' in operation.modelField && operation.modelField.localized ? (_c = operation.locale) !== null && _c !== void 0 ? _c : defaultLocale : defaultLocale;
            const operationWithLocale = {
                ...operation,
                locale
            };
            const opFunc = Operations[operationWithLocale.opType];
            await opFunc({ entry, operation: operationWithLocale });
        }
        const apiClient = this.getPlainApiClientForUser({ userContext });
        await (0, contentful_api_client_1.updateEntry)(apiClient, documentId, entry);
    }
    async deleteDocument({ document, userContext }) {
        this.logger.debug('deleteDocument');
        const documentId = document.id;
        try {
            const entry = await (0, contentful_api_client_1.fetchEntryById)(this.plainClient, documentId);
            const apiClient = this.getPlainApiClientForUser({ userContext });
            // Contentful won't let us delete a published entry, so if the entry is
            // published we must unpublish it first.
            if (lodash_1.default.get(entry, 'sys.publishedVersion')) {
                await (0, contentful_api_client_1.unpublishEntry)(apiClient, documentId);
            }
            await (0, contentful_api_client_1.deleteEntry)(apiClient, documentId);
        }
        catch (err) {
            this.logger.error('Contentful: Failed to delete object', {
                documentId: documentId,
                error: err
            });
            throw err;
        }
    }
    async uploadAsset({ url, base64, fileName, mimeType, locale, userContext }) {
        this.logger.debug('uploadAsset');
        locale = this.localeOrDefaultOrThrow(this.useLocalizedAssetFields ? locale : undefined);
        const apiClient = this.getPlainApiClientForUser({ userContext });
        let asset;
        if (url) {
            asset = await (0, contentful_api_client_1.createAsset)(apiClient, {
                fields: {
                    title: {
                        [locale]: fileName
                    },
                    file: {
                        [locale]: {
                            fileName: fileName,
                            contentType: mimeType,
                            upload: url
                        }
                    }
                }
            });
        }
        else {
            const imgBuffer = Buffer.from(base64, 'base64');
            const readable = new stream_1.Readable();
            readable.push(imgBuffer);
            readable.push(null);
            asset = await (0, contentful_api_client_1.createAssetFromFile)(apiClient, {
                fields: {
                    title: {
                        [locale]: fileName
                    },
                    // the description is marked as required in Contentful's Typescript
                    description: {
                        [locale]: ''
                    },
                    file: {
                        [locale]: {
                            fileName: fileName,
                            contentType: mimeType,
                            file: readable
                        }
                    }
                }
            });
        }
        const processedAsset = await (0, contentful_api_client_1.processAssetForAllLocales)(apiClient, asset);
        const publishedAsset = await (0, contentful_api_client_1.publishAsset)(apiClient, processedAsset);
        const assetDocument = this.convertAssets([publishedAsset]);
        return assetDocument[0];
    }
    async validateDocuments({ documents, assets, locale, userContext }) {
        // Max active bulk actions per space is limited to 5.
        // Max of 200 items per bulk action.
        const taskQueue = new utils_1.TaskQueue({ limit: 5 });
        const linkChunks = lodash_1.default.chunk([
            ...documents.map((document) => ({ sys: { type: 'Link', id: document.id, linkType: 'Entry' } })),
            ...assets.map((asset) => ({ sys: { type: 'Link', id: asset.id, linkType: 'Asset' } }))
        ], 200);
        const apiClient = this.getPlainApiClientForUser({ userContext });
        locale = this.localeOrDefaultOrThrow(locale);
        const result = await Promise.all(linkChunks.map((link) => {
            return taskQueue.addTask(async () => {
                var _a, _b, _c;
                const bulkActionOptions = {
                    spaceId: this.spaceId,
                    environmentId: this.environment
                };
                const bulkActionCreateResult = await (0, contentful_api_client_1.createValidateBulkAction)(apiClient, bulkActionOptions, {
                    entities: {
                        sys: { type: 'Array' },
                        items: link
                    }
                });
                const bulkAction = await waitBulkActionToComplete(bulkActionCreateResult, apiClient, bulkActionOptions);
                if (bulkAction.sys.status === 'failed') {
                    const errors = (_c = (_b = (_a = bulkAction.error) === null || _a === void 0 ? void 0 : _a.details) === null || _b === void 0 ? void 0 : _b.errors) !== null && _c !== void 0 ? _c : [];
                    return errors.reduce((result, { error, entity }) => {
                        var _a, _b;
                        const entityErrors = (_b = (_a = error === null || error === void 0 ? void 0 : error.details) === null || _a === void 0 ? void 0 : _a.errors) !== null && _b !== void 0 ? _b : [];
                        return entityErrors.reduce((result, entityError) => {
                            var _a;
                            // error.path is:
                            // ['fields', 'title'] => ['title']
                            // ['fields', 'title', 'en-US'] => ['title']
                            // ['fields', 'action', 'en-US', 1] => ['title']
                            const fieldPath = entityError.path.slice(1);
                            const fieldLocale = fieldPath[1];
                            if (typeof fieldLocale === 'string' && ['en-US', locale].includes(fieldLocale)) {
                                // remove locale from fieldPath
                                fieldPath.splice(1, 1);
                            }
                            result.push({
                                message: (_a = entityError === null || entityError === void 0 ? void 0 : entityError.customMessage) !== null && _a !== void 0 ? _a : entityError.details,
                                objectType: entity.sys.linkType === 'Entry' ? 'document' : 'asset',
                                objectId: entity.sys.id,
                                fieldPath: fieldPath,
                                isUniqueValidation: entityError.name === 'unique'
                            });
                            return result;
                        }, result);
                    }, []);
                }
                return [];
            });
        }));
        return { errors: lodash_1.default.flatten(result) };
    }
    async publishDocuments({ documents, assets, userContext }) {
        const apiClient = this.getPlainApiClientForUser({ userContext });
        // to publish, we need the most recent entity version, fetch the entities
        // by id to get their latest version and also ensure they were not publish
        // by someone else.
        const entries = await (0, contentful_api_client_1.fetchEntriesByIds)(apiClient, documents.map((document) => document.id), {
            'sys.archivedVersion[exists]': false,
            select: 'sys.id,sys.type,sys.version,sys.publishedVersion,sys.archivedVersion'
        });
        const contentfulAssets = await (0, contentful_api_client_1.fetchAssetsByIds)(apiClient, assets.map((asset) => asset.id), {
            'sys.archivedVersion[exists]': false,
            select: 'sys.id,sys.type,sys.version,sys.publishedVersion,sys.archivedVersion'
        });
        const entities = [...entries, ...contentfulAssets];
        const entitiesToPublish = entities.filter((entity) => {
            const isDraft = !entity.sys.publishedVersion && !entity.sys.archivedVersion;
            const isChanged = entity.sys.publishedVersion && entity.sys.version >= entity.sys.publishedVersion + 2;
            return isDraft || isChanged;
        });
        // Max active bulk actions per space is limited to 5.
        // Max of 200 items per bulk action.
        const taskQueue = new utils_1.TaskQueue({ limit: 5 });
        const versionedLinkChunks = lodash_1.default.chunk(entitiesToPublish.map((entity) => ({
            sys: {
                type: 'Link',
                id: entity.sys.id,
                linkType: entity.sys.type,
                version: entity.sys.version
            }
        })), 200);
        await Promise.all(versionedLinkChunks.map((versionedLinks) => {
            return taskQueue.addTask(async () => {
                const bulkActionOptions = {
                    spaceId: this.spaceId,
                    environmentId: this.environment
                };
                const bulkActionCreateResult = await (0, contentful_api_client_1.createPublishBulkAction)(apiClient, bulkActionOptions, {
                    entities: {
                        sys: { type: 'Array' },
                        items: versionedLinks
                    }
                });
                await waitBulkActionToComplete(bulkActionCreateResult, apiClient, bulkActionOptions);
            });
        }));
    }
    async onWebhook({ data, headers }) {
        const topic = headers['x-contentful-topic'] || '';
        const didContentTypeChange = topic.startsWith('ContentManagement.ContentType.');
        const didDocumentDelete = topic === 'ContentManagement.Entry.delete';
        const didAssetDelete = topic === 'ContentManagement.Asset.delete';
        const didScheduledActionDelete = topic === 'ContentManagement.ScheduledAction.delete' || topic === 'ContentManagement.Release.delete';
        const environment = lodash_1.default.get(data, 'sys.environment.sys.id');
        // skip updates on other environments
        if (environment !== this.environment) {
            return;
        }
        // skip updates on BulkAction event type
        if (topic.includes('BulkAction')) {
            return;
        }
        if (didContentTypeChange) {
            this.cache.invalidateSchema();
        }
        if (didDocumentDelete) {
            const documentId = lodash_1.default.get(data, 'sys.id');
            if (documentId) {
                this.cache.updateContent({
                    documents: [],
                    assets: [],
                    deletedDocumentIds: [documentId],
                    deletedAssetIds: []
                });
            }
        }
        if (didAssetDelete) {
            const assetId = lodash_1.default.get(data, 'sys.id');
            if (assetId) {
                this.cache.updateContent({
                    documents: [],
                    assets: [],
                    deletedDocumentIds: [],
                    deletedAssetIds: [assetId]
                });
            }
        }
        if (didScheduledActionDelete) {
            let scheduledActionId;
            if (lodash_1.default.get(data, 'sys.type') === 'ScheduledAction') {
                // refetch schedule because we're not getting the entity.sys.id in the webhook data
                const schedule = await (0, contentful_api_client_1.fetchScheduleById)(this.plainClient, { environment: this.environment, scheduleId: lodash_1.default.get(data, 'sys.id') });
                scheduledActionId = schedule.entity.sys.id;
            }
            else {
                scheduledActionId = lodash_1.default.get(data, 'sys.id');
            }
            if (scheduledActionId) {
                this.cache.updateContent({
                    deletedScheduledActionIds: [scheduledActionId]
                });
            }
        }
        // ScheduledActions are handled outside of this.useWebhookForContentUpdates block below because Releases and Schedules are not handled by sync.
        if ((topic.startsWith('ContentManagement.ScheduledAction') || topic.startsWith('ContentManagement.Release')) && !didScheduledActionDelete) {
            const scheduledActionId = lodash_1.default.get(data, 'sys.type') === 'ScheduledAction' && lodash_1.default.get(data, 'entity.sys.linkType') === 'Release'
                ? lodash_1.default.get(data, 'entity.sys.id')
                : lodash_1.default.get(data, 'sys.type') === 'Release'
                    ? lodash_1.default.get(data, 'sys.id')
                    : null;
            this.logger.debug(`onWebhook ScheduledAction/Release - ${scheduledActionId}`);
            if (scheduledActionId) {
                const scheduledAction = await (0, contentful_api_client_1.getScheduledAction)(this.plainClient, scheduledActionId, { environment: this.environment });
                if (scheduledAction) {
                    // If a schedule is updated from the studio, both the ScheduledAction and the Release will post a webhook update,
                    // So this diff change makes sure we send only one update.
                    const cachedScheduledAction = this.cache.getScheduledActions().find((schedule) => schedule.id === scheduledActionId);
                    const updatedActions = lodash_1.default.differenceWith([scheduledAction], [cachedScheduledAction], lodash_1.default.isEqual);
                    if (updatedActions.length) {
                        this.cache.updateContent({ scheduledActions: updatedActions });
                    }
                }
            }
        }
        // if sync poller is used, content updates are handled in the poller and we don't need to do anything here
        if (this.useWebhookForContentUpdates) {
            const userId = lodash_1.default.get(data, 'sys.updatedBy.sys.id');
            if (userId && !this.userMap[userId]) {
                await this.fetchUsers();
            }
            if (topic.startsWith('ContentManagement.Entry') && !didDocumentDelete) {
                const documentId = lodash_1.default.get(data, 'sys.id');
                this.logger.debug(`onWebhook ${topic} ${documentId}`);
                if (documentId) {
                    const entity = await (0, contentful_api_client_1.fetchEntryById)(this.plainClient, documentId);
                    this.cache.updateContent({
                        documents: this.convertEntries([entity], this.cache.getModelByName),
                        assets: [],
                        deletedDocumentIds: [],
                        deletedAssetIds: []
                    });
                }
            }
            else if (topic.startsWith('ContentManagement.Asset') && !didAssetDelete) {
                const assetId = lodash_1.default.get(data, 'sys.id');
                this.logger.debug(`onWebhook ${topic} ${assetId}`);
                if (assetId) {
                    const asset = await (0, contentful_api_client_1.fetchAssetById)(this.plainClient, assetId);
                    this.cache.updateContent({
                        documents: [],
                        assets: this.convertAssets([asset]),
                        deletedDocumentIds: [],
                        deletedAssetIds: []
                    });
                }
            }
        }
    }
    getPlainApiClientForUser({ userContext }) {
        if (this.localDev) {
            return this.plainClient;
        }
        const userAccessToken = userContext === null || userContext === void 0 ? void 0 : userContext.accessToken;
        if (!userAccessToken) {
            throw new Error(`User does not have an access token for space '${this.spaceId}'.`);
        }
        return (0, contentful_api_client_1.createPlainApiClient)({
            spaceId: this.spaceId,
            accessToken: userAccessToken,
            environment: this.environment
        });
    }
    convertEntries(entries, getModelByName) {
        return (0, contentful_entries_converter_1.convertEntities)({
            entries: entries,
            getModelByName: getModelByName,
            userMap: this.userMap,
            defaultLocale: this.localeOrDefaultOrThrow()
        });
    }
    convertAssets(assets) {
        return (0, contentful_entries_converter_1.convertAssets)({
            assets: assets,
            userMap: this.userMap,
            defaultLocale: this.localeOrDefaultOrThrow(),
            useLocalizedAssetFields: this.useLocalizedAssetFields
        });
    }
    localeOrDefaultOrThrow(locale) {
        var _a;
        const result = locale !== null && locale !== void 0 ? locale : (_a = this.defaultLocale) === null || _a === void 0 ? void 0 : _a.code;
        if (!result) {
            throw new Error('Localization error: default locale is not set.');
        }
        return result;
    }
    async cancelScheduledAction({ scheduledActionId, userContext }) {
        try {
            this.logger.debug('cancelScheduledAction', { scheduledActionId });
            const apiClient = this.getPlainApiClientForUser({ userContext });
            const schedule = await (0, contentful_api_client_1.cancelScheduledAction)(apiClient, scheduledActionId, {
                environment: this.environment
            });
            this.logger.debug('cancelScheduledAction - success', { schedule });
            return { cancelledScheduledActionId: schedule.id };
        }
        catch (err) {
            this.logger.debug('Failed to update scheduled actions');
            throw err;
        }
    }
    async createScheduledAction({ documentIds, name, action, executeAt, userContext }) {
        this.logger.debug('createScheduledAction', { action, executeAt });
        const apiClient = this.getPlainApiClientForUser({ userContext });
        const { schedule, contentfulSchedule, contentfulRelease } = await (0, contentful_api_client_1.createScheduledAction)(apiClient, {
            name,
            documentIds,
            executeAt,
            action,
            environment: this.environment
        });
        this.logger.debug('createScheduledAction - Create success', { schedule, contentfulSchedule, contentfulRelease });
        return { newScheduledActionId: schedule.id };
    }
    async getScheduledActions() {
        this.logger.debug('getScheduledActions');
        const contentfulReleases = await (0, contentful_api_client_1.fetchAllReleases)(this.plainClient, this.logger);
        const contentfulSchedules = await (0, contentful_api_client_1.fetchAllSchedules)(this.plainClient, { environment: this.environment }, this.logger);
        return (0, contentful_scheduled_actions_converter_1.convertAndFilterScheduledActions)(contentfulReleases, contentfulSchedules);
    }
    async updateScheduledAction({ scheduledActionId, documentIds, name, executeAt, userContext }) {
        try {
            this.logger.debug('updateScheduledAction', { scheduledActionId, documentIds, name, executeAt });
            const apiClient = this.getPlainApiClientForUser({ userContext });
            const schedule = await (0, contentful_api_client_1.updateScheduledAction)(apiClient, scheduledActionId, {
                name,
                documentIds,
                executeAt,
                environment: this.environment
            });
            this.logger.debug('updateScheduledAction - Update success', { schedule });
            return { updatedScheduledActionId: schedule.id };
        }
        catch (err) {
            this.logger.debug('Failed to update scheduled actions');
            throw err;
        }
    }
}
exports.ContentfulContentSource = ContentfulContentSource;
const Operations = {
    set: async function ({ entry, operation }) {
        const { field, fieldPath, locale, modelField } = operation;
        // bynder & cloudinary always stored as array in cms; depends on the app setting - it might be in csi either single image or array of images
        // if we call set on the entire list it should be an array, otherwise if we calling on the item of the list - not
        const isListOp = typeof fieldPath[fieldPath.length - 1] === 'number';
        const value = mapOperationFieldToContentfulValue(field, modelField, isListOp);
        setEntryField(entry, value, fieldPath, locale);
        return entry;
    },
    unset: async ({ entry, operation }) => {
        const { fieldPath, locale } = operation;
        const localizedFieldPath = getLocalizedFieldPath(fieldPath, locale);
        lodash_1.default.unset(entry, localizedFieldPath);
        return entry;
    },
    insert: async function ({ entry, operation }) {
        var _a, _b;
        const { item, fieldPath, locale, index, modelField } = operation;
        const array = (_a = getEntryField(entry, fieldPath, locale)) !== null && _a !== void 0 ? _a : [];
        const listItemModelField = (_b = modelField.items) !== null && _b !== void 0 ? _b : { type: 'string' };
        const value = mapOperationFieldToContentfulValue(item, listItemModelField, true);
        array.splice(index !== null && index !== void 0 ? index : array.length, 0, value);
        setEntryField(entry, array, fieldPath, locale);
        return entry;
    },
    remove: async ({ entry, operation }) => {
        var _a;
        const { fieldPath, locale, index } = operation;
        const array = (_a = getEntryField(entry, fieldPath, locale)) !== null && _a !== void 0 ? _a : [];
        array.splice(index, 1);
        setEntryField(entry, array, fieldPath, locale);
        return entry;
    },
    reorder: async ({ entry, operation }) => {
        var _a;
        const { fieldPath, locale, order } = operation;
        const array = (_a = getEntryField(entry, fieldPath, locale)) !== null && _a !== void 0 ? _a : [];
        const newEntryArr = order.map((newIndex) => array[newIndex]);
        setEntryField(entry, newEntryArr, fieldPath, locale);
        return entry;
    }
};
function mapOperationFieldToContentfulValue(documentField, modelField, inArray) {
    var _a, _b, _c, _d, _e;
    if (documentField.type === 'object') {
        throw new Error('Nested object fields not supported in Contentful.');
    }
    else if (documentField.type === 'model') {
        throw new Error('Nested model fields not supported in Contentful.');
    }
    else if (documentField.type === 'image') {
        if (modelField.type === 'image' && modelField.source && contentful_consts_1.CONTENTFUL_BUILT_IN_IMAGE_SOURCES.includes(modelField.source)) {
            // The Cloudinary and Bynder apps in Contentful always stores images as array,
            // but if we are already adding items to array, return don't wrap in array
            let value = inArray ? documentField.value : [documentField.value];
            if (modelField.source === 'bynder') {
                // contentful saves data in different format - align the incoming data from studio (which is in full format) to the one
                // contentful bynder app uses internally
                if ((_a = documentField.value) === null || _a === void 0 ? void 0 : _a.__typename) {
                    // full object - transform to bynder contentful app format
                    const thumbnails = {
                        webimage: (_b = documentField.value.files.webImage) === null || _b === void 0 ? void 0 : _b.url,
                        thul: (_c = documentField.value.files.thumbnail) === null || _c === void 0 ? void 0 : _c.url
                    };
                    lodash_1.default.forEach(documentField.value.files, (value, key) => {
                        if (key === 'webImage' || key === 'thumbnail') {
                            return;
                        }
                        thumbnails[key] = value.url;
                    });
                    const imageObject = lodash_1.default.omitBy({
                        id: documentField.value.databaseId,
                        orientation: documentField.value.orientation.toLowerCase(),
                        archive: documentField.value.isArchived ? 1 : 0,
                        type: documentField.value.type.toLowerCase(),
                        fileSize: documentField.value.fileSize,
                        description: documentField.value.description,
                        name: documentField.value.name,
                        height: documentField.value.height,
                        width: documentField.value.width,
                        copyright: documentField.value.copyright,
                        extension: documentField.value.extensions,
                        userCreated: documentField.value.createdBy,
                        datePublished: documentField.value.publishedAt,
                        dateCreated: documentField.value.createdAt,
                        dateModified: documentField.value.updatedAt,
                        watermarked: documentField.value.isWatermarked ? 1 : 0,
                        limited: documentField.value.isLimitedUse ? 1 : 0,
                        isPublic: documentField.value.isPublic ? 1 : 0,
                        brandId: documentField.value.brandId,
                        original: documentField.value.originalUrl,
                        videoPreviewURLs: documentField.value.previewUrls || [],
                        tags: documentField.value.tags,
                        selectedFile: documentField.value.selectedFile,
                        src: (_d = documentField.value.files.webImage) === null || _d === void 0 ? void 0 : _d.url,
                        thumbnails
                    }, (value) => value === undefined || (lodash_1.default.isPlainObject(value) ? !Object.keys(value).length : false));
                    value = inArray ? imageObject : [imageObject];
                }
            }
            return value;
        }
        // TODO: there is a bug right now because documentField is inferred from the model which is an "image", not reference
        return linkForAssetId(documentField === null || documentField === void 0 ? void 0 : documentField.value);
    }
    else if (documentField.type === 'reference') {
        return documentField.refType === 'document' ? linkForEntryId(documentField.refId) : linkForAssetId(documentField.refId);
    }
    else if (documentField.type === 'cross-reference') {
        return crossReferenceFieldPropsToResourceLink(documentField.value);
    }
    else if (documentField.type === 'list') {
        const listItemModelField = (_e = modelField.items) !== null && _e !== void 0 ? _e : { type: 'string' };
        return documentField.items.map((item) => mapOperationFieldToContentfulValue(item, listItemModelField, true));
    }
    else if (documentField.type === 'number') {
        return Number(documentField.value);
    }
    return documentField.value;
}
function linkForEntryId(entryId) {
    return {
        sys: {
            type: 'Link',
            linkType: 'Entry',
            id: entryId
        }
    };
}
function linkForAssetId(assetId) {
    return {
        sys: {
            type: 'Link',
            linkType: 'Asset',
            id: assetId
        }
    };
}
function getEntryField(entry, fieldPath, locale) {
    return lodash_1.default.get(entry, getLocalizedFieldPath(fieldPath, locale));
}
/**
 * When the `value` is `null`, an empty string, or an empty array, and the
 * `fieldPath` has the length of one, then unset the field at the specified locale.
 * Do not set the field locale to one of these values as it will prevent
 * localization fallback behavior:
 *
 * @example
 * Input:
 *   entry: { "title": { "en-US": "foo", "en-AU": "bar" } }
 *   value: ""
 *   fieldPath: ["title"]
 *   locale: "en-AU"
 * Result:
 *   entry: { "title": { "en-US": "foo" } }
 *
 * If the length of the `fieldPath` is greater than 1, for example when
 * the updated field is an item of an array (e.g.: ['tags', 0]), then set the
 * value of the array item to the actual value:
 *
 * @example
 * Input:
 *   entry: { "tags": { "en-US": ["foo"], "en-AU": ["bar"] } }
 *   value: ""
 *   fieldPath: ["tags", 0]
 *   locale: "en-AU"
 * Result:
 *   entry: { "title": { "en-US": "foo", "en-AU": [""] } }
 */
function setEntryField(entry, value, fieldPath, locale) {
    const localizedFieldPath = getLocalizedFieldPath(fieldPath, locale);
    const isEmpty = lodash_1.default.isNil(value) || value === '' || (Array.isArray(value) && value.length === 0);
    if (fieldPath.length === 1 && isEmpty) {
        lodash_1.default.unset(entry, localizedFieldPath);
    }
    else {
        lodash_1.default.set(entry, localizedFieldPath, value);
    }
}
function getLocalizedFieldPath(fieldPath, locale) {
    if (!locale) {
        throw new Error(`Localization error: locale missing for fieldPath: '${fieldPath}'.`);
    }
    if (fieldPath.length > 1) {
        return lodash_1.default.concat('fields', lodash_1.default.head(fieldPath), locale, lodash_1.default.tail(fieldPath));
    }
    else {
        return lodash_1.default.concat('fields', fieldPath, locale);
    }
}
function sleep(durationMs) {
    return new Promise((resolve) => setTimeout(resolve, durationMs));
}
async function waitBulkActionToComplete(bulkAction, apiClient, bulkActionOptions) {
    const maxRetries = 3;
    const retryIntervalMs = 2000;
    const initialDelayMs = 1000;
    await sleep(initialDelayMs);
    let retryCount = 0;
    let done = false;
    let bulkActionResult;
    while (retryCount < maxRetries && !done) {
        bulkActionResult = await (0, contentful_api_client_1.getBulkAction)(apiClient, {
            ...bulkActionOptions,
            bulkActionId: bulkAction.sys.id
        });
        // Terminal states
        if (bulkActionResult && ['succeeded', 'failed'].includes(bulkActionResult.sys.status)) {
            done = true;
            break;
        }
        await sleep(retryIntervalMs);
        retryCount += 1;
    }
    if (!bulkActionResult || !done) {
        throw new Error(`${bulkAction.action} bulk action didn't finish processing within the expected timeframe.`);
    }
    return bulkActionResult;
}
function crossReferenceFieldPropsToResourceLink(crossReference) {
    return {
        sys: {
            type: 'ResourceLink',
            linkType: 'Contentful:Entry',
            urn: `crn:contentful:::content:spaces/${crossReference.refProjectId}/entries/${crossReference.refId}`
        }
    };
}
//# sourceMappingURL=contentful-content-source.js.map