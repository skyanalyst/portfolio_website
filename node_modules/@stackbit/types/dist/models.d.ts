/**
 * Stackbit Model Types
 */
import type { Field, FieldExtension, FieldGroupItem, DocumentPreview, DocumentFieldPreview } from './model-fields';
import type { Document } from './content-source-document';
import type { CustomActionDocument, CustomActionObjectModel } from './custom-actions';
export declare type Model<ModelContext = unknown> = ObjectModel<ModelContext> | DataModel<ModelContext> | PageModel<ModelContext> | ConfigModel<ModelContext>;
export declare type ModelWithSource<ModelType extends Model = Model> = ModelType & {
    srcType: string;
    srcProjectId: string;
};
export declare type NamelessModelMap = Record<string, NamelessModel>;
export declare type NamelessModel = DistributeNamelessModels<Model>;
export declare type DistributeNamelessModels<Type extends Model> = Type extends Model ? Omit<Type, 'name'> : never;
export declare type DistributeModelExtensions<Type extends Model> = Type extends Model ? Partial<Omit<Type, 'name' | 'fields'>> & {
    name: string;
    fields?: FieldExtension[];
} & {
    srcType?: string;
    srcProjectId?: string;
} : never;
export declare type ModelExtension = DistributeModelExtensions<Model>;
export interface ModelCommonFields<ModelContext = unknown> {
    /**
     * The name of the model, must be unique.
     * When extending content source models using the {@link Config.modelExtensions}
     * property, set it to the unique name or the unique  ID of the model as it
     * appear in the CMS.
     **/
    name: string;
    /** The label of the model. If not specified, the name will be title cased. */
    label?: string;
    description?: string;
    thumbnail?: string;
    /** @deprecated */
    extends?: string | string[];
    readOnly?: boolean;
    labelField?: string;
    /** @deprecated */
    variantField?: string;
    groups?: string[];
    fieldGroups?: FieldGroupItem[];
    fields?: Field[];
    context?: ModelContext;
}
export interface ModelMatchFields {
    singleInstance?: boolean;
    file?: string;
    folder?: string;
    match?: string | string[];
    exclude?: string | string[];
}
export interface ObjectModel<ModelContext = unknown> extends ModelCommonFields<ModelContext> {
    type: 'object';
    preview?: DocumentFieldPreview;
    actions?: CustomActionObjectModel[];
}
/** @deprecated */
export interface ConfigModel<ModelContext = unknown> extends ModelCommonFields<ModelContext>, ModelLocalized {
    type: 'config';
    file?: string;
}
export interface PageModel<ModelContext = unknown> extends ModelCommonFields<ModelContext>, ModelMatchFields, ModelLocalized {
    type: 'page';
    layout?: string;
    urlPath?: string;
    filePath?: string | DocumentFilePathFunction;
    hideContent?: boolean;
    preview?: DocumentPreview;
    actions?: CustomActionDocument[];
}
export interface DataModel<ModelContext = unknown> extends ModelCommonFields<ModelContext>, ModelMatchFields, ModelLocalized {
    type: 'data';
    filePath?: string | DocumentFilePathFunction;
    preview?: DocumentPreview;
    actions?: CustomActionDocument[];
}
export interface ModelLocalized {
    /**
     * Boolean flag indicating if documents belonging to this model are localized.
     * If localized is set to true, provide the `locale` function to set the
     * document `locale`
     */
    localized?: boolean;
    /**
     * The `locale` function should return the locale for the passed `document`.
     */
    locale?: (options: {
        document: Document;
        /**
         * The model of the passed `document`.
         */
        model: DataModel | PageModel;
    }) => string;
}
export declare type DocumentFilePathFunction = (options: {
    data: Record<string, any>;
    model: DataModel | PageModel;
    currentLocale?: string;
}) => string;
//# sourceMappingURL=models.d.ts.map