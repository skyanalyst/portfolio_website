{"version":3,"file":"schema.js","names":["buildSchema","schemaComposer","types","typeMapping","fieldExtensions","thirdPartySchemas","printConfig","enginePrintConfig","typeConflictReporter","inferenceMetadata","parentSpan","getDataStore","ready","updateSchemaComposer","schema","freezeTypeComposers","excluded","Set","Array","from","values","forEach","tc","isCompositeTC","ObjectTypeComposer","InterfaceTypeComposer","has","getTypeName","type","getType","activity","report","phantomActivity","start","addTypes","span","end","addInferredTypes","addInferredChildOfExtensions","process","env","GATSBY_SKIP_WRITING_SCHEMA_TO_FILE","printTypeDefinitions","config","addSetFieldsOnGraphQLNodeTypeFields","addConvenienceChildrenFields","Promise","all","map","typeComposer","processTypeComposer","checkQueryableInterfaces","addThirdPartySchemas","addCustomResolveFunctions","attachTracingResolver","processFieldExtensions","hasInterface","addNodeInterfaceFields","addRemoteFileInterfaceFields","determineSearchableFields","addTypeToRootQuery","isNodeInterface","fieldNames","query","typeName","queryAll","convenienceChild","convenienceChildren","typeOrTypeDef","plugin","parseTypeDef","isASTDocument","parsedTypes","createdFrom","parseTypes","doc","error","reportParsingError","processAddedType","isGatsbyType","createTypeComposerFromGatsbyType","checkIsAllowedTypeName","get","mergeTypes","name","typeOwner","getExtension","isOverridableBuiltInType","overridableBuiltInTypeNames","isSafeMerge","hasExtension","warn","GraphQLObjectType","GraphQLInterfaceType","mergeFields","fields","getFields","getInterfaces","iface","addInterface","GraphQLUnionType","UnionTypeComposer","mergeResolveType","extensions","isNamedTypeComposer","convertDirectivesToExtensions","getDirectives","extendExtensions","getExtensions","addExtensions","add","getResolveType","setResolveType","node","internal","addSchemaMustHaveType","directives","args","setExtension","hasCorrectIdField","hasField","getFieldType","toString","panic","InputTypeComposer","getFieldNames","fieldName","setFieldExtension","getFieldDirectives","getFieldExtensions","Object","keys","filter","internalExtensionNames","includes","definition","getDirective","defaultValue","undefined","arg","argumentDef","find","value","validate","message","invariant","endsWith","builtInScalarTypeNames","assertValidName","kind","GatsbyGraphQLTypeKind","OBJECT","createTemp","typeMapper","convertOutputFieldConfigMap","interfaces","tmpComposer","createInterfaceTC","getIFTC","INPUT_OBJECT","convertInputFieldConfigMap","UNION","createObjectTC","getOTC","INTERFACE","ENUM","EnumTypeComposer","SCALAR","ScalarTypeComposer","JSON","stringify","result","apiRunnerNode","nodes","getNodesByType","traceId","addNestedFields","schemaQueryType","getQueryType","queryTC","createTempTC","processThirdPartyTypeFields","Query","addFields","getTypeMap","isSpecifiedScalarType","isIntrospectionType","typeHasFields","_fields","createTC","resetOverriddenThirdPartyTypeFields","getFieldExtension","removeField","fieldType","String","replace","extendField","intermediateSchema","createResolvers","resolvers","ignoreNonexistentTypes","fieldConfig","originalFieldConfig","getFieldConfig","originalTypeName","originalResolver","resolve","fieldTypeName","isArray","stringifyArray","newConfig","source","context","info","defaultFieldResolver","extendFieldExtensions","needsResolve","field","getField","resolver","wrappingResolver","defaultResolver","_schemaComposer","dateformat","searchable","SEARCHABLE_ENUM","SEARCHABLE","sortable","SORTABLE_ENUM","SORTABLE","proxy","DEPRECATED_SEARCHABLE","DEPRECATED_SORTABLE","parentTypesToChildren","Map","mimeTypesToChildren","typesHandlingMimeTypes","mimeType","set","mimeTypes","parentType","children","parent","getAnyTC","child","createChildrenField","createChildField","parentTypes","isExplicitChild","childTypeComposer","childOfExtension","parentMimeTypes","some","addInferredChildOfExtension","shouldInfer","parentTypeName","childNodeTypes","iterateNodesByType","getNode","childNode","push","description","_args","path","nodeModel","getNodesByIds","ids","length","filterInputTC","getFilterInput","paginationTC","getPagination","queryName","queryNamePlural","findOne","sort","getSortInputNestedObjects","skip","limit","findManyPaginated","makeFieldNonNull","definitions","def","parsedType","makeSchemaDef","ifaceName","_gqType","delete","arr","item","GraphQLNonNull","Error","ofType","GraphQLList","v","parseValue","interfaceTypeComposer","queryableInterfaces","incorrectTypes","size","t","join","entries","setField","resolveType"],"sources":["../../src/schema/schema.ts"],"sourcesContent":["import _ from \"lodash\"\nimport invariant from \"invariant\"\nimport {\n  isSpecifiedScalarType,\n  isIntrospectionType,\n  assertValidName,\n  GraphQLNonNull,\n  GraphQLList,\n  GraphQLObjectType,\n  GraphQLInterfaceType,\n  GraphQLUnionType,\n} from \"graphql\"\nimport {\n  ObjectTypeComposer,\n  InterfaceTypeComposer,\n  UnionTypeComposer,\n  InputTypeComposer,\n  ScalarTypeComposer,\n  EnumTypeComposer,\n} from \"graphql-compose\"\nimport { getDataStore, getNode, getNodesByType } from \"../datastore\"\n\nimport apiRunnerNode from \"../utils/api-runner-node\"\nimport report from \"../reporter\"\nimport { addNodeInterfaceFields } from \"./types/node-interface\"\nimport {\n  overridableBuiltInTypeNames,\n  builtInScalarTypeNames,\n} from \"./types/built-in-types\"\nimport { addInferredTypes } from \"./infer\"\nimport { addRemoteFileInterfaceFields } from \"./types/remote-file-interface\"\n\nimport {\n  findOne,\n  findManyPaginated,\n  wrappingResolver,\n  defaultResolver,\n} from \"./resolvers\"\nimport { processFieldExtensions, internalExtensionNames } from \"./extensions\"\nimport { getPagination } from \"./types/pagination\"\nimport {\n  SORTABLE_ENUM,\n  // getSortInput,\n  getSortInputNestedObjects,\n} from \"./types/sort\"\nimport { getFilterInput, SEARCHABLE_ENUM } from \"./types/filter\"\nimport { isGatsbyType, GatsbyGraphQLTypeKind } from \"./types/type-builders\"\n\nimport {\n  isASTDocument,\n  parseTypeDef,\n  reportParsingError,\n} from \"./types/type-defs\"\nimport { printTypeDefinitions } from \"./print\"\n\nconst buildSchema = async ({\n  schemaComposer,\n  types,\n  typeMapping,\n  fieldExtensions,\n  thirdPartySchemas,\n  printConfig,\n  enginePrintConfig,\n  typeConflictReporter,\n  inferenceMetadata,\n  parentSpan,\n}) => {\n  // FIXME: consider removing .ready here - it is needed for various tests to pass (although probably harmless)\n  await getDataStore().ready()\n  await updateSchemaComposer({\n    schemaComposer,\n    types,\n    typeMapping,\n    fieldExtensions,\n    thirdPartySchemas,\n    printConfig,\n    enginePrintConfig,\n    typeConflictReporter,\n    inferenceMetadata,\n    parentSpan,\n  })\n  // const { printSchema } = require(`graphql`)\n  const schema = schemaComposer.buildSchema()\n  freezeTypeComposers(schemaComposer)\n\n  // console.log(printSchema(schema))\n  return schema\n}\n\nexport { buildSchema }\n\n// Workaround for https://github.com/graphql-compose/graphql-compose/issues/319\n//  FIXME: remove this when fixed in graphql-compose\nconst freezeTypeComposers = (schemaComposer, excluded = new Set()) => {\n  Array.from(schemaComposer.values()).forEach(tc => {\n    const isCompositeTC =\n      tc instanceof ObjectTypeComposer || tc instanceof InterfaceTypeComposer\n\n    if (isCompositeTC && !excluded.has(tc.getTypeName())) {\n      // typeComposer.getType() actually mutates the underlying GraphQL type\n      //   and always re-assigns type._fields with a thunk.\n      //   It causes continuous redundant field re-definitions when running queries\n      //   (affects performance significantly).\n      //   Prevent the mutation and \"freeze\" the type:\n      const type = tc.getType()\n      // @ts-ignore\n      tc.getType = () => type\n    }\n  })\n}\n\nconst updateSchemaComposer = async ({\n  schemaComposer,\n  types,\n  typeMapping,\n  fieldExtensions,\n  thirdPartySchemas,\n  printConfig,\n  enginePrintConfig,\n  typeConflictReporter,\n  inferenceMetadata,\n  parentSpan,\n}) => {\n  let activity = report.phantomActivity(`Add explicit types`, {\n    parentSpan: parentSpan,\n  })\n  activity.start()\n  await addTypes({ schemaComposer, parentSpan: activity.span, types })\n  activity.end()\n\n  activity = report.phantomActivity(`Add inferred types`, {\n    parentSpan: parentSpan,\n  })\n  activity.start()\n  await addInferredTypes({\n    schemaComposer,\n    typeConflictReporter,\n    typeMapping,\n    inferenceMetadata,\n    parentSpan: activity.span,\n  })\n  addInferredChildOfExtensions({\n    schemaComposer,\n  })\n  activity.end()\n\n  activity = report.phantomActivity(`Processing types`, {\n    parentSpan: parentSpan,\n  })\n  activity.start()\n  if (!process.env.GATSBY_SKIP_WRITING_SCHEMA_TO_FILE) {\n    await printTypeDefinitions({\n      config: printConfig,\n      schemaComposer,\n      // parentSpan: activity.span,\n    })\n    if (enginePrintConfig) {\n      // make sure to print schema that will be used when bundling graphql-engine\n      await printTypeDefinitions({\n        config: enginePrintConfig,\n        schemaComposer,\n        // parentSpan: activity.span,\n      })\n    }\n  }\n  await addSetFieldsOnGraphQLNodeTypeFields({\n    schemaComposer,\n    parentSpan: activity.span,\n  })\n  await addConvenienceChildrenFields({\n    schemaComposer,\n    // parentSpan: activity.span,\n  })\n  await Promise.all(\n    Array.from(new Set(schemaComposer.values())).map(typeComposer =>\n      processTypeComposer({\n        schemaComposer,\n        typeComposer,\n        fieldExtensions,\n        parentSpan: activity.span,\n      })\n    )\n  )\n  checkQueryableInterfaces({\n    schemaComposer,\n    // parentSpan: activity.span\n  })\n  await addThirdPartySchemas({\n    schemaComposer,\n    thirdPartySchemas,\n    // @ts-ignore\n    parentSpan: activity.span,\n  })\n  await addCustomResolveFunctions({ schemaComposer, parentSpan: activity.span })\n  attachTracingResolver({\n    schemaComposer,\n    // parentSpan: activity.span\n  })\n  activity.end()\n}\n\nconst processTypeComposer = async ({\n  schemaComposer,\n  typeComposer,\n  fieldExtensions,\n  parentSpan,\n}) => {\n  if (typeComposer instanceof ObjectTypeComposer) {\n    await processFieldExtensions({\n      schemaComposer,\n      typeComposer,\n      fieldExtensions,\n      parentSpan,\n    })\n\n    if (typeComposer.hasInterface(`Node`)) {\n      await addNodeInterfaceFields({ schemaComposer, typeComposer })\n    }\n\n    if (typeComposer.hasInterface(`RemoteFile`)) {\n      addRemoteFileInterfaceFields(schemaComposer, typeComposer)\n    }\n\n    await determineSearchableFields({\n      schemaComposer,\n      typeComposer,\n      // parentSpan,\n    })\n\n    if (typeComposer.hasInterface(`Node`)) {\n      await addTypeToRootQuery({\n        schemaComposer,\n        typeComposer,\n        // parentSpan\n      })\n    }\n  } else if (typeComposer instanceof InterfaceTypeComposer) {\n    if (isNodeInterface(typeComposer)) {\n      await addNodeInterfaceFields({\n        // @ts-ignore\n        schemaComposer,\n        // @ts-ignore\n        typeComposer,\n        // parentSpan\n      })\n\n      // We only process field extensions for queryable Node interfaces, so we get\n      // the input args on the root query type, e.g. `formatString` etc. for `dateformat`\n      await processFieldExtensions({\n        schemaComposer,\n        typeComposer,\n        fieldExtensions,\n        parentSpan,\n      })\n      await determineSearchableFields({\n        schemaComposer,\n        typeComposer,\n        // parentSpan,\n      })\n      await addTypeToRootQuery({\n        schemaComposer,\n        typeComposer,\n        // parentSpan\n      })\n    }\n  }\n}\n\nconst fieldNames = {\n  query: typeName => _.camelCase(typeName),\n  queryAll: typeName => _.camelCase(`all ${typeName}`),\n  convenienceChild: typeName => _.camelCase(`child ${typeName}`),\n  convenienceChildren: typeName => _.camelCase(`children ${typeName}`),\n}\n\nconst addTypes = ({ schemaComposer, types, parentSpan }) => {\n  types.forEach(({ typeOrTypeDef, plugin }) => {\n    if (typeof typeOrTypeDef === `string`) {\n      typeOrTypeDef = parseTypeDef(typeOrTypeDef)\n    }\n\n    if (isASTDocument(typeOrTypeDef)) {\n      let parsedTypes\n      const createdFrom = `sdl`\n      try {\n        parsedTypes = parseTypes({\n          doc: typeOrTypeDef,\n          plugin,\n          createdFrom,\n          schemaComposer,\n          parentSpan,\n        })\n      } catch (error) {\n        reportParsingError(error)\n        return\n      }\n      parsedTypes.forEach(type => {\n        processAddedType({\n          schemaComposer,\n          type,\n          // parentSpan,\n          createdFrom,\n          plugin,\n        })\n      })\n    } else if (isGatsbyType(typeOrTypeDef)) {\n      const type = createTypeComposerFromGatsbyType({\n        schemaComposer,\n        type: typeOrTypeDef,\n        // parentSpan,\n      })\n\n      if (type) {\n        const typeName = type.getTypeName()\n        const createdFrom = `typeBuilder`\n        checkIsAllowedTypeName(typeName)\n        if (schemaComposer.has(typeName)) {\n          const typeComposer = schemaComposer.get(typeName)\n          mergeTypes({\n            schemaComposer,\n            typeComposer,\n            type,\n            plugin,\n            createdFrom,\n            // parentSpan,\n          })\n        } else {\n          processAddedType({\n            schemaComposer,\n            type,\n            // parentSpan,\n            createdFrom,\n            plugin,\n          })\n        }\n      }\n    } else {\n      const typeName = typeOrTypeDef.name\n      const createdFrom = `graphql-js`\n      checkIsAllowedTypeName(typeName)\n      if (schemaComposer.has(typeName)) {\n        const typeComposer = schemaComposer.get(typeName)\n        mergeTypes({\n          schemaComposer,\n          typeComposer,\n          type: typeOrTypeDef,\n          plugin,\n          createdFrom,\n          // parentSpan,\n        })\n      } else {\n        processAddedType({\n          schemaComposer,\n          type: typeOrTypeDef,\n          // parentSpan,\n          createdFrom,\n          plugin,\n        })\n      }\n    }\n  })\n}\n\nconst mergeTypes = ({\n  schemaComposer,\n  typeComposer,\n  type,\n  plugin,\n  createdFrom,\n  // parentSpan,\n}) => {\n  // The merge is considered safe when a user or a plugin owning the type extend this type\n  // TODO: add proper conflicts detection and reporting (on the field level)\n  const typeOwner = typeComposer.getExtension(`plugin`)\n  const isOverridableBuiltInType =\n    !typeOwner && overridableBuiltInTypeNames.has(typeComposer.getTypeName())\n\n  const isSafeMerge =\n    !plugin ||\n    plugin.name === `default-site-plugin` ||\n    plugin.name === typeOwner ||\n    typeComposer.hasExtension(`isPlaceholder`) ||\n    isOverridableBuiltInType\n\n  if (!isSafeMerge) {\n    if (typeOwner) {\n      report.warn(\n        `Plugin \\`${plugin.name}\\` has customized the GraphQL type ` +\n          `\\`${typeComposer.getTypeName()}\\`, which has already been defined ` +\n          `by the plugin \\`${typeOwner}\\`. ` +\n          `This could potentially cause conflicts.`\n      )\n    } else {\n      report.warn(\n        `Plugin \\`${plugin.name}\\` has customized the built-in Gatsby GraphQL type ` +\n          `\\`${typeComposer.getTypeName()}\\`. ` +\n          `This is allowed, but could potentially cause conflicts.`\n      )\n    }\n  }\n\n  if (\n    type instanceof ObjectTypeComposer ||\n    type instanceof InterfaceTypeComposer ||\n    type instanceof GraphQLObjectType ||\n    type instanceof GraphQLInterfaceType\n  ) {\n    mergeFields({ typeComposer, fields: type.getFields() })\n    type.getInterfaces().forEach(iface => typeComposer.addInterface(iface))\n  }\n\n  if (\n    type instanceof GraphQLInterfaceType ||\n    type instanceof InterfaceTypeComposer ||\n    type instanceof GraphQLUnionType ||\n    type instanceof UnionTypeComposer\n  ) {\n    mergeResolveType({ typeComposer, type })\n  }\n\n  let extensions = {}\n  if (isNamedTypeComposer(type)) {\n    if (createdFrom === `sdl`) {\n      extensions = convertDirectivesToExtensions(type, type.getDirectives())\n    } else {\n      typeComposer.extendExtensions(type.getExtensions())\n    }\n  }\n\n  addExtensions({\n    schemaComposer,\n    typeComposer,\n    extensions,\n    plugin,\n    createdFrom,\n  })\n\n  return true\n}\n\nconst processAddedType = ({\n  schemaComposer,\n  type,\n  // parentSpan,\n  createdFrom,\n  plugin,\n}) => {\n  const typeName = schemaComposer.add(type)\n  const typeComposer = schemaComposer.get(typeName)\n  if (\n    typeComposer instanceof InterfaceTypeComposer ||\n    typeComposer instanceof UnionTypeComposer\n  ) {\n    if (!typeComposer.getResolveType()) {\n      typeComposer.setResolveType(node => node.internal.type)\n    }\n  }\n  schemaComposer.addSchemaMustHaveType(typeComposer)\n  let extensions = {}\n  if (createdFrom === `sdl`) {\n    extensions = convertDirectivesToExtensions(\n      typeComposer,\n      typeComposer.getDirectives()\n    )\n  }\n\n  addExtensions({\n    schemaComposer,\n    typeComposer,\n    extensions,\n    plugin,\n    createdFrom,\n  })\n\n  return typeComposer\n}\n\n/**\n * @param {import(\"graphql-compose\").AnyTypeComposer} typeComposer\n * @param {Array<import(\"graphql-compose\").Directive>} directives\n * @return {{infer?: boolean, mimeTypes?: { types: Array<string> }, childOf?: { types: Array<string> }, nodeInterface?: boolean}}\n */\nconst convertDirectivesToExtensions = (typeComposer, directives) => {\n  const extensions = {}\n  directives.forEach(({ name, args }) => {\n    switch (name) {\n      case `infer`:\n      case `dontInfer`: {\n        extensions[`infer`] = name === `infer`\n        break\n      }\n      case `mimeTypes`:\n        extensions[`mimeTypes`] = args\n        break\n      case `childOf`:\n        extensions[`childOf`] = args\n        break\n      case `nodeInterface`:\n        if (typeComposer instanceof InterfaceTypeComposer) {\n          extensions[`nodeInterface`] = true\n        }\n        break\n      default:\n    }\n  })\n\n  return extensions\n}\n\nconst addExtensions = ({\n  schemaComposer,\n  typeComposer,\n  extensions = {},\n  plugin,\n  createdFrom,\n}) => {\n  typeComposer.setExtension(`createdFrom`, createdFrom)\n  typeComposer.setExtension(`plugin`, plugin ? plugin.name : null)\n  typeComposer.extendExtensions(extensions)\n\n  if (\n    typeComposer instanceof InterfaceTypeComposer &&\n    isNodeInterface(typeComposer)\n  ) {\n    const hasCorrectIdField =\n      typeComposer.hasField(`id`) &&\n      typeComposer.getFieldType(`id`).toString() === `ID!`\n\n    if (!hasCorrectIdField) {\n      report.panic(\n        `Interfaces with the \\`nodeInterface\\` extension must have a field ` +\n          `\\`id\\` of type \\`ID!\\`. Check the type definition of ` +\n          `\\`${typeComposer.getTypeName()}\\`.`\n      )\n    }\n  }\n\n  if (\n    typeComposer instanceof ObjectTypeComposer ||\n    typeComposer instanceof InterfaceTypeComposer ||\n    typeComposer instanceof InputTypeComposer\n  ) {\n    typeComposer.getFieldNames().forEach(fieldName => {\n      typeComposer.setFieldExtension(fieldName, `createdFrom`, createdFrom)\n      typeComposer.setFieldExtension(\n        fieldName,\n        `plugin`,\n        plugin ? plugin.name : null\n      )\n\n      if (createdFrom === `sdl`) {\n        const directives = typeComposer.getFieldDirectives(fieldName)\n        directives.forEach(({ name, args }) => {\n          typeComposer.setFieldExtension(fieldName, name, args)\n        })\n      }\n\n      // Validate field extension args. `graphql-compose` already checks the\n      // type of directive args in `parseDirectives`, but we want to check\n      // extensions provided with type builders as well. Also, we warn if an\n      // extension option was provided which does not exist in the field\n      // extension definition.\n      const fieldExtensions = typeComposer.getFieldExtensions(fieldName)\n      const typeName = typeComposer.getTypeName()\n      Object.keys(fieldExtensions)\n        .filter(name => !internalExtensionNames.includes(name))\n        .forEach(name => {\n          const args = fieldExtensions[name]\n\n          if (!args || typeof args !== `object`) {\n            report.error(\n              `Field extension arguments must be provided as an object. ` +\n                `Received \"${args}\" on \\`${typeName}.${fieldName}\\`.`\n            )\n            return\n          }\n\n          try {\n            const definition = schemaComposer.getDirective(name)\n\n            // Handle `defaultValue` when not provided as directive\n            definition.args.forEach(({ name, defaultValue }) => {\n              if (args[name] === undefined && defaultValue !== undefined) {\n                args[name] = defaultValue\n              }\n            })\n\n            Object.keys(args).forEach(arg => {\n              const argumentDef = definition.args.find(\n                ({ name }) => name === arg\n              )\n              if (!argumentDef) {\n                report.error(\n                  `Field extension \\`${name}\\` on \\`${typeName}.${fieldName}\\` ` +\n                    `has invalid argument \\`${arg}\\`.`\n                )\n                return\n              }\n              const value = args[arg]\n              try {\n                validate(argumentDef.type, value)\n              } catch (error) {\n                report.error(\n                  `Field extension \\`${name}\\` on \\`${typeName}.${fieldName}\\` ` +\n                    `has argument \\`${arg}\\` with invalid value \"${value}\". ` +\n                    error.message\n                )\n              }\n            })\n          } catch (error) {\n            report.error(\n              `Field extension \\`${name}\\` on \\`${typeName}.${fieldName}\\` ` +\n                `is not available.`\n            )\n          }\n        })\n    })\n  }\n\n  return typeComposer\n}\n\nconst checkIsAllowedTypeName = name => {\n  invariant(\n    name !== `Node`,\n    `The GraphQL type \\`Node\\` is reserved for internal use.`\n  )\n  invariant(\n    !name.endsWith(`FilterInput`) && !name.endsWith(`SortInput`),\n    `GraphQL type names ending with \"FilterInput\" or \"SortInput\" are ` +\n      `reserved for internal use. Please rename \\`${name}\\`.`\n  )\n  invariant(\n    !builtInScalarTypeNames.includes(name),\n    `The GraphQL type \\`${name}\\` is reserved for internal use by ` +\n      `built-in scalar types.`\n  )\n  assertValidName(name)\n}\n\nconst createTypeComposerFromGatsbyType = ({ schemaComposer, type }) => {\n  let typeComposer\n  switch (type.kind) {\n    case GatsbyGraphQLTypeKind.OBJECT: {\n      typeComposer = ObjectTypeComposer.createTemp({\n        ...type.config,\n        fields: () =>\n          schemaComposer.typeMapper.convertOutputFieldConfigMap(\n            type.config.fields\n          ),\n        interfaces: () => {\n          if (type.config.interfaces) {\n            return type.config.interfaces.map(iface => {\n              if (typeof iface === `string`) {\n                // Sadly, graphql-compose runs this function too early - before we have\n                // all of those interfaces actually created in the schema, so have to create\n                // a temporary placeholder composer :/\n                if (!schemaComposer.has(iface)) {\n                  const tmpComposer = schemaComposer.createInterfaceTC(iface)\n                  tmpComposer.setExtension(`isPlaceholder`, true)\n                  return tmpComposer\n                }\n                return schemaComposer.getIFTC(iface)\n              } else {\n                return iface\n              }\n            })\n          } else {\n            return []\n          }\n        },\n      })\n      break\n    }\n    case GatsbyGraphQLTypeKind.INPUT_OBJECT: {\n      typeComposer = InputTypeComposer.createTemp({\n        ...type.config,\n        fields: schemaComposer.typeMapper.convertInputFieldConfigMap(\n          type.config.fields\n        ),\n      })\n      break\n    }\n    case GatsbyGraphQLTypeKind.UNION: {\n      typeComposer = UnionTypeComposer.createTemp({\n        ...type.config,\n        types: () => {\n          if (type.config.types) {\n            return type.config.types.map(typeName => {\n              if (!schemaComposer.has(typeName)) {\n                // Sadly, graphql-compose runs this function too early - before we have\n                // all of those types actually created in the schema, so have to create\n                // a temporary placeholder composer :/\n                const tmpComposer = schemaComposer.createObjectTC(typeName)\n                tmpComposer.setExtension(`isPlaceholder`, true)\n                return tmpComposer\n              }\n              return schemaComposer.getOTC(typeName)\n            })\n          } else {\n            return []\n          }\n        },\n      })\n      break\n    }\n    case GatsbyGraphQLTypeKind.INTERFACE: {\n      typeComposer = InterfaceTypeComposer.createTemp({\n        ...type.config,\n        fields: () =>\n          schemaComposer.typeMapper.convertOutputFieldConfigMap(\n            type.config.fields\n          ),\n        interfaces: () => {\n          if (type.config.interfaces) {\n            return type.config.interfaces.map(iface => {\n              if (typeof iface === `string`) {\n                // Sadly, graphql-compose runs this function too early - before we have\n                // all of those interfaces actually created in the schema, so have to create\n                // a temporary placeholder composer :/\n                if (!schemaComposer.has(iface)) {\n                  const tmpComposer = schemaComposer.createInterfaceTC(iface)\n                  tmpComposer.setExtension(`isPlaceholder`, true)\n                  return tmpComposer\n                }\n                return schemaComposer.getIFTC(iface)\n              } else {\n                return iface\n              }\n            })\n          } else {\n            return []\n          }\n        },\n      })\n      break\n    }\n    case GatsbyGraphQLTypeKind.ENUM: {\n      typeComposer = EnumTypeComposer.createTemp(type.config)\n      break\n    }\n    case GatsbyGraphQLTypeKind.SCALAR: {\n      typeComposer = ScalarTypeComposer.createTemp(type.config)\n      break\n    }\n    default: {\n      report.warn(`Illegal type definition: ${JSON.stringify(type.config)}`)\n      typeComposer = null\n    }\n  }\n  if (typeComposer) {\n    // Workaround for https://github.com/graphql-compose/graphql-compose/issues/311\n    typeComposer.schemaComposer = schemaComposer\n  }\n  return typeComposer\n}\n\nconst addSetFieldsOnGraphQLNodeTypeFields = ({ schemaComposer, parentSpan }) =>\n  Promise.all(\n    Array.from(schemaComposer.values()).map(async tc => {\n      if (tc instanceof ObjectTypeComposer && tc.hasInterface(`Node`)) {\n        const typeName = tc.getTypeName()\n        const result = await apiRunnerNode(`setFieldsOnGraphQLNodeType`, {\n          type: {\n            name: typeName,\n            get nodes() {\n              // TODO STRICT_MODE: return iterator instead of array\n              return getNodesByType(typeName)\n            },\n          },\n          traceId: `initial-setFieldsOnGraphQLNodeType`,\n          parentSpan,\n        })\n        if (result) {\n          // NOTE: `setFieldsOnGraphQLNodeType` only allows setting\n          // nested fields with a path as property name, i.e.\n          // `{ 'frontmatter.published': 'Boolean' }`, but not in the form\n          // `{ frontmatter: { published: 'Boolean' }}`\n          // @ts-ignore\n          result.forEach(fields => tc.addNestedFields(fields))\n        }\n      }\n    })\n  )\n\nconst addThirdPartySchemas = ({\n  schemaComposer,\n  thirdPartySchemas,\n  // parentSpan,\n}) => {\n  thirdPartySchemas.forEach(schema => {\n    const schemaQueryType = schema.getQueryType()\n    const queryTC = schemaComposer.createTempTC(schemaQueryType)\n    processThirdPartyTypeFields({\n      typeComposer: queryTC,\n      type: schemaQueryType,\n      schemaQueryType,\n    })\n    schemaComposer.Query.addFields(queryTC.getFields())\n\n    // Explicitly add the third-party schema's types, so they can be targeted\n    // in `createResolvers` API.\n    const types = schema.getTypeMap()\n    Object.keys(types).forEach(typeName => {\n      const type = types[typeName]\n      if (\n        type !== schemaQueryType &&\n        !isSpecifiedScalarType(type) &&\n        !isIntrospectionType(type) &&\n        type.name !== `Date` &&\n        type.name !== `JSON`\n      ) {\n        const typeHasFields =\n          type instanceof GraphQLObjectType ||\n          type instanceof GraphQLInterfaceType\n\n        // Workaround for an edge case typical for Relay Classic-compatible schemas.\n        // For example, GitHub API contains this piece:\n        //   type Query { relay: Query }\n        // And gatsby-source-graphql transforms it to:\n        //   type Query { github: GitHub }\n        //   type GitHub { relay: Query }\n        // The problem:\n        //   schemaComposer.createTC(type) for type `GitHub` will eagerly create type composers\n        //   for all fields (including `relay` and it's type: `Query` of the third-party schema)\n        //   This unexpected `Query` composer messes up with our own Query type composer and produces duplicate types.\n        //   The workaround is to make sure fields of the GitHub type are lazy and are evaluated only when\n        //   this Query type is already replaced with our own root `Query` type (see processThirdPartyTypeFields):\n        // @ts-ignore\n        if (typeHasFields && typeof type._fields === `object`) {\n          // @ts-ignore\n          const fields = type._fields\n          // @ts-ignore\n          type._fields = () => fields\n        }\n        // ^^^ workaround done\n        const typeComposer = schemaComposer.createTC(type)\n        if (typeHasFields) {\n          processThirdPartyTypeFields({\n            typeComposer,\n            type,\n            schemaQueryType,\n          })\n        }\n        typeComposer.setExtension(`createdFrom`, `thirdPartySchema`)\n        schemaComposer.addSchemaMustHaveType(typeComposer)\n      }\n    })\n  })\n}\n\nconst resetOverriddenThirdPartyTypeFields = ({ typeComposer }) => {\n  // The problem: createResolvers API mutates third party schema instance.\n  //   For example it can add a new field referencing a type from our main schema\n  //   Then if we rebuild the schema this old type instance will sneak into\n  //   the new schema and produce the famous error:\n  //   \"Schema must contain uniquely named types but contains multiple types named X\"\n  // This function only affects schema rebuilding pathway.\n  //   It cleans up artifacts created by the `createResolvers` API of the previous build\n  //   so that we return the third party schema to its initial state (hence can safely re-add)\n  // TODO: the right way to fix this would be not to mutate the third party schema in\n  //   the first place. But unfortunately mutation happens in the `graphql-compose`\n  //   and we don't have an easy way to avoid it without major rework\n  typeComposer.getFieldNames().forEach(fieldName => {\n    const createdFrom = typeComposer.getFieldExtension(fieldName, `createdFrom`)\n    if (createdFrom === `createResolvers`) {\n      typeComposer.removeField(fieldName)\n      return\n    }\n    const config = typeComposer.getFieldExtension(\n      fieldName,\n      `originalFieldConfig`\n    )\n    if (config) {\n      typeComposer.removeField(fieldName)\n      typeComposer.addFields({\n        [fieldName]: config,\n      })\n    }\n  })\n}\n\nconst processThirdPartyTypeFields = ({\n  typeComposer,\n  type,\n  schemaQueryType,\n}) => {\n  // Fix for types that refer to Query. Thanks Relay Classic!\n  const fields = type.getFields()\n  Object.keys(fields).forEach(fieldName => {\n    // Remove customization that we could have added via `createResolvers`\n    // to make it work with schema rebuilding\n    const fieldType = String(fields[fieldName].type)\n    if (fieldType.replace(/[[\\]!]/g, ``) === schemaQueryType.name) {\n      typeComposer.extendField(fieldName, {\n        type: fieldType.replace(schemaQueryType.name, `Query`),\n      })\n    }\n  })\n  resetOverriddenThirdPartyTypeFields({ typeComposer })\n}\n\nconst addCustomResolveFunctions = async ({ schemaComposer, parentSpan }) => {\n  const intermediateSchema = schemaComposer.buildSchema()\n  const createResolvers = (\n    resolvers,\n    { ignoreNonexistentTypes = false } = {}\n  ) => {\n    Object.keys(resolvers).forEach(typeName => {\n      const fields = resolvers[typeName]\n      if (schemaComposer.has(typeName)) {\n        const tc = schemaComposer.getOTC(typeName)\n        Object.keys(fields).forEach(fieldName => {\n          const fieldConfig = fields[fieldName]\n          if (tc.hasField(fieldName)) {\n            const originalFieldConfig = tc.getFieldConfig(fieldName)\n            const originalTypeName = originalFieldConfig.type.toString()\n            const originalResolver = originalFieldConfig.resolve\n            let fieldTypeName\n            if (fieldConfig.type) {\n              fieldTypeName = Array.isArray(fieldConfig.type)\n                ? stringifyArray(fieldConfig.type)\n                : fieldConfig.type.toString()\n            }\n\n            if (\n              !fieldTypeName ||\n              fieldTypeName.replace(/!/g, ``) ===\n                originalTypeName.replace(/!/g, ``) ||\n              tc.getExtension(`createdFrom`) === `thirdPartySchema`\n            ) {\n              const newConfig = {}\n              if (fieldConfig.type) {\n                // @ts-ignore\n                newConfig.type = fieldConfig.type\n              }\n              if (fieldConfig.args) {\n                // @ts-ignore\n                newConfig.args = fieldConfig.args\n              }\n              if (fieldConfig.resolve) {\n                // @ts-ignore\n                newConfig.resolve = (source, args, context, info) =>\n                  fieldConfig.resolve(source, args, context, {\n                    ...info,\n                    originalResolver:\n                      originalResolver || context.defaultFieldResolver,\n                  })\n                tc.extendFieldExtensions(fieldName, {\n                  needsResolve: true,\n                })\n              }\n              tc.extendField(fieldName, newConfig)\n\n              // See resetOverriddenThirdPartyTypeFields for explanation\n              if (tc.getExtension(`createdFrom`) === `thirdPartySchema`) {\n                tc.setFieldExtension(\n                  fieldName,\n                  `originalFieldConfig`,\n                  originalFieldConfig\n                )\n              }\n            } else if (fieldTypeName) {\n              report.warn(\n                `\\`createResolvers\\` passed resolvers for field ` +\n                  `\\`${typeName}.${fieldName}\\` with type \\`${fieldTypeName}\\`. ` +\n                  `Such a field with type \\`${originalTypeName}\\` already exists ` +\n                  `on the type. Use \\`createTypes\\` to override type fields.`\n              )\n            }\n          } else {\n            tc.addFields({\n              [fieldName]: fieldConfig,\n            })\n            // See resetOverriddenThirdPartyTypeFields for explanation\n            tc.setFieldExtension(fieldName, `createdFrom`, `createResolvers`)\n          }\n        })\n      } else if (!ignoreNonexistentTypes) {\n        report.warn(\n          `\\`createResolvers\\` passed resolvers for type \\`${typeName}\\` that ` +\n            `doesn't exist in the schema. Use \\`createTypes\\` to add the type ` +\n            `before adding resolvers.`\n        )\n      }\n    })\n  }\n  await apiRunnerNode(`createResolvers`, {\n    intermediateSchema,\n    createResolvers,\n    traceId: `initial-createResolvers`,\n    parentSpan,\n  })\n}\n\nfunction attachTracingResolver({ schemaComposer }) {\n  schemaComposer.forEach(typeComposer => {\n    if (\n      typeComposer instanceof ObjectTypeComposer ||\n      typeComposer instanceof InterfaceTypeComposer\n    ) {\n      typeComposer.getFieldNames().forEach(fieldName => {\n        const field = typeComposer.getField(fieldName)\n        const resolver = wrappingResolver(field.resolve || defaultResolver)\n        typeComposer.extendField(fieldName, {\n          resolve: resolver,\n        })\n      })\n    }\n  })\n}\n\nconst determineSearchableFields = ({\n  schemaComposer: _schemaComposer,\n  typeComposer,\n}) => {\n  typeComposer.getFieldNames().forEach(fieldName => {\n    const field = typeComposer.getField(fieldName)\n    const extensions = typeComposer.getFieldExtensions(fieldName)\n    if (field.resolve) {\n      if (extensions.dateformat) {\n        typeComposer.extendFieldExtensions(fieldName, {\n          searchable: SEARCHABLE_ENUM.SEARCHABLE,\n          sortable: SORTABLE_ENUM.SORTABLE,\n          needsResolve: extensions.proxy ? true : false,\n        })\n      } else if (!_.isEmpty(field.args)) {\n        typeComposer.extendFieldExtensions(fieldName, {\n          searchable: SEARCHABLE_ENUM.DEPRECATED_SEARCHABLE,\n          sortable: SORTABLE_ENUM.DEPRECATED_SORTABLE,\n          needsResolve: true,\n        })\n      } else {\n        typeComposer.extendFieldExtensions(fieldName, {\n          searchable: SEARCHABLE_ENUM.SEARCHABLE,\n          sortable: SORTABLE_ENUM.SORTABLE,\n          needsResolve: true,\n        })\n      }\n    } else {\n      typeComposer.extendFieldExtensions(fieldName, {\n        searchable: SEARCHABLE_ENUM.SEARCHABLE,\n        sortable: SORTABLE_ENUM.SORTABLE,\n        needsResolve: false,\n      })\n    }\n  })\n}\n\nconst addConvenienceChildrenFields = ({ schemaComposer }) => {\n  const parentTypesToChildren = new Map()\n  const mimeTypesToChildren = new Map()\n  const typesHandlingMimeTypes = new Map()\n\n  schemaComposer.forEach(type => {\n    if (\n      (type instanceof ObjectTypeComposer ||\n        type instanceof InterfaceTypeComposer) &&\n      type.hasExtension(`mimeTypes`)\n    ) {\n      // @ts-ignore\n      const { types } = type.getExtension(`mimeTypes`)\n      new Set(types).forEach(mimeType => {\n        if (!typesHandlingMimeTypes.has(mimeType)) {\n          typesHandlingMimeTypes.set(mimeType, new Set())\n        }\n        typesHandlingMimeTypes.get(mimeType).add(type)\n      })\n    }\n\n    if (\n      (type instanceof ObjectTypeComposer ||\n        type instanceof InterfaceTypeComposer) &&\n      type.hasExtension(`childOf`)\n    ) {\n      if (type instanceof ObjectTypeComposer && !type.hasInterface(`Node`)) {\n        report.error(\n          `The \\`childOf\\` extension can only be used on types that implement the \\`Node\\` interface.\\n` +\n            `Check the type definition of \\`${type.getTypeName()}\\`.`\n        )\n        return\n      }\n      if (type instanceof InterfaceTypeComposer && !isNodeInterface(type)) {\n        report.error(\n          `The \\`childOf\\` extension can only be used on types that implement the \\`Node\\` interface.\\n` +\n            `Check the type definition of \\`${type.getTypeName()}\\`.`\n        )\n        return\n      }\n\n      // @ts-ignore\n      const { types, mimeTypes } = type.getExtension(`childOf`)\n\n      new Set(types).forEach(parentType => {\n        if (!parentTypesToChildren.has(parentType)) {\n          parentTypesToChildren.set(parentType, new Set())\n        }\n        parentTypesToChildren.get(parentType).add(type)\n      })\n      new Set(mimeTypes).forEach(mimeType => {\n        if (!mimeTypesToChildren.has(mimeType)) {\n          mimeTypesToChildren.set(mimeType, new Set())\n        }\n        mimeTypesToChildren.get(mimeType).add(type)\n      })\n    }\n  })\n\n  parentTypesToChildren.forEach((children, parent) => {\n    if (!schemaComposer.has(parent)) return\n    const typeComposer = schemaComposer.getAnyTC(parent)\n    if (\n      typeComposer instanceof InterfaceTypeComposer &&\n      !isNodeInterface(typeComposer)\n    ) {\n      report.error(\n        `With the \\`childOf\\` extension, children fields can only be added to ` +\n          `interfaces which implement the \\`Node\\` interface.\\n` +\n          `Check the type definition of \\`${typeComposer.getTypeName()}\\`.`\n      )\n      return\n    }\n    children.forEach(child => {\n      typeComposer.addFields(createChildrenField(child.getTypeName()))\n      typeComposer.addFields(createChildField(child.getTypeName()))\n    })\n  })\n\n  mimeTypesToChildren.forEach((children, mimeType) => {\n    const parentTypes = typesHandlingMimeTypes.get(mimeType)\n    if (parentTypes) {\n      parentTypes.forEach(typeComposer => {\n        if (\n          typeComposer instanceof InterfaceTypeComposer &&\n          !isNodeInterface(typeComposer)\n        ) {\n          report.error(\n            `With the \\`childOf\\` extension, children fields can only be added to ` +\n              `interfaces which implement the \\`Node\\` interface.\\n` +\n              `Check the type definition of \\`${typeComposer.getTypeName()}\\`.`\n          )\n          return\n        }\n        children.forEach(child => {\n          typeComposer.addFields(createChildrenField(child.getTypeName()))\n          typeComposer.addFields(createChildField(child.getTypeName()))\n        })\n      })\n    }\n  })\n}\n\nconst isExplicitChild = ({ typeComposer, childTypeComposer }) => {\n  if (!childTypeComposer.hasExtension(`childOf`)) {\n    return false\n  }\n  const childOfExtension = childTypeComposer.getExtension(`childOf`)\n  const { types: parentMimeTypes = [] } =\n    typeComposer.getExtension(`mimeTypes`) ?? {}\n\n  return (\n    childOfExtension?.types?.includes(typeComposer.getTypeName()) ||\n    childOfExtension?.mimeTypes?.some(mimeType =>\n      parentMimeTypes.includes(mimeType)\n    )\n  )\n}\n\nconst addInferredChildOfExtensions = ({ schemaComposer }) => {\n  schemaComposer.forEach(typeComposer => {\n    if (\n      typeComposer instanceof ObjectTypeComposer &&\n      typeComposer.hasInterface(`Node`)\n    ) {\n      addInferredChildOfExtension({\n        schemaComposer,\n        typeComposer,\n      })\n    }\n  })\n}\n\nconst addInferredChildOfExtension = ({ schemaComposer, typeComposer }) => {\n  const shouldInfer = typeComposer.getExtension(`infer`)\n  // With `@dontInfer`, only parent-child\n  // relations explicitly set with the `@childOf` extension are added.\n  if (shouldInfer === false) return\n\n  const parentTypeName = typeComposer.getTypeName()\n\n  // This is expensive.\n  // TODO: We should probably collect this info during inference metadata pass\n  const childNodeTypes = new Set()\n  for (const node of getDataStore().iterateNodesByType(parentTypeName)) {\n    const children = (node.children || []).map(getNode)\n    for (const childNode of children) {\n      if (childNode?.internal?.type) {\n        childNodeTypes.add(childNode.internal.type)\n      }\n    }\n  }\n\n  childNodeTypes.forEach(typeName => {\n    const childTypeComposer = schemaComposer.getAnyTC(typeName)\n    let childOfExtension = childTypeComposer.getExtension(`childOf`)\n\n    if (isExplicitChild({ typeComposer, childTypeComposer })) {\n      return\n    }\n    // Set `@childOf` extension automatically\n    // This will cause convenience children fields like `childImageSharp`\n    // to be added in `addConvenienceChildrenFields` method.\n    // Also required for proper printing of the `@childOf` directive in the snapshot plugin\n    if (!childOfExtension) {\n      childOfExtension = {}\n    }\n    if (!childOfExtension.types) {\n      childOfExtension.types = []\n    }\n    childOfExtension.types.push(parentTypeName)\n    childTypeComposer.setExtension(`childOf`, childOfExtension)\n  })\n}\n\nconst createChildrenField = typeName => {\n  return {\n    [fieldNames.convenienceChildren(typeName)]: {\n      type: () => [typeName],\n      description: `Returns all children nodes filtered by type ${typeName}`,\n      resolve(source, _args, context) {\n        const { path } = context\n        return context.nodeModel.getNodesByIds(\n          { ids: source.children, type: typeName },\n          { path }\n        )\n      },\n    },\n  }\n}\n\nconst createChildField = typeName => {\n  return {\n    [fieldNames.convenienceChild(typeName)]: {\n      type: () => typeName,\n      description:\n        `Returns the first child node of type ${typeName} ` +\n        `or null if there are no children of given type on this node`,\n      resolve(source, _args, context) {\n        const { path } = context\n        const result = context.nodeModel.getNodesByIds(\n          { ids: source.children, type: typeName },\n          { path }\n        )\n        if (result && result.length > 0) {\n          return result[0]\n        } else {\n          return null\n        }\n      },\n    },\n  }\n}\n\nconst addTypeToRootQuery = ({ schemaComposer, typeComposer }) => {\n  const filterInputTC = getFilterInput({\n    schemaComposer,\n    typeComposer,\n  })\n  const paginationTC = getPagination({\n    schemaComposer,\n    typeComposer,\n  })\n\n  const typeName = typeComposer.getTypeName()\n  // not strictly correctly, result is `npmPackage` and `allNpmPackage` from type `NPMPackage`\n  const queryName = fieldNames.query(typeName)\n  const queryNamePlural = fieldNames.queryAll(typeName)\n\n  schemaComposer.Query.addFields({\n    [queryName]: {\n      type: typeComposer,\n      args: {\n        ...filterInputTC.getFields(),\n      },\n      resolve: findOne(typeName),\n    },\n    [queryNamePlural]: {\n      type: paginationTC,\n      args: {\n        filter: filterInputTC,\n        sort: getSortInputNestedObjects({ schemaComposer, typeComposer }),\n\n        skip: `Int`,\n        limit: `Int`,\n      },\n      resolve: findManyPaginated(typeName),\n    },\n  }).makeFieldNonNull(queryNamePlural)\n}\n\nconst parseTypes = ({\n  doc,\n  plugin,\n  createdFrom,\n  schemaComposer,\n  parentSpan,\n}) => {\n  const types = []\n  doc.definitions.forEach(def => {\n    const name = def.name.value\n    checkIsAllowedTypeName(name)\n\n    if (schemaComposer.has(name)) {\n      // We don't check if ast.kind matches composer type, but rely\n      // that this will throw when something is wrong and get\n      // reported by `reportParsingError`.\n\n      // Keep the original type composer around\n      const typeComposer = schemaComposer.get(name)\n\n      // After this, the parsed type composer will be registered as the composer\n      // handling the type name (requires cleanup after merging, see below)\n      const parsedType = schemaComposer.typeMapper.makeSchemaDef(def)\n\n      // Merging types require implemented interfaces to already exist.\n      // Depending on type creation order, interface might have not been\n      // processed yet. We check if interface already exist and create\n      // placeholder for it, if it doesn't exist yet.\n      if (parsedType.getInterfaces) {\n        parsedType.getInterfaces().forEach(iface => {\n          const ifaceName = iface.getTypeName()\n          if (!schemaComposer.has(ifaceName)) {\n            const tmpComposer = schemaComposer.createInterfaceTC(ifaceName)\n            tmpComposer.setExtension(`isPlaceholder`, true)\n          }\n        })\n      }\n\n      // Merge the parsed type with the original\n      mergeTypes({\n        schemaComposer,\n        typeComposer,\n        type: parsedType,\n        plugin,\n        createdFrom,\n        // @ts-ignore\n        parentSpan,\n      })\n\n      // Cleanup:\n      // Set the original type composer (with the merged fields added)\n      // as the correct composer for the type name and remove the temporary one\n      // `graphql-compose` doesn't make that easy 🤯\n      // TODO: clean this up when this issue is fixed:\n      //  https://github.com/graphql-compose/graphql-compose/issues/311\n      schemaComposer.set(typeComposer.getTypeName(), typeComposer)\n      schemaComposer.set(typeComposer._gqType, typeComposer)\n      schemaComposer.delete(parsedType._gqType)\n      schemaComposer.delete(parsedType)\n    } else {\n      const parsedType = schemaComposer.typeMapper.makeSchemaDef(def)\n      // @ts-ignore\n      types.push(parsedType)\n    }\n  })\n  return types\n}\n\nconst stringifyArray = arr =>\n  `[${arr.map(item =>\n    Array.isArray(item) ? stringifyArray(item) : item.toString()\n  )}]`\n\n// TODO: Import this directly from graphql-compose once we update to v7\nconst isNamedTypeComposer = type =>\n  type instanceof ObjectTypeComposer ||\n  type instanceof InputTypeComposer ||\n  type instanceof ScalarTypeComposer ||\n  type instanceof EnumTypeComposer ||\n  type instanceof InterfaceTypeComposer ||\n  type instanceof UnionTypeComposer\n\nconst validate = (type, value) => {\n  if (type instanceof GraphQLNonNull) {\n    if (value == null) {\n      throw new Error(`Expected non-null field value.`)\n    }\n    return validate(type.ofType, value)\n  } else if (type instanceof GraphQLList) {\n    if (!Array.isArray(value)) {\n      throw new Error(`Expected array field value.`)\n    }\n    return value.map(v => validate(type.ofType, v))\n  } else {\n    return type.parseValue(value)\n  }\n}\n\nconst isNodeInterface = interfaceTypeComposer =>\n  interfaceTypeComposer.hasInterface(`Node`)\n\nconst checkQueryableInterfaces = ({ schemaComposer }) => {\n  const queryableInterfaces = new Set()\n  schemaComposer.forEach(type => {\n    if (type instanceof InterfaceTypeComposer && isNodeInterface(type)) {\n      queryableInterfaces.add(type.getTypeName())\n    }\n  })\n  const incorrectTypes = new Set()\n  schemaComposer.forEach(type => {\n    if (type instanceof ObjectTypeComposer) {\n      const interfaces = type.getInterfaces()\n      if (\n        interfaces.some(iface =>\n          queryableInterfaces.has(iface.getTypeName())\n        ) &&\n        !type.hasInterface(`Node`)\n      ) {\n        incorrectTypes.add(type.getTypeName())\n      }\n    }\n  })\n  if (incorrectTypes.size) {\n    report.panic(\n      `Types implementing queryable interfaces must also implement the \\`Node\\` ` +\n        `interface. Check the type definition of ` +\n        `${Array.from(incorrectTypes)\n          .map(t => `\\`${t}\\``)\n          .join(`, `)}.`\n    )\n  }\n}\n\nconst mergeFields = ({ typeComposer, fields }) =>\n  Object.entries(fields).forEach(([fieldName, fieldConfig]) => {\n    if (typeComposer.hasField(fieldName)) {\n      typeComposer.extendField(fieldName, fieldConfig)\n    } else {\n      typeComposer.setField(fieldName, fieldConfig)\n    }\n  })\n\nconst mergeResolveType = ({ typeComposer, type }) => {\n  if (\n    (type instanceof GraphQLInterfaceType ||\n      type instanceof GraphQLUnionType) &&\n    type.resolveType\n  ) {\n    typeComposer.setResolveType(type.resolveType)\n  }\n  if (\n    (type instanceof InterfaceTypeComposer ||\n      type instanceof UnionTypeComposer) &&\n    type.getResolveType()\n  ) {\n    typeComposer.setResolveType(type.getResolveType())\n  }\n  if (!typeComposer.getResolveType()) {\n    typeComposer.setResolveType(node => node?.internal?.type)\n  }\n}\n"],"mappings":"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"}